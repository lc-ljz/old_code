var tengine=tengine||{},base=base||require("./base");tengine.ModelFactory=class{match(t){if(t.identifier.split(".").pop().toLowerCase()==="tmfile"){const s=t.buffer;if(s.length>4&&(s[0]|s[1]<<8)<4)return!0}return!1}open(t,s){return tengine.Metadata.open(s).then(i=>{const e=t.identifier.toLowerCase();try{const n=t.buffer,o=n[0]|n[1]<<8,r=n[2]|n[3]<<8;if(o!==2)throw new tengine.Error("Unsupported format version 'v"+o.toString()+"."+r.toString()+"'.");return new tengine.Model(i,n)}catch(n){const o=n&&n.message?n.message:n.toString();throw new tengine.Error(o.replace(/\.$/,"")+" in '"+e+"'.")}})}},tengine.Model=class{constructor(t,s){const i=new tengine.ModelFileReader(s);this._version=i.version,this._source=i.source,this._graphs=i.graphs.map(e=>new tengine.Graph(t,e))}get format(){return"Tengine v"+this._version}get source(){return this._source}get graphs(){return this._graphs}},tengine.Graph=class{constructor(t,s){this._name=s.id.toString(),this._inputs=[],this._outputs=[],this._nodes=[];const i=s.tensors.map(e=>new tengine.Argument(e));for(const e of s.inputs){const n=i[e];this._inputs.push(new tengine.Parameter(n.name,!0,[n]))}for(const e of s.outputs){const n=i[e];n.type&&n.type.shape&&n.type.shape.dimensions&&n.type.shape.dimensions.length==0&&n.initializer!==null||this._outputs.push(new tengine.Parameter(n.name,!0,[n]))}for(const e of s.nodes)e.type!=="INPUT"&&this._nodes.push(new tengine.Node(t,e,i))}get name(){return this._name}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}},tengine.Parameter=class{constructor(t,s,i){this._name=t,this._visible=s,this._arguments=i}get name(){return this._name}get visible(){return this._visible}get arguments(){return this._arguments}},tengine.Argument=class{constructor(t){this._name=t.name,this._type=new tengine.TensorType(t.dataType,new tengine.TensorShape(t.dims)),this._initializer=t.type===2?new tengine.Tensor(this._type,t.buffer):null}get name(){return this._name}get type(){return this._initializer?this._initializer.type:this._type}get quantization(){return null}get initializer(){return this._initializer}},tengine.Node=class{constructor(t,s,i){this._metadata=t,this._name=s.name,this._type=s.type+(s.version&&s.version!==1?":"+s.version.toString():""),this._inputs=[],this._outputs=[],this._attributes=[];const e=t.type(this._type);for(let h=0;h<s.params.length;h++){const u=e&&e.attributes&&h<e.attributes.length?e.attributes[h]:null,l=u?u.name:h.toString();this._attributes.push(new tengine.Attribute(u,l,s.params[h]))}const n=s.inputs;let o=0;if(e&&e.inputs){for(const h of e.inputs)if(o<n.length||h.option!="optional"){const u=h.option=="variadic"?n.length-o:1,l=n.slice(o,o+u).filter(p=>p!=""||h.option!="optional").map(p=>i[p]);this._inputs.push(new tengine.Parameter(h.name,!0,l)),o+=u}}else this._inputs=this._inputs.concat(n.slice(o).map((h,u)=>{const l=o+u==0?"input":(o+u).toString();return new tengine.Parameter(l,!0,[i[h]])}));const r=s.outputs;let c=0;if(e&&e.outputs){for(const h of e.outputs)if(c<r.length||h.option!="optional"){const u=h.option=="variadic"?r.length-c:1,l=r.slice(c,c+u).map(p=>i[p]);this._outputs.push(new tengine.Parameter(h.name,!0,l)),c+=u}}else this._outputs=this._outputs.concat(r.slice(c).map((h,u)=>{const l=c+u==0?"output":(c+u).toString();return new tengine.Parameter(l,!0,[i[h]])}))}get type(){return this._type.split(":")[0]}get name(){return this._name}get metadata(){return this._metadata.type(this._type)}get attributes(){return this._attributes}get inputs(){return this._inputs}get outputs(){return this._outputs}},tengine.Attribute=class{constructor(t,s,i){this._type="",this._name=s,this._value=i,t&&(this._name=t.name,t.type&&(this._type=t.type),(Object.prototype.hasOwnProperty.call(t,"visible")&&!t.visible||Object.prototype.hasOwnProperty.call(t,"default")&&(this._value==t.default||this._value&&this._value.toString()==t.default.toString()))&&(this._visible=!1))}get type(){return this._type}get name(){return this._name}get value(){return this._value}get visible(){return this._visible!=0}},tengine.Tensor=class{constructor(t,s,i){this._type=t,this._data=s,this._kind=i}get kind(){return this._kind}get type(){return this._type}get state(){return this._context().state||null}get value(){const t=this._context();return t.state?null:(t.limit=Number.MAX_SAFE_INTEGER,this._decode(t,0))}toString(){const t=this._context();if(t.state)return"";t.limit=1e4;const s=this._decode(t,0);return JSON.stringify(s,null,4)}_context(){const t={index:0,count:0,state:null};if(this._type.dataType=="?")return t.state="Tensor has unknown data type.",t;if(!this._type.shape||this._type.shape.dimensions&&this._type.shape.dimensions.length==0)return t.state="Tensor has no dimensions.",t;if(!this._data)return t.state="Tensor data is empty.",t;switch(this._type.dataType){case"int8":case"uint8":case"float16":case"float32":case"int32":case"int16":t.data=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength);break;default:t.state="Tensor data type is not implemented."}return t.dataType=this._type.dataType,t.shape=this._type.shape.dimensions,t}_decode(t,s){const i=t.shape.length==0?[1]:t.shape,e=[],n=i[s];if(s==i.length-1)for(let o=0;o<n;o++){if(t.count>t.limit)return e.push("..."),e;switch(this._type.dataType){case"float32":e.push(t.data.getFloat32(t.index,!0)),t.index+=4,t.count++;break;case"float16":e.push(t.data.getFloat16(t.index,!0)),t.index+=2,t.count++;break;case"int8":e.push(t.data.getInt8(t.index,!0)),t.index+=1,t.count++;break;case"uint8":e.push(t.data.getUint8(t.index,!0)),t.index+=1,t.count++;break;case"int32":e.push(t.data.getInt32(t.index,!0)),t.index+=4,t.count++;break;case"int16":e.push(t.data.getInt16(t.index,!0)),t.index+=2,t.count++}}else for(let o=0;o<n;o++){if(t.count>t.limit)return e.push("..."),e;e.push(this._decode(t,s+1))}return t.shape.length==0?e[0]:e}},tengine.TensorType=class{constructor(t,s){switch(t){case 0:this._dataType="float32";break;case 1:this._dataType="float16";break;case 2:this._dataType="int8";break;case 3:this._dataType="uint8";break;case 4:this._dataType="int32";break;case 5:this._dataType="int16";break;default:throw new tengine.Error("Unknown data type'"+t+"'.")}this._shape=s}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return this._dataType+this._shape.toString()}},tengine.TensorShape=class{constructor(t){this._dimensions=t}get dimensions(){return this._dimensions}toString(){return this._dimensions?"["+this._dimensions.map(t=>t?t.toString():"?").join(",")+"]":""}},tengine.Metadata=class{static open(t){return tengine.Metadata._metadata?Promise.resolve(tengine.Metadata._metadata):t.request(null,"tengine-metadata.json","utf-8").then(s=>(tengine.Metadata._metadata=new tengine.Metadata(s),tengine.Metadata._metadata)).catch(()=>(tengine.Metadata._metadata=new tengine.Metadata(null),tengine.Metadata._metadata))}constructor(t){if(this._map={},this._attributeCache={},t){const s=JSON.parse(t);if(s){for(const i of s)if(i.name&&i.schema){i.schema.name=i.name;const e=i.name+(i.version&&i.version!==1?":"+i.version.toString():"");this._map[e]=i.schema}}}}type(t){return this._map[t]||null}attribute(t,s){let i=this._attributeCache[t];if(!i){i={};const e=this.type(t);if(e&&e.attributes&&e.attributes.length>0)for(const n of e.attributes)i[n.name]=n;this._attributeCache[t]=i}return i[s]||null}},tengine.ModelFileReader=class{constructor(t){const s=new Map,i=(o,r,c,h)=>{s.set(o.toString()+":"+r.toString(),{name:c,params:h})};i(0,1,"Accuracy",[]),i(1,1,"BatchNormalization",["f","f","i"]),i(2,1,"BilinearResize",["f","f","i"]),i(3,1,"Concat",["i"]),i(4,1,"Const",[]),i(5,1,"Convolution",["i","i","i","i","i","i","i","i","i","i","i","i","i","i"]),i(6,1,"DeConvolution",["i","i","i","i","i","i","i","i","i","i","i","i","i"]),i(7,1,"DetectionOutput",["i","i","i","f","f"]),i(8,1,"DropOut",[]),i(9,1,"Eltwise",["i","i"]),i(10,1,"Flatten",["i"]),i(11,1,"FullyConnected",["i"]),i(12,1,"INPUT",[]),i(13,1,"LRN",["i","f","f","i","f"]),i(14,1,"Normalize",["i","i"]),i(15,1,"Permute",["i","i","i","i","i"]),i(16,1,"Pooling",["i","i","i","i","i","i","i","i","i","i","i"]),i(17,1,"Prelu",[]),i(18,1,"PriorBox",["f[]","f[]","f[]","f[]","i","i","i","i","i","f","f","f","i","i"]),i(19,1,"Region",["i","i","i","i","f","f","f[]"]),i(20,1,"ReLU",["f"]),i(21,1,"ReLU6",[]),i(22,1,"Reorg",["i"]),i(23,1,"Reshape",["i","i","i","i","i","i"]),i(23,2,"Reshape",["i","i","i[]"]),i(24,1,"RoiPooling",["i","i","f"]),i(25,1,"RPN",["f[]","f[]","i","i","i","i","i","f","anchors"]),i(26,1,"Scale",["i","i","i"]),i(27,1,"Slice",["i","i[]","i[]","i[]","i","i","i","i","i"]),i(28,1,"SoftMax",["i"]),i(29,1,"Split",["i","i","boolean","boolean","i[]"]),i(30,1,"DetectionPostProcess",["i","i","f","f","i","f[]"]),i(31,1,"Gemm",["f","f","i","i"]),i(32,1,"Generic",["i","i","string"]),i(33,1,"Logistic",[]),i(34,1,"LSTM",["f","f","i","i","i","i","i","i","i","i","i","i","i","i","i","i","i","i"]),i(35,1,"RNN",["f","i","i","i","i","i","i","i","i","i"]),i(36,1,"TanH",[]),i(37,1,"Sigmoid",[]),i(38,1,"Squeeze",["i","i","i","i"]),i(39,1,"FusedbnScaleRelu",[]),i(40,1,"Pad",["i","i","i","i","i","i","i","i","i","f"]),i(41,1,"StridedSlice",["i","i","i","i","i","i","i","i","i","i","i","i"]),i(42,1,"ArgMax",["i"]),i(43,1,"ArgMin",["i"]),i(44,1,"TopKV2",["i","i"]),i(45,1,"Reduction",["i","i","i","i","i","i"]),i(46,1,"Max",[]),i(47,1,"Min",[]),i(48,1,"GRU",["f","i","i","i","i","i","i","i","i","i"]),i(49,1,"Addn","i"),i(50,1,"SwapAxis",["i","i"]),i(51,1,"Upsample",["f"]),i(52,1,"SpaceToBatchND",["i","i","i","i","i","i"]),i(53,1,"BatchToSpaceND",["i","i","i","i","i","i"]),i(54,1,"Resize",["f","f","i"]),i(55,1,"ShuffleChannel",["i"]),i(56,1,"Crop",["i","i","i","i","i","i","boolean","i","i"]),i(57,1,"ROIAlign",["i","i","f"]),i(58,1,"Psroipooling",["i","i","f","i"]),i(59,1,"Unary",["i"]),i(60,1,"Expanddims",["i"]),i(61,1,"Bias",["i"]),i(62,1,"Noop",[]),i(63,1,"Threshold",["f"]),i(64,1,"Hardsigmoid",["f","f"]),i(65,1,"Embed",["f","f","f","f"]),i(66,1,"InstanceNorm",["f"]),i(67,1,"MVN",["i","i","f"]),i(68,1,"Absval",[]),i(69,1,"Cast",["i","i"]),i(70,1,"HardSwish",["f","f"]),i(71,1,"Interp",["i","i","f","f","i"]),i(72,1,"SELU",["f","f"]),i(73,1,"ELU",["f"]),i(74,1,"BroadMul",[]),i(75,1,"Logical",["i"]),i(76,1,"Gather",["i","i"]),i(77,1,"Transpose",["i[]"]),i(78,1,"Comparison",["i"]),i(79,1,"SpaceToDepth",["i"]),i(80,1,"DepthToSpace",["i"]),i(81,1,"Reverse",[]),i(82,1,"SparseToDense",["i","i","i"]),i(83,1,"Ceil",[]),i(84,1,"SquaredDifference",[]),i(85,1,"Round",[]),i(86,1,"ZerosLike",[]),i(87,1,"Clip",["f","f"]),i(88,1,"MatMul",[]),i(89,1,"ReduceL2",["i","i"]),i(90,1,"Unsqueeze",["i[]"]),i(91,1,"Num",[]);const e=new tengine.BinaryReader(t);this._majorVersion=e.uint16(),this._minorVersion=e.uint16(),this._compileVersion=e.uint16(),e.skip(2),e.seek(e.uint32()),this._originalFormat=e.int32(),this._subFormat=e.int32(),this._graphs=[];const n=e.uint32s();for(const o of n){e.seek(o);const r={};r.id=e.int32(),r.graphLayout=e.int32(),r.originalLayout=e.int32(),r.inputs=e.uint32s(),r.outputs=e.uint32s();const c=e.uint32s(),h=e.uint32s(),u=e.uint32s();r.name=e.string(),r.nodes=[],r.tensors=[],this._graphs.push(r);for(const p of c){e.seek(p);const a={};a.id=e.int32(),a.inputs=e.uint32s(),a.outputs=e.uint32s();const d=e.int32();a.name=e.string();const b=e.uint32s();a.dynamicShape=!!e.boolean(),e.seek(d),a.version=e.int32();const m=e.int32(),g=e.uint32(),y=m.toString()+":"+a.version.toString(),_=s.has(y)?s.get(y):null;a.type=_?_.name:m.toString();const w=_?_.params:[];if(a.params=[],g){e.seek(g);for(const f of w)switch(f!=="boolean"&&e.align(4),f){case"i":a.params.push(e.int32());break;case"f":a.params.push(e.float32());break;case"i[]":a.params.push(e.int32s());break;case"f[]":a.params.push(e.float32s());break;case"boolean":a.params.push(e.boolean());break;case"string":a.params.push(e.string());break;case"anchors":a.params.push(e.anchors(4));break;default:throw new tengine.Error("Unsupported param type '"+f+"' in '"+a.type+"'.")}}a.type==="Slice"&&(a.params[6]=this._originalFormat==5?a.params[6]:0),a.attributes=[];for(const f of b){e.seek(f);const k=e.string(),S=e.string(),T=e.int32();a.attributes.push({name:k,value:S,type:T})}a.type!=="Const"&&r.nodes.push(a)}const l=[];for(const p of u){e.seek(p);const a=e.uint32();e.seek(e.int32()),l.push(e.bytes(a))}for(const p of h){e.seek(p);const a={};a.id=e.int32(),a.buffer=l[e.int32()],a.dims=e.int32s(),a.name=e.string();const d=e.int32();a.layout=e.int32(),a.type=e.int32(),a.dataType=e.int32(),d&&(e.seek(d),a.quantparams={zeroPoint:e.int32(),scale:e.float32(),width:e.int32()}),r.tensors.push(a)}for(const p of r.nodes)if(p.type==="Convolution")switch(r.graphLayout){case 0:p.params[6]=r.tensors[p.inputs[1]].dims[1];break;case 1:p.params[6]=r.tensors[p.inputs[1]].dims[3]}}}get version(){return this._majorVersion+"."+this._minorVersion}get source(){switch(this._originalFormat){case 0:return"";case 1:return"Tengine";case 2:return"Caffe";case 3:return"ONNX";case 4:return"MXNet";case 5:return"TensorFlow";case 6:return"TensorFlow Lite";case 7:return"Darknet";case 8:return"DLA v"+this._subFormat;default:throw new tengine.Error("Unknown source '"+this._originalFormat.toString()+"'.")}}get graphs(){return this._graphs}},tengine.BinaryReader=class{constructor(t){this._buffer=t,this._dataView=new DataView(t.buffer,t.byteOffset,t.byteLength),this._position=0}seek(t){if(this._position=t,this._position>this._buffer.length)throw new tengine.Error("Expected "+(this._position-this._buffer.length)+" more bytes. The file might be corrupted. Unexpected end of file.")}skip(t){if(this._position+=t,this._position>this._buffer.length)throw new tengine.Error("Expected "+(this._position-this._buffer.length)+" more bytes. The file might be corrupted. Unexpected end of file.")}align(t){this._position%t!=0&&this.skip(t-this._position%t)}bytes(t){const s=this._position;return this.skip(t),this._buffer.slice(s,this._position)}byte(){return this.skip(1),this._dataView.getUint8(this._position)}boolean(){return this.byte()==0}uint16(){const t=this._position;return this.skip(2),this._dataView.getUint16(t,!0)}uint32(){const t=this._position;return this.skip(4),this._dataView.getUint32(t,!0)}uint32s(){const t=[],s=this.uint32();if(s){const i=this._position;this.seek(s);const e=this.uint32();for(let n=0;n<e;n++)t.push(this.uint32());this.seek(i)}return t}int32(){const t=this._position;return this.skip(4),this._dataView.getInt32(t,!0)}int32s(){const t=[],s=this.uint32();if(s){const i=this._position;this.seek(s);const e=this.uint32();for(let n=0;n<e;n++)t.push(this.int32());this.seek(i)}return t}float32(){const t=this._position;return this.skip(4),this._dataView.getFloat32(t,!0)}float32s(){const t=[],s=this.uint32();if(s){const i=this._position;this.seek(s);const e=this.uint32();for(let n=0;n<e;n++)t.push(this.float32());this.seek(i)}return t}anchors(t){const s=[],i=this.uint32();if(i){const e=this._position;this.seek(i);const n=this.uint32();for(let o=0;o<n;o++){const r=[];for(let c=0;c<t;c++)r.push(this.float32());s.push(r)}this.seek(e)}return s}string(){const t=this.uint32();let s="";if(t){const i=this._position;this.seek(t);const e=this.uint32();this.seek(this.uint32());for(let n=0;n<e-1;n++)s+=String.fromCharCode(this._buffer[this._position++]);this.seek(i)}return s}},tengine.Error=class extends Error{constructor(t){super(t),this.name="Error loading Tengine model."}},typeof module!="undefined"&&typeof module.exports=="object"&&(module.exports.ModelFactory=tengine.ModelFactory);
