var caffe=caffe||{},long=long||{Long:require("long")},protobuf=protobuf||require("./protobuf");caffe.ModelFactory=class{match(t){const e=t.identifier,n=e.split(".").pop().toLowerCase();if(n=="caffemodel")return!0;if(n=="pbtxt"||n=="prototxt"){if(e=="saved_model.pbtxt"||e=="saved_model.prototxt"||e.endsWith("predict_net.pbtxt")||e.endsWith("predict_net.prototxt")||e.endsWith("init_net.pbtxt")||e.endsWith("init_net.prototxt"))return!1;const s=t.tags("pbtxt");if(s.has("layer")||s.has("layers")||s.has("net")||s.has("train_net")||s.has("net_param"))return!0}if(n=="pt"){const s=t.buffer,a=[138,10,108,252,156,70,249,32,106,168,80,25];if(s&&s.length>14&&s[0]==128&&a.every((o,u)=>o==s[u+2])||s&&s.length>2&&s[0]==80&&s[1]==75)return!1;const l=t.tags("pbtxt");if(l.has("layer")||l.has("layers")||l.has("net")||l.has("train_net")||l.has("net_param"))return!0}return!1}open(t,e){return e.require("./caffe-proto").then(()=>(caffe.proto=protobuf.get("caffe").caffe,caffe.Metadata.open(e).then(n=>{const s=t.identifier.split(".").pop();if(s=="pbtxt"||s=="prototxt"||s=="pt"){const a=t.tags("pbtxt");if(a.has("net")||a.has("train_net")||a.has("net_param"))try{const l=protobuf.TextReader.create(t.text);l.field=function(u,h){if(!(h instanceof caffe.proto.SolverParameter))throw new Error("Unknown field '"+u+"'"+this.location());h[u]=this.skip()};const o=caffe.proto.SolverParameter.decodeText(l);if(o.net_param)return this._openNetParameter(n,o.net_param,e);if(o.net||o.train_net){let u=o.net||o.train_net;return u=u.split("/").pop(),t.request(u,"utf-8").then(h=>this._openNetParameterText(n,t.identifier,h,e)).catch(h=>{if(h){const i=h&&h.message?h.message:h.toString();throw new caffe.Error("Failed to load '"+u+"' ("+i.replace(/\.$/,"")+").")}})}}catch(l){}return this._openNetParameterText(n,t.identifier,t.text,e)}return this._openNetParameterBuffer(n,t.identifier,t.buffer,e)})))}_openNetParameterBuffer(t,e,n,s,a,l){try{const o=protobuf.Reader.create(n),u=caffe.proto.NetParameter.decode(o);return this._openNetParameter(t,u,s,a,l)}catch(o){throw new caffe.Error("File format is not caffe.NetParameter ("+o.message+") in '"+e+"'.")}}_openNetParameterText(t,e,n,s){try{const a=protobuf.TextReader.create(n);a.field=function(o,u){const h=u.constructor.name;if(!o.endsWith("_param")||h!="LayerParameter"&&h!="V1LayerParameter"&&h!="V0LayerParameter"){if(!u.constructor.name.endsWith("Parameter")&&u.constructor.name!=="ParamSpec")throw new Error("Unknown field '"+o+"'"+this.location());u[o]?(Array.isArray(u[o])||(u[o]=[u[o]]),u[o].push(this.skip())):u[o]=this.skip()}else u[o]=caffe.ModelFactory._decodeText(a)},a.enum=function(o){const u=this.read();if(!Object.prototype.hasOwnProperty.call(o,u)){const h=Number.parseInt(u,10);return Number.isNaN(u-h)?u:h}return o[u]};const l=caffe.proto.NetParameter.decodeText(a);return this._openNetParameter(t,l,s)}catch(a){throw new caffe.Error("File text format is not caffe.NetParameter ("+a.message+") in '"+e+"'.")}}_openNetParameter(t,e,n){try{return new caffe.Model(t,e)}catch(s){throw n.exception(s,!1),new caffe.Error(s.message)}}static _decodeText(t){const e={};for(t.start();!t.end();){const n=t.tag(),s=t.skip();e[n]?(Array.isArray(e[n])||(e[n]=[e[n]]),e[n].push(s)):e[n]=s}return e}},caffe.Model=class{constructor(t,e){this._name=e.name,e.layers&&e.layers.length>0?e.layers.every(s=>Object.prototype.hasOwnProperty.call(s,"layer"))?(this._version=0,e.layer=e.layers):(this._version=1,e.layer=e.layers):e.layer&&e.layer.length>0&&(this._version=2),this._graphs=[];const n=new Set;for(const s of e.layer)for(const a of s.include)a.phase!==void 0&&n.add(a.phase);n.size===0&&n.add(-1);for(const s of n)this._graphs.push(new caffe.Graph(t,s,e,this._version))}get format(){return"Caffe"+(this._version?" v"+this._version.toString():"")}get graphs(){return this._graphs}},caffe.Graph=class{constructor(t,e,n,s){switch(e){case 0:this._phase="TRAIN";break;case 1:this._phase="TEST";break;case-1:this._phase="";break;default:this._phase=e.toString()}this._nodes=[],this._inputs=[],this._outputs=[];for(const r of n.layer)r.input=r.bottom.slice(0),r.output=r.top.slice(0),r.chain=[];const a=[];for(const r of n.layer)(e===-1||r.include.every(p=>p.phase===e))&&a.push(r);const l={};let o=0;for(const r of a)r.input=r.input.map(p=>l[p]?l[p]:p),r.output=r.output.map(p=>(l[p]=l[p]?p+`
`+o.toString():p,l[p])),o++;const u=new Set;for(const r of a)for(const p of r.output)u.add(p);const h=[];for(const r of a)for(const p of r.input)u.has(p)||h.push(p);const i=[];let c=null,_=null;for(;a.length>0;){let r=a.shift();if(r.output.length==1&&r.input.length==1&&r.output[0].split(`
`).shift()==r.input[0].split(`
`).shift()&&c&&_==r.output[0].split(`
`).shift())c.chain=c.chain||[],c.chain.push(r);else{if((r.type=="Input"||r.type=="Data")&&r.input.length==0&&r.output.length==1&&r.input_param&&r.input_param.shape&&r.input_param.shape.length==1&&r.input_param.shape[0].dim){const p=new caffe.TensorType(null,new caffe.TensorShape(r.input_param.shape[0].dim));this._inputs.push(new caffe.Parameter(r.output[0],[new caffe.Argument(r.output[0],p)])),r=null}r&&(i.push(r),c=null,_=null,r.output.length==1&&(c=r,_=r.output[0].split(`
`).shift()))}}if(n.input)for(let r=0;r<n.input.length;r++){const p=n.input[r];if(this._inputs.some(f=>f.name===p))continue;let m=null;if(n.input_shape&&r<n.input_shape.length){const f=n.input_shape[r];f&&f.dim&&(m=new caffe.TensorType(null,new caffe.TensorShape(f.dim)))}const d=4*r;!m&&n.input_dim&&n.input_dim.length>=d&&(m=new caffe.TensorType(null,new caffe.TensorShape(n.input_dim.slice(d,d+4)))),this._inputs.push(new caffe.Parameter(p,[new caffe.Argument(p,m,null)]))}for(const r of i){const p=new caffe.Node(t,r,s);if(r.chain&&r.chain.length>0)for(const m of r.chain)p.chain.push(new caffe.Node(t,m,s));this._nodes.push(p)}this._inputs.length===0&&h.length===1&&this._inputs.push(new caffe.Parameter(h[0],[new caffe.Argument(h[0],null)]))}get name(){return this._phase}get type(){return""}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}},caffe.Parameter=class{constructor(t,e){this._name=t,this._arguments=e}get name(){return this._name}get visible(){return!0}get arguments(){return this._arguments}},caffe.Argument=class{constructor(t,e,n){if(typeof t!="string")throw new caffe.Error("Invalid argument identifier '"+JSON.stringify(t)+"'.");this._name=t,this._type=e||null,this._initializer=n||null}get name(){return this._name}get type(){return this._type}get initializer(){return this._initializer}},caffe.Node=class{constructor(t,e,n){switch(this._metadata=t,this._chain=[],this._attributes=[],n){case 0:this._name=e.layer.name,this._type=e.layer.type;break;case 1:{this._name=e.name;const i=e.type;if(i===void 0)this._type="?";else{if(!caffe.Node._typeMap){caffe.Node._typeMap={};const c={BNLL:"BNLL",HDF5:"HDF5",LRN:"LRN",RELU:"ReLU",TANH:"TanH",ARGMAX:"ArgMax",MVN:"MVN",ABSVAL:"AbsVal"};for(const _ of Object.keys(caffe.proto.V1LayerParameter.LayerType)){const r=caffe.proto.V1LayerParameter.LayerType[_];caffe.Node._typeMap[r]=_.split("_").map(p=>c[p]||p.substring(0,1)+p.substring(1).toLowerCase()).join("")}}this._type=caffe.Node._typeMap[i]||i.toString()}break}case 2:this._name=e.name,this._type=e.type}let s=[];switch(n){case 0:for(const i of Object.keys(e.layer))i!="type"&&i!="name"&&i!="blobs"&&i!="blobs_lr"&&this._attributes.push(new caffe.Attribute(t.attribute(this.type,i),i,e.layer[i]));s=e.layer.blobs.map(i=>new caffe.Tensor(i));break;case 1:case 2:for(const i of Object.keys(e))if(i.endsWith("_param")||i=="transform_param"){const c=e[i];let _=this._type;_=="Deconvolution"&&(_="Convolution");const r=Object.getPrototypeOf(c);for(const p of Object.keys(c)){const m=r[p],d=c[p];d==m||Array.isArray(d)&&Array.isArray(m)&&d.length==0&&m.length==0||this._attributes.push(new caffe.Attribute(t.attribute(this.type,p),p,d))}}e.include&&e.include.length>0&&this._attributes.push(new caffe.Attribute(this._metadata.attribute(this.type,"include"),"include",e.include)),e.exclude&&e.exclude.length>0&&this._attributes.push(new caffe.Attribute(this._metadata.attribute(this.type,"exclude"),"exclude",e.exclude)),this._type=="Data"&&e.input_param&&e.input_param.shape&&this._attributes.push(new caffe.Attribute(this._metadata.attribute(this.type,"shape"),"shape",e.input_param.shape)),s=e.blobs.map(i=>new caffe.Tensor(i))}const a=this._metadata.type(this.type);this._inputs=[];const l=e.input.concat(s);let o=0;if(a&&a.inputs){for(const i of a.inputs)if(o<l.length||i.option!="optional"){const c=i.option=="variadic"?l.length-o:1;this._inputs.push(new caffe.Parameter(i.name,l.slice(o,o+c).filter(_=>_!==""||i.option!="optional").map(_=>_ instanceof caffe.Tensor?new caffe.Argument("",_.type,_):new caffe.Argument(_,null,null)))),o+=c}}this._inputs=this._inputs.concat(l.slice(o).map(i=>new caffe.Parameter(o.toString(),[i instanceof caffe.Tensor?new caffe.Argument("",i.type,i):new caffe.Argument(i,null,null)]))),this._outputs=[];const u=e.output;let h=0;if(a&&a.outputs){for(const i of a.outputs)if(h<u.length){const c=i.option=="variadic"?u.length-h:1;this._outputs.push(new caffe.Parameter(i.name,u.slice(h,h+c).map(_=>new caffe.Argument(_,null,null)))),h+=c}}this._outputs=this._outputs.concat(u.slice(h).map((i,c)=>new caffe.Parameter((h+c).toString(),[new caffe.Argument(i,null,null)])))}get type(){return this._type}get metadata(){return this._metadata.type(this._type)}get name(){return this._name}get inputs(){return this._inputs}get outputs(){return this._outputs}get attributes(){return this._attributes}get chain(){return this._chain}},caffe.Attribute=class{constructor(t,e,n){if(this._name=e,this._value=n,n instanceof caffe.proto.BlobShape&&(this._value=new caffe.TensorShape(n.dim)),t){if(Object.prototype.hasOwnProperty.call(t,"visible")&&!t.visible)this._visible=!1;else if(Object.prototype.hasOwnProperty.call(t,"default")){const s=t.default;(this._value==s||Array.isArray(this._value)&&Array.isArray(s)&&this._value.length==s.length&&this._value.every((a,l)=>a==s[l]))&&(this._visible=!1)}}}get name(){return this._name}get value(){return this._value}get visible(){return this._visible!=0}},caffe.Tensor=class{constructor(t){this._blob=t;let e=[];Object.prototype.hasOwnProperty.call(t,"num")&&Object.prototype.hasOwnProperty.call(t,"channels")&&Object.prototype.hasOwnProperty.call(t,"width")&&Object.prototype.hasOwnProperty.call(t,"height")?(t.num!=1&&e.push(t.num),t.channels!=1&&e.push(t.channels),t.width!=1&&e.push(t.width),t.height!=1&&e.push(t.height)):Object.prototype.hasOwnProperty.call(t,"shape")&&(e=t.shape.dim);let n="?";t.data.length>0?(n="float32",this._data=t.data):t.double_data.length>0&&(n="float64",this._data=t.double_data),this._type=new caffe.TensorType(n,new caffe.TensorShape(e))}get kind(){return"Blob"}get type(){return this._type}get state(){return this._context().state}get value(){const t=this._context();return t.state?null:(t.limit=Number.MAX_SAFE_INTEGER,this._decode(t,0))}toString(){const t=this._context();if(t.state)return"";t.limit=1e4;const e=this._decode(t,0);return JSON.stringify(e,null,4)}_context(){const t={state:null,index:0,count:0};return t.data=this._data,t.dimensions=this.type.shape.dimensions,this._data||(t.state="Tensor data is empty."),t}_decode(t,e){const n=[],s=t.dimensions[e];if(e==t.dimensions.length-1)for(let a=0;a<s;a++){if(t.count>t.limit)return n.push("..."),n;n.push(t.data[t.index]),t.index++,t.count++}else for(let a=0;a<s;a++){if(t.count>t.limit)return n.push("..."),n;n.push(this._decode(t,e+1))}return n}},caffe.TensorType=class{constructor(t,e){this._dataType=t,this._shape=e}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return(this.dataType||"?")+this._shape.toString()}},caffe.TensorShape=class{constructor(t){this._dimensions=t.map(e=>e&&long.Long.isLong(e)?e.toNumber():e)}get dimensions(){return this._dimensions}toString(){return this._dimensions?"["+this._dimensions.map(t=>t.toString()).join(",")+"]":""}},caffe.Metadata=class{static open(t){return caffe.Metadata._metadata?Promise.resolve(caffe.Metadata._metadata):t.request(null,"caffe-metadata.json","utf-8").then(e=>(caffe.Metadata._metadata=new caffe.Metadata(e),caffe.Metadata._metadata)).catch(()=>(caffe.Metadata._metadata=new caffe.Metadata(null),caffe.Metadata._metadata))}constructor(t){if(this._map={},this._attributeCache={},t){const e=JSON.parse(t);if(e)for(const n of e)n.name&&n.schema&&(n.schema.name=n.name,this._map[n.name]=n.schema)}}type(t){return this._map[t]||null}attribute(t,e){let n=this._attributeCache[t];if(!n){n={};const s=this.type(t);if(s&&s.attributes&&s.attributes.length>0)for(const a of s.attributes)n[a.name]=a;this._attributeCache[t]=n}return n[e]||null}},caffe.Error=class extends Error{constructor(t){super(t),this.name="Error loading Caffe model."}},typeof module!="undefined"&&typeof module.exports=="object"&&(module.exports.ModelFactory=caffe.ModelFactory);
