var $root=protobuf.get("caffe2");$root.caffe2={},$root.caffe2.ExternalDataProto=class{constructor(){this.strides=[]}static decode(e,a){const t=new $root.caffe2.ExternalDataProto,o=e.next(a);for(;e.end(o);){const r=e.uint32();switch(r>>>3){case 1:t.source_type=e.int32();break;case 2:t.record_id=e.string();break;case 5:t.record_size=e.uint64();break;case 3:t.offset=e.int64();break;case 4:t.strides=e.array(t.strides,()=>e.int64(),r);break;default:e.skipType(7&r)}}return t}static decodeText(e){const a=new $root.caffe2.ExternalDataProto;for(e.start();!e.end();){const t=e.tag();switch(t){case"source_type":a.source_type=e.enum($root.caffe2.ExternalDataProto.SourceType);break;case"record_id":a.record_id=e.string();break;case"record_size":a.record_size=e.integer();break;case"offset":a.offset=e.integer();break;case"strides":e.array(a.strides,()=>e.integer());break;default:e.field(t,a)}}return a}},$root.caffe2.ExternalDataProto.prototype.source_type=0,$root.caffe2.ExternalDataProto.prototype.record_id="",$root.caffe2.ExternalDataProto.prototype.record_size=protobuf.Long?protobuf.Long.fromBits(0,0,!0):0,$root.caffe2.ExternalDataProto.prototype.offset=protobuf.Long?protobuf.Long.fromBits(0,0,!1):0,$root.caffe2.ExternalDataProto.SourceType={INLINE_CONTAINER:0,SIMPLE_FILE:1},$root.caffe2.TensorProto=class{constructor(){this.dims=[],this.float_data=[],this.int32_data=[],this.string_data=[],this.double_data=[],this.int64_data=[]}static decode(e,a){const t=new $root.caffe2.TensorProto,o=e.next(a);for(;e.end(o);){const r=e.uint32();switch(r>>>3){case 1:t.dims=e.array(t.dims,()=>e.int64(),r);break;case 2:t.data_type=e.int32();break;case 12:t.storage_type=e.int32();break;case 3:t.float_data=e.floats(t.float_data,r);break;case 4:t.int32_data=e.array(t.int32_data,()=>e.int32(),r);break;case 5:t.byte_data=e.bytes();break;case 6:t.string_data.push(e.bytes());break;case 9:t.double_data=e.doubles(t.double_data,r);break;case 10:t.int64_data=e.array(t.int64_data,()=>e.int64(),r);break;case 13:t.raw_data=e.bytes();break;case 14:t.external_data=$root.caffe2.ExternalDataProto.decode(e,e.uint32());break;case 7:t.name=e.string();break;case 8:t.device_detail=$root.caffe2.DeviceOption.decode(e,e.uint32());break;case 11:t.segment=$root.caffe2.TensorProto.Segment.decode(e,e.uint32());break;default:e.skipType(7&r)}}return t}static decodeText(e){const a=new $root.caffe2.TensorProto;for(e.start();!e.end();){const t=e.tag();switch(t){case"dims":e.array(a.dims,()=>e.integer());break;case"data_type":a.data_type=e.enum($root.caffe2.TensorProto.DataType);break;case"storage_type":a.storage_type=e.enum($root.caffe2.TensorProto.StorageType);break;case"float_data":e.array(a.float_data,()=>e.float());break;case"int32_data":e.array(a.int32_data,()=>e.integer());break;case"byte_data":a.byte_data=e.bytes();break;case"string_data":e.array(a.string_data,()=>e.bytes());break;case"double_data":e.array(a.double_data,()=>e.float());break;case"int64_data":e.array(a.int64_data,()=>e.integer());break;case"raw_data":a.raw_data=e.bytes();break;case"external_data":a.external_data=$root.caffe2.ExternalDataProto.decodeText(e,!0);break;case"name":a.name=e.string();break;case"device_detail":a.device_detail=$root.caffe2.DeviceOption.decodeText(e,!0);break;case"segment":a.segment=$root.caffe2.TensorProto.Segment.decodeText(e,!0);break;default:e.field(t,a)}}return a}},$root.caffe2.TensorProto.prototype.data_type=1,$root.caffe2.TensorProto.prototype.storage_type=1,$root.caffe2.TensorProto.prototype.byte_data=new Uint8Array([]),$root.caffe2.TensorProto.prototype.raw_data=new Uint8Array([]),$root.caffe2.TensorProto.prototype.external_data=null,$root.caffe2.TensorProto.prototype.name="",$root.caffe2.TensorProto.prototype.device_detail=null,$root.caffe2.TensorProto.prototype.segment=null,$root.caffe2.TensorProto.DataType={UNDEFINED:0,FLOAT:1,INT32:2,BYTE:3,STRING:4,BOOL:5,UINT8:6,INT8:7,UINT16:8,INT16:9,INT64:10,FLOAT16:12,DOUBLE:13,ZERO_COLLISION_HASH:14},$root.caffe2.TensorProto.StorageType={TYPED:1,RAW:2,EXTERNAL:3,NO_CONTENT:4},$root.caffe2.TensorProto.Segment=class{constructor(){}static decode(e,a){const t=new $root.caffe2.TensorProto.Segment,o=e.next(a);for(;e.end(o);){const r=e.uint32();switch(r>>>3){case 1:t.begin=e.int64();break;case 2:t.end=e.int64();break;default:e.skipType(7&r)}}if(!Object.prototype.hasOwnProperty.call(t,"begin"))throw new protobuf.Error("Excepted 'begin'.");if(!Object.prototype.hasOwnProperty.call(t,"end"))throw new protobuf.Error("Excepted 'end'.");return t}static decodeText(e){const a=new $root.caffe2.TensorProto.Segment;for(e.start();!e.end();){const t=e.tag();switch(t){case"begin":a.begin=e.integer();break;case"end":a.end=e.integer();break;default:e.field(t,a)}}if(!Object.prototype.hasOwnProperty.call(a,"begin"))throw new protobuf.Error("Excepted 'begin'.");if(!Object.prototype.hasOwnProperty.call(a,"end"))throw new protobuf.Error("Excepted 'end'.");return a}},$root.caffe2.TensorProto.Segment.prototype.begin=protobuf.Long?protobuf.Long.fromBits(0,0,!1):0,$root.caffe2.TensorProto.Segment.prototype.end=protobuf.Long?protobuf.Long.fromBits(0,0,!1):0,$root.caffe2.QTensorProto=class{constructor(){this.dims=[],this.data=[],this.scales=[],this.biases=[]}static decode(e,a){const t=new $root.caffe2.QTensorProto,o=e.next(a);for(;e.end(o);){const r=e.uint32();switch(r>>>3){case 1:t.dims=e.array(t.dims,()=>e.int64(),r);break;case 2:t.precision=e.int32();break;case 3:t.scale=e.double();break;case 4:t.bias=e.double();break;case 5:t.is_signed=e.bool();break;case 6:t.data=e.array(t.data,()=>e.int32(),r);break;case 7:t.name=e.string();break;case 8:t.data_type=e.int32();break;case 9:t.scales=e.doubles(t.scales,r);break;case 10:t.biases=e.doubles(t.biases,r);break;case 11:t.axis=e.int32();break;case 12:t.is_multiparam=e.bool();break;default:e.skipType(7&r)}}if(!Object.prototype.hasOwnProperty.call(t,"precision"))throw new protobuf.Error("Excepted 'precision'.");if(!Object.prototype.hasOwnProperty.call(t,"scale"))throw new protobuf.Error("Excepted 'scale'.");if(!Object.prototype.hasOwnProperty.call(t,"bias"))throw new protobuf.Error("Excepted 'bias'.");if(!Object.prototype.hasOwnProperty.call(t,"is_signed"))throw new protobuf.Error("Excepted 'is_signed'.");return t}static decodeText(e){const a=new $root.caffe2.QTensorProto;for(e.start();!e.end();){const t=e.tag();switch(t){case"dims":e.array(a.dims,()=>e.integer());break;case"precision":a.precision=e.integer();break;case"scale":a.scale=e.float();break;case"bias":a.bias=e.float();break;case"is_signed":a.is_signed=e.boolean();break;case"data":e.array(a.data,()=>e.integer());break;case"name":a.name=e.string();break;case"data_type":a.data_type=e.enum($root.caffe2.TensorProto.DataType);break;case"scales":e.array(a.scales,()=>e.float());break;case"biases":e.array(a.biases,()=>e.float());break;case"axis":a.axis=e.integer();break;case"is_multiparam":a.is_multiparam=e.boolean();break;default:e.field(t,a)}}if(!Object.prototype.hasOwnProperty.call(a,"precision"))throw new protobuf.Error("Excepted 'precision'.");if(!Object.prototype.hasOwnProperty.call(a,"scale"))throw new protobuf.Error("Excepted 'scale'.");if(!Object.prototype.hasOwnProperty.call(a,"bias"))throw new protobuf.Error("Excepted 'bias'.");if(!Object.prototype.hasOwnProperty.call(a,"is_signed"))throw new protobuf.Error("Excepted 'is_signed'.");return a}},$root.caffe2.QTensorProto.prototype.precision=0,$root.caffe2.QTensorProto.prototype.scale=0,$root.caffe2.QTensorProto.prototype.bias=0,$root.caffe2.QTensorProto.prototype.is_signed=!1,$root.caffe2.QTensorProto.prototype.name="",$root.caffe2.QTensorProto.prototype.data_type=2,$root.caffe2.QTensorProto.prototype.axis=0,$root.caffe2.QTensorProto.prototype.is_multiparam=!1,$root.caffe2.TensorProtos=class{constructor(){this.protos=[]}static decode(e,a){const t=new $root.caffe2.TensorProtos,o=e.next(a);for(;e.end(o);){const r=e.uint32();switch(r>>>3){case 1:t.protos.push($root.caffe2.TensorProto.decode(e,e.uint32()));break;default:e.skipType(7&r)}}return t}static decodeText(e){const a=new $root.caffe2.TensorProtos;for(e.start();!e.end();){const t=e.tag();switch(t){case"protos":a.protos.push($root.caffe2.TensorProto.decodeText(e,!0));break;default:e.field(t,a)}}return a}},$root.caffe2.TensorShape=class{constructor(){this.dims=[],this.unknown_dims=[]}static decode(e,a){const t=new $root.caffe2.TensorShape,o=e.next(a);for(;e.end(o);){const r=e.uint32();switch(r>>>3){case 1:t.dims=e.array(t.dims,()=>e.int64(),r);break;case 2:t.data_type=e.int32();break;case 3:t.unknown_dims=e.array(t.unknown_dims,()=>e.int32(),r);break;case 4:t.unknown_shape=e.bool();break;case 5:t.name=e.string();break;default:e.skipType(7&r)}}return t}static decodeText(e){const a=new $root.caffe2.TensorShape;for(e.start();!e.end();){const t=e.tag();switch(t){case"dims":e.array(a.dims,()=>e.integer());break;case"data_type":a.data_type=e.enum($root.caffe2.TensorProto.DataType);break;case"unknown_dims":e.array(a.unknown_dims,()=>e.integer());break;case"unknown_shape":a.unknown_shape=e.boolean();break;case"name":a.name=e.string();break;default:e.field(t,a)}}return a}},$root.caffe2.TensorShape.prototype.data_type=1,$root.caffe2.TensorShape.prototype.unknown_shape=!1,$root.caffe2.TensorShape.prototype.name="",$root.caffe2.TensorShapes=class{constructor(){this.shapes=[]}static decode(e,a){const t=new $root.caffe2.TensorShapes,o=e.next(a);for(;e.end(o);){const r=e.uint32();switch(r>>>3){case 1:t.shapes.push($root.caffe2.TensorShape.decode(e,e.uint32()));break;default:e.skipType(7&r)}}return t}static decodeText(e){const a=new $root.caffe2.TensorShapes;for(e.start();!e.end();){const t=e.tag();switch(t){case"shapes":a.shapes.push($root.caffe2.TensorShape.decodeText(e,!0));break;default:e.field(t,a)}}return a}},$root.caffe2.TensorBoundShape=class{constructor(){this.dim_type=[]}static decode(e,a){const t=new $root.caffe2.TensorBoundShape,o=e.next(a);for(;e.end(o);){const r=e.uint32();switch(r>>>3){case 1:t.shape=$root.caffe2.TensorShape.decode(e,e.uint32());break;case 2:t.dim_type=e.array(t.dim_type,()=>e.int32(),r);break;case 3:t.name=e.string();break;default:e.skipType(7&r)}}return t}static decodeText(e){const a=new $root.caffe2.TensorBoundShape;for(e.start();!e.end();){const t=e.tag();switch(t){case"shape":a.shape=$root.caffe2.TensorShape.decodeText(e,!0);break;case"dim_type":e.array(a.dim_type,()=>e.enum($root.caffe2.TensorBoundShape.DimType));break;case"name":a.name=e.string();break;default:e.field(t,a)}}return a}},$root.caffe2.TensorBoundShape.prototype.shape=null,$root.caffe2.TensorBoundShape.prototype.name="",$root.caffe2.TensorBoundShape.DimType={UNKNOWN:0,CONSTANT:1,BATCH:2,BATCH_OF_FEATURE_MAX:3,BATCH_OF_FEATURE_MAX_DEFAULT:4,FEATURE_MAX:5,FEATURE_MAX_DEFAULT:6},$root.caffe2.TensorBoundShapes=class{constructor(){this.shapes=[]}static decode(e,a){const t=new $root.caffe2.TensorBoundShapes,o=e.next(a);for(;e.end(o);){const r=e.uint32();switch(r>>>3){case 1:t.shapes.push($root.caffe2.TensorBoundShape.decode(e,e.uint32()));break;case 2:t.max_batch_size=e.int64();break;case 3:t.max_feature_len=e.int64();break;default:e.skipType(7&r)}}return t}static decodeText(e){const a=new $root.caffe2.TensorBoundShapes;for(e.start();!e.end();){const t=e.tag();switch(t){case"shapes":a.shapes.push($root.caffe2.TensorBoundShape.decodeText(e,!0));break;case"max_batch_size":a.max_batch_size=e.integer();break;case"max_feature_len":a.max_feature_len=e.integer();break;default:e.field(t,a)}}return a}},$root.caffe2.TensorBoundShapes.prototype.max_batch_size=protobuf.Long?protobuf.Long.fromBits(0,0,!1):0,$root.caffe2.TensorBoundShapes.prototype.max_feature_len=protobuf.Long?protobuf.Long.fromBits(0,0,!1):0,$root.caffe2.Argument=class{constructor(){this.floats=[],this.ints=[],this.strings=[],this.tensors=[],this.nets=[],this.qtensors=[]}static decode(e,a){const t=new $root.caffe2.Argument,o=e.next(a);for(;e.end(o);){const r=e.uint32();switch(r>>>3){case 1:t.name=e.string();break;case 2:t.f=e.float();break;case 3:t.i=e.int64();break;case 4:t.s=e.bytes();break;case 10:t.t=$root.caffe2.TensorProto.decode(e,e.uint32());break;case 8:t.n=$root.caffe2.NetDef.decode(e,e.uint32());break;case 5:t.floats=e.floats(t.floats,r);break;case 6:t.ints=e.array(t.ints,()=>e.int64(),r);break;case 7:t.strings.push(e.bytes());break;case 11:t.tensors.push($root.caffe2.TensorProto.decode(e,e.uint32()));break;case 9:t.nets.push($root.caffe2.NetDef.decode(e,e.uint32()));break;case 12:t.qtensors.push($root.caffe2.QTensorProto.decode(e,e.uint32()));break;default:e.skipType(7&r)}}return t}static decodeText(e){const a=new $root.caffe2.Argument;for(e.start();!e.end();){const t=e.tag();switch(t){case"name":a.name=e.string();break;case"f":a.f=e.float();break;case"i":a.i=e.integer();break;case"s":a.s=e.bytes();break;case"t":a.t=$root.caffe2.TensorProto.decodeText(e,!0);break;case"n":a.n=$root.caffe2.NetDef.decodeText(e,!0);break;case"floats":e.array(a.floats,()=>e.float());break;case"ints":e.array(a.ints,()=>e.integer());break;case"strings":e.array(a.strings,()=>e.bytes());break;case"tensors":a.tensors.push($root.caffe2.TensorProto.decodeText(e,!0));break;case"nets":a.nets.push($root.caffe2.NetDef.decodeText(e,!0));break;case"qtensors":a.qtensors.push($root.caffe2.QTensorProto.decodeText(e,!0));break;default:e.field(t,a)}}return a}},$root.caffe2.Argument.prototype.name="",$root.caffe2.Argument.prototype.f=0,$root.caffe2.Argument.prototype.i=protobuf.Long?protobuf.Long.fromBits(0,0,!1):0,$root.caffe2.Argument.prototype.s=new Uint8Array([]),$root.caffe2.Argument.prototype.t=null,$root.caffe2.Argument.prototype.n=null,$root.caffe2.DeviceTypeProto={PROTO_CPU:0,PROTO_CUDA:1,PROTO_MKLDNN:2,PROTO_OPENGL:3,PROTO_OPENCL:4,PROTO_IDEEP:5,PROTO_HIP:6,PROTO_FPGA:7,PROTO_MSNPU:8,PROTO_XLA:9,PROTO_COMPILE_TIME_MAX_DEVICE_TYPES:10,PROTO_ONLY_FOR_TEST:20901},$root.caffe2.DeviceOption=class{constructor(){this.extra_info=[]}static decode(e,a){const t=new $root.caffe2.DeviceOption,o=e.next(a);for(;e.end(o);){const r=e.uint32();switch(r>>>3){case 1:t.device_type=e.int32();break;case 2:t.device_id=e.int32();break;case 3:t.random_seed=e.uint32();break;case 4:t.node_name=e.string();break;case 5:t.numa_node_id=e.int32();break;case 6:t.extra_info.push(e.string());break;default:e.skipType(7&r)}}return t}static decodeText(e){const a=new $root.caffe2.DeviceOption;for(e.start();!e.end();){const t=e.tag();switch(t){case"device_type":a.device_type=e.integer();break;case"device_id":a.device_id=e.integer();break;case"random_seed":a.random_seed=e.integer();break;case"node_name":a.node_name=e.string();break;case"numa_node_id":a.numa_node_id=e.integer();break;case"extra_info":e.array(a.extra_info,()=>e.string());break;default:e.field(t,a)}}return a}},$root.caffe2.DeviceOption.prototype.device_type=0,$root.caffe2.DeviceOption.prototype.device_id=0,$root.caffe2.DeviceOption.prototype.random_seed=0,$root.caffe2.DeviceOption.prototype.node_name="",$root.caffe2.DeviceOption.prototype.numa_node_id=0,$root.caffe2.OperatorDef=class{constructor(){this.input=[],this.output=[],this.arg=[],this.control_input=[]}static decode(e,a){const t=new $root.caffe2.OperatorDef,o=e.next(a);for(;e.end(o);){const r=e.uint32();switch(r>>>3){case 1:t.input.push(e.string());break;case 2:t.output.push(e.string());break;case 3:t.name=e.string();break;case 4:t.type=e.string();break;case 5:t.arg.push($root.caffe2.Argument.decode(e,e.uint32()));break;case 6:t.device_option=$root.caffe2.DeviceOption.decode(e,e.uint32());break;case 7:t.engine=e.string();break;case 8:t.control_input.push(e.string());break;case 9:t.is_gradient_op=e.bool();break;case 10:t.debug_info=e.string();break;case 11:t.domain=e.string();break;case 12:t.op_version=e.int64();break;default:e.skipType(7&r)}}return t}static decodeText(e){const a=new $root.caffe2.OperatorDef;for(e.start();!e.end();){const t=e.tag();switch(t){case"input":e.array(a.input,()=>e.string());break;case"output":e.array(a.output,()=>e.string());break;case"name":a.name=e.string();break;case"type":a.type=e.string();break;case"arg":a.arg.push($root.caffe2.Argument.decodeText(e,!0));break;case"device_option":a.device_option=$root.caffe2.DeviceOption.decodeText(e,!0);break;case"engine":a.engine=e.string();break;case"control_input":e.array(a.control_input,()=>e.string());break;case"is_gradient_op":a.is_gradient_op=e.boolean();break;case"debug_info":a.debug_info=e.string();break;case"domain":a.domain=e.string();break;case"op_version":a.op_version=e.integer();break;default:e.field(t,a)}}return a}},$root.caffe2.OperatorDef.prototype.name="",$root.caffe2.OperatorDef.prototype.type="",$root.caffe2.OperatorDef.prototype.device_option=null,$root.caffe2.OperatorDef.prototype.engine="",$root.caffe2.OperatorDef.prototype.is_gradient_op=!1,$root.caffe2.OperatorDef.prototype.debug_info="",$root.caffe2.OperatorDef.prototype.domain="",$root.caffe2.OperatorDef.prototype.op_version=protobuf.Long?protobuf.Long.fromBits(0,0,!1):0,$root.caffe2.MapFieldEntry=class{constructor(){}static decode(e,a){const t=new $root.caffe2.MapFieldEntry,o=e.next(a);for(;e.end(o);){const r=e.uint32();switch(r>>>3){case 1:t.key=e.string();break;case 2:t.val=e.string();break;default:e.skipType(7&r)}}if(!Object.prototype.hasOwnProperty.call(t,"key"))throw new protobuf.Error("Excepted 'key'.");if(!Object.prototype.hasOwnProperty.call(t,"val"))throw new protobuf.Error("Excepted 'val'.");return t}static decodeText(e){const a=new $root.caffe2.MapFieldEntry;for(e.start();!e.end();){const t=e.tag();switch(t){case"key":a.key=e.string();break;case"val":a.val=e.string();break;default:e.field(t,a)}}if(!Object.prototype.hasOwnProperty.call(a,"key"))throw new protobuf.Error("Excepted 'key'.");if(!Object.prototype.hasOwnProperty.call(a,"val"))throw new protobuf.Error("Excepted 'val'.");return a}},$root.caffe2.MapFieldEntry.prototype.key="",$root.caffe2.MapFieldEntry.prototype.val="",$root.caffe2.BackendOptions=class{constructor(){this.option=[]}static decode(e,a){const t=new $root.caffe2.BackendOptions,o=e.next(a);for(;e.end(o);){const r=e.uint32();switch(r>>>3){case 1:t.backend_name=e.string();break;case 2:t.option.push($root.caffe2.MapFieldEntry.decode(e,e.uint32()));break;default:e.skipType(7&r)}}if(!Object.prototype.hasOwnProperty.call(t,"backend_name"))throw new protobuf.Error("Excepted 'backend_name'.");return t}static decodeText(e){const a=new $root.caffe2.BackendOptions;for(e.start();!e.end();){const t=e.tag();switch(t){case"backend_name":a.backend_name=e.string();break;case"option":a.option.push($root.caffe2.MapFieldEntry.decodeText(e,!0));break;default:e.field(t,a)}}if(!Object.prototype.hasOwnProperty.call(a,"backend_name"))throw new protobuf.Error("Excepted 'backend_name'.");return a}},$root.caffe2.BackendOptions.prototype.backend_name="",$root.caffe2.PartitionInfo=class{constructor(){this.device_id=[],this.backend_options=[]}static decode(e,a){const t=new $root.caffe2.PartitionInfo,o=e.next(a);for(;e.end(o);){const r=e.uint32();switch(r>>>3){case 1:t.name=e.string();break;case 2:t.device_id=e.array(t.device_id,()=>e.int32(),r);break;case 3:t.extra_info=e.string();break;case 4:t.backend_options.push($root.caffe2.BackendOptions.decode(e,e.uint32()));break;default:e.skipType(7&r)}}if(!Object.prototype.hasOwnProperty.call(t,"name"))throw new protobuf.Error("Excepted 'name'.");return t}static decodeText(e){const a=new $root.caffe2.PartitionInfo;for(e.start();!e.end();){const t=e.tag();switch(t){case"name":a.name=e.string();break;case"device_id":e.array(a.device_id,()=>e.integer());break;case"extra_info":a.extra_info=e.string();break;case"backend_options":a.backend_options.push($root.caffe2.BackendOptions.decodeText(e,!0));break;default:e.field(t,a)}}if(!Object.prototype.hasOwnProperty.call(a,"name"))throw new protobuf.Error("Excepted 'name'.");return a}},$root.caffe2.PartitionInfo.prototype.name="",$root.caffe2.PartitionInfo.prototype.extra_info="",$root.caffe2.NetDef=class{constructor(){this.op=[],this.arg=[],this.external_input=[],this.external_output=[],this.partition_info=[]}static decode(e,a){const t=new $root.caffe2.NetDef,o=e.next(a);for(;e.end(o);){const r=e.uint32();switch(r>>>3){case 1:t.name=e.string();break;case 2:t.op.push($root.caffe2.OperatorDef.decode(e,e.uint32()));break;case 3:t.type=e.string();break;case 4:t.num_workers=e.int32();break;case 5:t.device_option=$root.caffe2.DeviceOption.decode(e,e.uint32());break;case 6:t.arg.push($root.caffe2.Argument.decode(e,e.uint32()));break;case 7:t.external_input.push(e.string());break;case 8:t.external_output.push(e.string());break;case 9:t.partition_info.push($root.caffe2.PartitionInfo.decode(e,e.uint32()));break;default:e.skipType(7&r)}}return t}static decodeText(e){const a=new $root.caffe2.NetDef;for(e.start();!e.end();){const t=e.tag();switch(t){case"name":a.name=e.string();break;case"op":a.op.push($root.caffe2.OperatorDef.decodeText(e,!0));break;case"type":a.type=e.string();break;case"num_workers":a.num_workers=e.integer();break;case"device_option":a.device_option=$root.caffe2.DeviceOption.decodeText(e,!0);break;case"arg":a.arg.push($root.caffe2.Argument.decodeText(e,!0));break;case"external_input":e.array(a.external_input,()=>e.string());break;case"external_output":e.array(a.external_output,()=>e.string());break;case"partition_info":a.partition_info.push($root.caffe2.PartitionInfo.decodeText(e,!0));break;default:e.field(t,a)}}return a}},$root.caffe2.NetDef.prototype.name="",$root.caffe2.NetDef.prototype.type="",$root.caffe2.NetDef.prototype.num_workers=0,$root.caffe2.NetDef.prototype.device_option=null,$root.caffe2.ExecutionStep=class{constructor(){this.substep=[],this.network=[]}static decode(e,a){const t=new $root.caffe2.ExecutionStep,o=e.next(a);for(;e.end(o);){const r=e.uint32();switch(r>>>3){case 1:t.name=e.string();break;case 2:t.substep.push($root.caffe2.ExecutionStep.decode(e,e.uint32()));break;case 3:t.network.push(e.string());break;case 4:t.num_iter=e.int64();break;case 5:t.criteria_network=e.string();break;case 7:t.report_net=e.string();break;case 8:t.report_interval=e.int32();break;case 11:t.run_every_ms=e.int64();break;case 6:t.concurrent_substeps=e.bool();break;case 9:t.should_stop_blob=e.string();break;case 10:t.only_once=e.bool();break;case 12:t.create_workspace=e.bool();break;case 13:t.num_concurrent_instances=e.int32();break;default:e.skipType(7&r)}}return t}static decodeText(e){const a=new $root.caffe2.ExecutionStep;for(e.start();!e.end();){const t=e.tag();switch(t){case"name":a.name=e.string();break;case"substep":a.substep.push($root.caffe2.ExecutionStep.decodeText(e,!0));break;case"network":e.array(a.network,()=>e.string());break;case"num_iter":a.num_iter=e.integer();break;case"criteria_network":a.criteria_network=e.string();break;case"report_net":a.report_net=e.string();break;case"report_interval":a.report_interval=e.integer();break;case"run_every_ms":a.run_every_ms=e.integer();break;case"concurrent_substeps":a.concurrent_substeps=e.boolean();break;case"should_stop_blob":a.should_stop_blob=e.string();break;case"only_once":a.only_once=e.boolean();break;case"create_workspace":a.create_workspace=e.boolean();break;case"num_concurrent_instances":a.num_concurrent_instances=e.integer();break;default:e.field(t,a)}}return a}},$root.caffe2.ExecutionStep.prototype.name="",$root.caffe2.ExecutionStep.prototype.num_iter=protobuf.Long?protobuf.Long.fromBits(0,0,!1):0,$root.caffe2.ExecutionStep.prototype.criteria_network="",$root.caffe2.ExecutionStep.prototype.report_net="",$root.caffe2.ExecutionStep.prototype.report_interval=0,$root.caffe2.ExecutionStep.prototype.run_every_ms=protobuf.Long?protobuf.Long.fromBits(0,0,!1):0,$root.caffe2.ExecutionStep.prototype.concurrent_substeps=!1,$root.caffe2.ExecutionStep.prototype.should_stop_blob="",$root.caffe2.ExecutionStep.prototype.only_once=!1,$root.caffe2.ExecutionStep.prototype.create_workspace=!1,$root.caffe2.ExecutionStep.prototype.num_concurrent_instances=0,$root.caffe2.PlanDef=class{constructor(){this.network=[],this.execution_step=[]}static decode(e,a){const t=new $root.caffe2.PlanDef,o=e.next(a);for(;e.end(o);){const r=e.uint32();switch(r>>>3){case 1:t.name=e.string();break;case 2:t.network.push($root.caffe2.NetDef.decode(e,e.uint32()));break;case 3:t.execution_step.push($root.caffe2.ExecutionStep.decode(e,e.uint32()));break;default:e.skipType(7&r)}}return t}static decodeText(e){const a=new $root.caffe2.PlanDef;for(e.start();!e.end();){const t=e.tag();switch(t){case"name":a.name=e.string();break;case"network":a.network.push($root.caffe2.NetDef.decodeText(e,!0));break;case"execution_step":a.execution_step.push($root.caffe2.ExecutionStep.decodeText(e,!0));break;default:e.field(t,a)}}return a}},$root.caffe2.PlanDef.prototype.name="",$root.caffe2.BlobProto=class{constructor(){}static decode(e,a){const t=new $root.caffe2.BlobProto,o=e.next(a);for(;e.end(o);){const r=e.uint32();switch(r>>>3){case 1:t.name=e.string();break;case 2:t.type=e.string();break;case 3:t.tensor=$root.caffe2.TensorProto.decode(e,e.uint32());break;case 4:t.content=e.bytes();break;case 5:t.qtensor=$root.caffe2.QTensorProto.decode(e,e.uint32());break;case 6:t.content_num_chunks=e.int32();break;case 7:t.content_chunk_id=e.int32();break;default:e.skipType(7&r)}}return t}static decodeText(e){const a=new $root.caffe2.BlobProto;for(e.start();!e.end();){const t=e.tag();switch(t){case"name":a.name=e.string();break;case"type":a.type=e.string();break;case"tensor":a.tensor=$root.caffe2.TensorProto.decodeText(e,!0);break;case"content":a.content=e.bytes();break;case"qtensor":a.qtensor=$root.caffe2.QTensorProto.decodeText(e,!0);break;case"content_num_chunks":a.content_num_chunks=e.integer();break;case"content_chunk_id":a.content_chunk_id=e.integer();break;default:e.field(t,a)}}return a}},$root.caffe2.BlobProto.prototype.name="",$root.caffe2.BlobProto.prototype.type="",$root.caffe2.BlobProto.prototype.tensor=null,$root.caffe2.BlobProto.prototype.content=new Uint8Array([]),$root.caffe2.BlobProto.prototype.qtensor=null,$root.caffe2.BlobProto.prototype.content_num_chunks=0,$root.caffe2.BlobProto.prototype.content_chunk_id=0,$root.caffe2.DBReaderProto=class{constructor(){}static decode(e,a){const t=new $root.caffe2.DBReaderProto,o=e.next(a);for(;e.end(o);){const r=e.uint32();switch(r>>>3){case 1:t.name=e.string();break;case 2:t.source=e.string();break;case 3:t.db_type=e.string();break;case 4:t.key=e.string();break;default:e.skipType(7&r)}}return t}static decodeText(e){const a=new $root.caffe2.DBReaderProto;for(e.start();!e.end();){const t=e.tag();switch(t){case"name":a.name=e.string();break;case"source":a.source=e.string();break;case"db_type":a.db_type=e.string();break;case"key":a.key=e.string();break;default:e.field(t,a)}}return a}},$root.caffe2.DBReaderProto.prototype.name="",$root.caffe2.DBReaderProto.prototype.source="",$root.caffe2.DBReaderProto.prototype.db_type="",$root.caffe2.DBReaderProto.prototype.key="";
