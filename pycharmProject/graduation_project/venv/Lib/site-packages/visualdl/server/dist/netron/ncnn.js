var ncnn=ncnn||{},base=base||require("./base");ncnn.ModelFactory=class{match(t){const s=t.identifier.toLowerCase();if(s.endsWith(".param")||s.endsWith(".cfg.ncnn")){let e=t.text;if(e=e.substring(0,Math.min(e.length,32)),e.split(`
`).shift().trim()==="7767517")return!0}if(s.endsWith(".param.bin")){const e=t.buffer;if(e.length>4&&(e[0]|e[1]<<8|e[2]<<16|e[3]<<24)>>>0==7767517)return!0}if(s.endsWith(".bin")||s.endsWith(".weights.ncnn")){if(s=="snapshot_blob.bin"||s==="v8_context_snapshot.bin")return!1;const e=t.buffer;if(e.length>4){const n=(e[0]|e[1]<<8|e[2]<<16|e[3]<<24)>>>0;if(n===0||n===1||n===19950407||n===871224||n===180310)return!0}}return!1}open(t,s){return ncnn.Metadata.open(s).then(e=>{const n=t.identifier.toLowerCase(),a=(l,h)=>{try{return new ncnn.Model(e,l,h)}catch(p){const u=p&&p.message?p.message:p.toString();throw new ncnn.Error(u.replace(/\.$/,"")+" in '"+n+"'.")}};let o=null;if(n.endsWith(".param")||n.endsWith(".cfg.ncnn"))return n.endsWith(".param")?o=t.identifier.substring(0,t.identifier.length-6)+".bin":n.endsWith(".cfg.ncnn")&&(o=t.identifier.substring(0,t.identifier.length-9)+".weights.ncnn"),t.request(o,null).then(l=>a(t.text,l)).catch(()=>a(t.text,null));if(n.endsWith(".param.bin"))return o=t.identifier.substring(0,t.identifier.length-10)+".bin",t.request(o,null).then(l=>a(t.buffer,l)).catch(()=>a(t.buffer,null));if(n.endsWith(".bin")||n.endsWith(".weights.ncnn")){let l=null;return n.endsWith("bin")?l=t.identifier.substring(0,t.identifier.length-4)+".param":n.endsWith(".weights.ncnn")&&(l=t.identifier.substring(0,t.identifier.length-13)+".cfg.ncnn"),t.request(l,"utf-8").then(h=>a(h,t.buffer)).catch(h=>{const p=h&&h.message?h.message:h.toString();throw new ncnn.Error(p.replace(/\.$/,"")+" in '"+n+"'.")})}})}},ncnn.Model=class{constructor(t,s,e){this._graphs=[],this._graphs.push(new ncnn.Graph(t,s,e))}get format(){return"ncnn"}get graphs(){return this._graphs}},ncnn.Graph=class{constructor(t,s,e){this._inputs=[],this._outputs=[],this._nodes=[];const n=new ncnn.BlobReader(e),a=(typeof s=="string"?new ncnn.TextParamReader(s):new ncnn.BinaryParamReader(t,s)).layers;for(const o of a)if(o.type=="Input"){const l=o.attributes.map(u=>isNaN(parseInt(u.value,10))?u.value:parseInt(u.value,10)),h=new ncnn.TensorShape(l),p=new ncnn.TensorType("float32",h);this._inputs.push(new ncnn.Parameter(o.name,!0,o.outputs.map(u=>new ncnn.Argument(u,p,null))))}else this._nodes.push(new ncnn.Node(t,n,o))}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}},ncnn.Parameter=class{constructor(t,s,e){this._name=t,this._visible=s,this._arguments=e}get name(){return this._name}get visible(){return this._visible}get arguments(){return this._arguments}},ncnn.Argument=class{constructor(t,s,e){if(typeof t!="string")throw new ncnn.Error("Invalid argument identifier '"+JSON.stringify(t)+"'.");this._name=t,this._type=s||null,this._initializer=e||null}get name(){return this._name}get type(){return this._initializer?this._initializer.type:this._type}get initializer(){return this._initializer}},ncnn.Node=class{constructor(t,s,e){this._metadata=t,this._inputs=[],this._outputs=[],this._attributes=[],this._type=e.type,this._name=e.name;const n=t.operator(this._type);n&&(this._type=n);const a=t.type(this._type),o=a&&a.attributes?a&&a.attributes:[];for(const i of e.attributes){const r=o[i.key];this._attributes.push(new ncnn.Attribute(r,i.key,i.value))}const l=e.inputs;let h=0;if(a&&a.inputs){for(const i of a.inputs)if(h<l.length||i.option!="optional"){const r=i.option=="variadic"?l.length-h:1,c=l.slice(h,h+r).filter(f=>f!=""||i.option!="optional").map(f=>new ncnn.Argument(f,null,null));this._inputs.push(new ncnn.Parameter(i.name,!0,c)),h+=r}}this._inputs=this._inputs.concat(l.slice(h).map((i,r)=>{const c=h+r==0?"input":(h+r).toString();return new ncnn.Parameter(c,!0,[new ncnn.Argument(i,null,null)])}));const p=e.outputs;let u=0;if(a&&a.outputs){for(const i of a.outputs)if(u<p.length||i.option!="optional"){const r=i.option=="variadic"?p.length-u:1,c=p.slice(u,u+r).map(f=>new ncnn.Argument(f,null,null));this._outputs.push(new ncnn.Parameter(i.name,!0,c)),u+=r}}switch(this._outputs=this._outputs.concat(p.slice(u).map((i,r)=>{const c=u+r==0?"output":(u+r).toString();return new ncnn.Parameter(c,!0,[new ncnn.Argument(i,null,null)])})),this._type){case"BatchNorm":{const i=parseInt(e.attr[0]||0,10);this._weight(s,"slope",[i],"float32"),this._weight(s,"mean",[i],"float32"),this._weight(s,"variance",[i],"float32"),this._weight(s,"bias",[i],"float32");break}case"InnerProduct":{const i=parseInt(e.attr[0]||0,10),r=parseInt(e.attr[2]||0,10);this._weight(s,"weight",[i,r/i]),e.attr[1]=="1"&&this._weight(s,"bias",[i],"float32");break}case"Bias":{const i=parseInt(e.attr[0]||0,10);this._weight(s,"bias",[i],"float32");break}case"Embed":{const i=parseInt(e.attr[0]||0,10),r=parseInt(e.attr[3]||0,10);this._weight(s,"weight",[r]),e.attr[2]=="1"&&this._weight(s,"bias",[i],"float32");break}case"Convolution":case"ConvolutionDepthWise":case"Deconvolution":case"DeconvolutionDepthWise":{const i=parseInt(e.attr[0]||0,10),r=parseInt(e.attr[1]||0,10),c=parseInt(e.attr[11]||r,10),f=parseInt(e.attr[6]||0,10);this._weight(s,"weight",[i,f/(i*r*c),r,c]),e.attr[5]=="1"&&this._weight(s,"bias",[i],"float32");break}case"Dequantize":if(e.attr[1]=="1"){const i=parseInt(e.attr[2]||0,10);this._weight(s,"bias",[i],"float32")}break;case"Requantize":if(e.attr[2]=="1"){const i=parseInt(e.attr[3]||0,10);this._weight(s,"bias",[i],"float32")}break;case"InstanceNorm":{const i=parseInt(e.attr[0]||0,10);this._weight(s,"gamma",[i],"float32"),this._weight(s,"beta",[i],"float32");break}case"Scale":{const i=parseInt(e.attr[0]||0,10);i!=-233&&(this._weight(s,"scale",[i],"float32"),e.attr[1]=="1"&&this._weight(s,"bias",[i],"float32"));break}case"Normalize":{const i=parseInt(e.attr[3]||0,10);this._weight(s,"scale",[i],"float32");break}case"PReLU":{const i=parseInt(e.attr[0]||0,10);this._weight(s,"slope",[i],"float32");break}}}get type(){return this._type}get name(){return this._name}get metadata(){return this._metadata.type(this._type)}get attributes(){return this._attributes}get inputs(){return this._inputs}get outputs(){return this._outputs}_weight(t,s,e,n){const a=t.read(e,n);n=a?a.dataType||"?":n||"?";const o=a?a.data:null;this._inputs.push(new ncnn.Parameter(s,!0,[new ncnn.Argument("",null,new ncnn.Tensor(new ncnn.TensorType(n,new ncnn.TensorShape(e)),o))]))}},ncnn.Attribute=class{constructor(t,s,e){if(this._type="",this._name=s,this._value=e,t){switch(this._name=t.name,t.type&&(this._type=t.type),this._type){case"int32":this._value=parseInt(this._value,10);break;case"float32":this._value=parseFloat(this._value);break;case"float32[]":this._value=this._value.map(n=>parseFloat(n))}(Object.prototype.hasOwnProperty.call(t,"visible")&&!t.visible||Object.prototype.hasOwnProperty.call(t,"default")&&(this._value==t.default||this._value&&this._value.toString()==t.default.toString()))&&(this._visible=!1)}}get type(){return this._type}get name(){return this._name}get value(){return this._value}get visible(){return this._visible!=0}},ncnn.Tensor=class{constructor(t,s){this._type=t,this._data=s}get kind(){return"Weight"}get type(){return this._type}get state(){return this._context().state||null}get value(){const t=this._context();return t.state?null:(t.limit=Number.MAX_SAFE_INTEGER,this._decode(t,0))}toString(){const t=this._context();if(t.state)return"";t.limit=1e4;const s=this._decode(t,0);return JSON.stringify(s,null,4)}_context(){const t={index:0,count:0,state:null};if(this._type.dataType=="?")return t.state="Tensor has unknown data type.",t;if(!this._type.shape)return t.state="Tensor has no dimensions.",t;if(!this._data)return t.state="Tensor data is empty.",t;switch(this._type.dataType){case"float16":case"float32":t.data=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength);break;default:t.state="Tensor data type is not implemented."}return t.dataType=this._type.dataType,t.shape=this._type.shape.dimensions,t}_decode(t,s){const e=t.shape.length!==0?t.shape:[1],n=[],a=e[s];if(s==e.length-1)for(let o=0;o<a;o++){if(t.count>t.limit)return n.push("..."),n;switch(this._type.dataType){case"float32":n.push(t.data.getFloat32(t.index,!0)),t.index+=4,t.count++;break;case"float16":n.push(t.data.getFloat16(t.index,!0)),t.index+=2,t.count++}}else for(let o=0;o<a;o++){if(t.count>t.limit)return n.push("..."),n;n.push(this._decode(t,s+1))}return t.shape.length==0?n[0]:n}},ncnn.TensorType=class{constructor(t,s){this._dataType=t||"?",this._shape=s}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return this._dataType+this._shape.toString()}},ncnn.TensorShape=class{constructor(t){this._dimensions=t}get dimensions(){return this._dimensions}toString(){return this._dimensions?"["+this._dimensions.map(t=>t?t.toString():"?").join(",")+"]":""}},ncnn.Metadata=class{static open(t){return ncnn.Metadata._metadata?Promise.resolve(ncnn.Metadata._metadata):t.request(null,"ncnn-metadata.json","utf-8").then(s=>(ncnn.Metadata._metadata=new ncnn.Metadata(s),ncnn.Metadata._metadata)).catch(()=>(ncnn.Metadata._metadata=new ncnn.Metadata(null),ncnn.Metadata._metadatas))}constructor(t){if(this._operatorMap=new Map,this._map=new Map,this._attributeCache=new Map,t){const s=JSON.parse(t);if(s)for(const e of s)e.name&&e.schema&&(e.schema.name=e.name,this._map.set(e.name,e.schema),Object.prototype.hasOwnProperty.call(e.schema,"operator")&&this._operatorMap.set(e.schema.operator,e.name))}}operator(t){return this._operatorMap.get(t)}type(t){return this._map.get(t)}attribute(t,s){const e=t+":"+s;if(!this._attributeCache.has(e)){const n=this.type(t);if(n&&n.attributes&&n.attributes.length>0)for(const a of n.attributes)this._attributeCache.set(t+":"+a.name,a);this._attributeCache.has(e)||this._attributeCache.set(e,null)}return this._attributeCache.get(e)}},ncnn.TextParamReader=class{constructor(t){const s=t.split(/\r?\n/);if(s.shift()!=="7767517")throw new ncnn.Error("Invalid signature.");if(s.shift().split(" ").length!==2)throw new ncnn.Error("Invalid header count.");const e=[];for(;s.length>0;){const n=s.shift().trim();if(n.length>0){const a=n.split(" ").filter(p=>p.length!=0),o={};o.type=a.shift(),o.name=a.shift();const l=parseInt(a.shift(),10),h=parseInt(a.shift(),10);o.inputs=a.splice(0,l),o.outputs=a.splice(0,h),o.attr={},o.attributes=[];for(const p of a){const u=p.split("=");if(u.length===2){let i=u[0].trim(),r=u[1].trim();const c=parseInt(i,10);c<0&&(r=r.split(",").map(f=>f.trim()),r.shift(),i=(-(c+23300)).toString()),o.attr[i]=r,o.attributes.push({key:i,value:r})}}e.push(o)}}this._layers=e}get layers(){return this._layers}},ncnn.BinaryParamReader=class{constructor(t,s){const e=new ncnn.BinaryReader(s);if(e.int32()!==7767517)throw new ncnn.Error("Invalid signature.");const n=e.int32();e.int32();const a=[];for(let o=0;o<n;o++){const l=e.int32(),h={type:t.operator(l)||l.toString(),name:o.toString(),inputs:[],outputs:[],attr:{},attributes:[]},p=e.int32(),u=e.int32();for(let r=0;r<p;r++)h.inputs.push(e.int32().toString());for(let r=0;r<u;r++)h.outputs.push(e.int32().toString());let i=e.int32();for(;i!=-233;){const r=i<=-23300;if(r&&(i=-i-23300),r){const c=e.int32(),f=[];for(let _=0;_<c;_++)f.push(e.int32());h.attributes.push({key:i.toString(),value:f.toString()}),h.attr[i.toString()]=f}else{const c=e.int32();h.attributes.push({key:i.toString(),value:c.toString()}),h.attr[i.toString()]=c.toString()}i=e.int32()}a.push(h)}this._layers=a}get layers(){return this._layers}},ncnn.BlobReader=class{constructor(t){this._buffer=t,this._position=0}read(t,s){if(this._buffer){if(!s)if(this._buffer&&this._position+4<this._buffer.length){const a=this._buffer[this._position++]|this._buffer[this._position++]<<8|this._buffer[this._position++]<<16|this._buffer[this._position++]<<24;switch(a){case 0:s="float32";break;case 19950407:s="float16";break;case 871224:s="int8";break;case 1:s="qint8";break;case 180310:default:throw new ncnn.Error("Unknown weight type '"+a+"'.")}}else this._buffer=null;let e=null,n=1;if(t)for(const a of t)n*=a;else this._buffer=null;if(this._buffer&&s){const a=this._position;switch(s){case"float32":n*=4,this._position+=n,e=this._buffer.subarray(a,this._position);break;case"float16":n*=2,this._position+=n,e=this._buffer.subarray(a,this._position);break;case"int8":this._position+=n,e=this._buffer.subarray(a,this._position);break;case"qint8":this._position+=n+1024,e=null;break;default:throw new ncnn.Error("Unknown weight type '"+s+"'.")}}return{dataType:s,data:e}}return null}},ncnn.BinaryReader=class{constructor(t){this._buffer=t,this._dataView=new DataView(t.buffer,t.byteOffset,t.byteLength),this._position=0}skip(t){if(this._position+=t,this._position>this._buffer.length)throw new ncnn.Error("Expected "+(this._position-this._buffer.length)+" more bytes. The file might be corrupted. Unexpected end of file.")}int32(){const t=this._position;return this.skip(4),this._dataView.getInt32(t,!0)}},ncnn.Error=class extends Error{constructor(t){super(t),this.name="Error loading ncnn model."}},typeof module!="undefined"&&typeof module.exports=="object"&&(module.exports.ModelFactory=ncnn.ModelFactory);
