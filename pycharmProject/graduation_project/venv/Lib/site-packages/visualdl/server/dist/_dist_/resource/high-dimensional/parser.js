function M(r,t){var e=Object.keys(r);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(r);t&&(n=n.filter(function(a){return Object.getOwnPropertyDescriptor(r,a).enumerable})),e.push.apply(e,n)}return e}function p(r){for(var t=1;t<arguments.length;t++){var e=arguments[t]!=null?arguments[t]:{};t%2?M(Object(e),!0).forEach(function(n){u(r,n,e[n])}):Object.getOwnPropertyDescriptors?Object.defineProperties(r,Object.getOwnPropertyDescriptors(e)):M(Object(e)).forEach(function(n){Object.defineProperty(r,n,Object.getOwnPropertyDescriptor(e,n))})}return r}function u(r,t,e){return t in r?Object.defineProperty(r,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):r[t]=e,r}import{safeSplit as A}from"../../utils/index.js";const y="__index__",w="__metadata__",P={NUMBER_MISMATCH:Symbol("NUMBER_MISMATCH"),TENSER_EMPTY:Symbol("TENSER_EMPTY"),METADATA_EMPTY:Symbol("METADATA_EMPTY"),SHAPE_MISMATCH:Symbol("SHAPE_MISMATCH")};export class ParserError extends Error{constructor(t,e,n){super(t);u(this,"code",void 0),u(this,"data",void 0),this.code=e,this.data=n}}u(ParserError,"CODES",P);function S(r,t){return A(r,`
`).map(e=>A(e,"	").map(n=>t?t(n):n)).filter(e=>e.length)}function _(r,t,e){return r.map(n=>{const a=n.length;return a>t?n.slice(0,t):a<t?[...n,...Array.from({length:t-a}).fill(e)]:n})}function b(r){const t=Array.from({length:r}).map((n,a)=>a);let e=r;for(;e;){const n=Math.floor(Math.random()*e);e--;const a=t[e];t[e]=t[n],t[n]=a}return t}function g(r,t,e){const{count:n,dimension:a,vectors:o,metadata:l}=r,s=t?Math.min(n,t):n,i=e?Math.min(a,e):a,E=b(n),T=b(a),m=new Float32Array(s*i),h=[];for(let c=0;c<s;c++){const d=E[c]*a;if(i<a)for(let f=0;f<i;f++)m[c+f]=o[d+T[f]];else m.set(o.subarray(d,d+i),c*i);h.push(l[E[c]])}return p(p({},r),{},{count:s,dimension:i,vectors:m,metadata:h})}function D(r){if(!r)throw new ParserError("Tenser file is empty",ParserError.CODES.TENSER_EMPTY);const t=[0,0];let e=S(r,Number.parseFloat);t[0]=e.length;const n=Math.min(...e.map(a=>a.length));return t[1]=n,e=_(e,n,0),{rawShape:t,dimension:n,count:e.length,vectors:new Float32Array(e.flat())}}function I(r){if(!r)throw new ParserError("Metadata file is empty",ParserError.CODES.METADATA_EMPTY);let t=S(r);const e=t[0].length;let n=[w];return t=_(t,e,""),e>1&&(n=t.shift()),{dimension:e,labels:n,metadata:t}}function O(r,t){if(r){const e=I(r),n=e.metadata.length;if(t!==n)throw new ParserError(`Number of tensors (${t}) do not match the number of lines in metadata (${n}).`,ParserError.CODES.NUMBER_MISMATCH,{vectors:t,metadata:n});return{labels:e.labels,metadata:e.metadata}}return{labels:[y],metadata:Array.from({length:t},(e,n)=>[`${n}`])}}export function parseFromString({vectors:r,metadata:t,maxCount:e,maxDimension:n}){const a={rawShape:[0,0],count:0,dimension:0,vectors:new Float32Array,labels:[],metadata:[]};return r&&(Object.assign(a,D(r)),Object.assign(a,O(t,a.count))),g(a,e,n)}export async function parseFromBlob({shape:r,vectors:t,metadata:e,maxCount:n,maxDimension:a}){const[o,l]=r,s=new Float32Array(await t.arrayBuffer());if(o*l!==s.length)throw new ParserError("Size of tensor does not match.",ParserError.CODES.SHAPE_MISMATCH);return g(p({rawShape:r,count:o,dimension:l,vectors:s},O(e,o)),n,a)}
