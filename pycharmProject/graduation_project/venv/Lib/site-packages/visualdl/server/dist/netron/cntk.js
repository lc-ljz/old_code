var cntk=cntk||{},long=long||{Long:require("long")},protobuf=protobuf||require("./protobuf"),cntk_v1={},cntk_v2=null;cntk.ModelFactory=class{match(e){const i=e.identifier.split(".").pop().toLowerCase();if(i=="model"||i=="cmf"||i=="dnn"||i=="cntk"){const s=e.buffer,o=[138,10,108,252,156,70,249,32,106,168,80,25];if(s&&s.length>14&&s[0]==128&&o.every((t,n)=>t==s[n+2]))return!1;if(s&&s.length>=8&&s[0]==66&&s[1]==0&&s[2]==67&&s[3]==0&&s[4]==78&&s[5]==0&&s[6]==0&&s[7]==0)return!0;const a=e.tags("pb");return a.get(1)===0&&a.get(2)===2}}open(e,i){return i.require("./cntk-proto").then(()=>{let s=0,o=null;try{const a=e.buffer;a&&a.length>=8&&a[0]==66&&a[1]==0&&a[2]==67&&a[3]==0&&a[4]==78&&a[5]==0&&a[6]==0&&a[7]==0&&(o=new cntk_v1.ComputationNetwork(a),s=1)}catch(a){throw new cntk.Error("File format is not CNTK v1 ("+a.message+") in '"+e.identifier+"'.")}try{if(!o){(cntk_v2=protobuf.get("cntk").CNTK.proto).PoolingType={0:"Max",1:"Average"};const a=protobuf.Reader.create(e.buffer),t=cntk_v2.Dictionary.decode(a);o=cntk.ModelFactory._convertDictionary(t),s=2}}catch(a){throw new cntk.Error("File format is not cntk.Dictionary ("+a.message+") in '"+e.identifier+"'.")}return cntk.Metadata.open(i).then(a=>{try{return new cntk.Model(a,s,o)}catch(t){throw new cntk.Error(t.message)}})})}static _convertDictionary(e){const i={};for(const s of Object.keys(e.data).filter(o=>o!="version"))i[s]=cntk.ModelFactory._convertDictionaryValue(e.data[s]);return i}static _convertDictionaryValue(e){switch(e.value_type){case cntk_v2.DictionaryValue.Type.Bool:return e.bool_value;case cntk_v2.DictionaryValue.Type.Int:return e.int_value;case cntk_v2.DictionaryValue.Type.SizeT:return e.size_t_value;case cntk_v2.DictionaryValue.Type.Float:return e.float_value;case cntk_v2.DictionaryValue.Type.Double:return e.double_value;case cntk_v2.DictionaryValue.Type.String:return e.string_value;case cntk_v2.DictionaryValue.Type.Vector:return cntk.ModelFactory._convertVectorValue(e.vector_value);case cntk_v2.DictionaryValue.Type.NDShape:return e.nd_shape_value;case cntk_v2.DictionaryValue.Type.Axis:return e.axis_value;case cntk_v2.DictionaryValue.Type.Dictionary:return cntk.ModelFactory._convertDictionary(e.dictionary_value);case cntk_v2.DictionaryValue.Type.NDArrayView:return e.nd_array_view_value}throw new cntk.Error("Unknown dictionary value type '"+e.value_type.toString()+"'.")}static _convertVectorValue(e){return e.value.map(i=>cntk.ModelFactory._convertDictionaryValue(i))}},cntk.Model=class{constructor(e,i,s){switch(i){case 1:this._format="CNTK v1"+(s.version?"."+s.version.toString():"");break;case 2:this._format="CNTK v2"}this._graphs=[],this._graphs.push(new cntk.Graph(e,i,s))}get graphs(){return this._graphs}get format(){return this._format}},cntk.Graph=class{constructor(e,i,s){this._inputs=[],this._outputs=[],this._nodes=[],this._functions=[];const o={};switch(i){case 1:for(const a of Object.keys(s.nodes)){const t=s.nodes[a];switch(t.__type__){case"InputValue":this._inputs.push(new cntk.Parameter(t.name,[new cntk.Argument(i,t)]));break;case"LearnableParameter":o[t.name]=new cntk.Argument(i,t)}}for(const a of Object.keys(s.nodes)){const t=s.nodes[a];t.__type__!="InputValue"&&t.__type__!="LearnableParameter"&&this._nodes.push(new cntk.Node(e,i,t,o))}if(s.output)for(const a of s.output)this._outputs.push(new cntk.Parameter(a,[new cntk.Argument(i,a)]));break;case 2:{const a=new Map;for(const t of s.primitive_functions)a.set(t.uid,t);for(const t of s.inputs){const n=new cntk.Argument(i,t);if(o[t.uid]=n,t.kind==0){const r=t.name||t.uid;this._inputs.push(new cntk.Parameter(r,[n]))}}for(const t of s.primitive_functions)if(t.op==57&&t.block_function_composite){const n=[t.block_function_composite.root],r=[];for(;n.length>0;){const u=n.shift();if(a.has(u)){const p=a.get(u);r.push(new cntk.Node(e,i,p,o)),a.delete(u);for(let c=0;c<p.inputs.length;c++){const _=p.inputs[c].split("_");_.length>=3&&(_.pop(),_.pop()=="Output"&&n.push(_.join("_")))}}}const h=[],l=[t.block_function_composite.root];this._functions.push(new cntk.Function(t.block_function_op_name,r,h,l))}for(const t of s.primitive_functions)a.has(t.uid)&&this._nodes.push(new cntk.Node(e,i,t,o));break}default:throw new cntk.Error("Unsupported graph version '"+i+"'.")}}get nodes(){return this._nodes}get functions(){return this._functions}get inputs(){return this._inputs}get outputs(){return this._outputs}},cntk.Function=class{constructor(e,i,s,o){this._name=e,this._inputs=s,this._outputs=o,this._nodes=i}get name(){return this._name}get description(){return""}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}},cntk.Parameter=class{constructor(e,i){this._name=e,this._arguments=i}get name(){return this._name}get visible(){return!0}get arguments(){return this._arguments}},cntk.Argument=class{constructor(e,i){if(typeof i=="string")this._name=i;else switch(e){case 1:switch(i.__type__){case"InputValue":this._name=i.name,this._type=new cntk.TensorType(e,i.precision,i.sampleLayout),this._initializer=null;break;case"LearnableParameter":this._name=i.name,this._type=null,this._initializer=new cntk.Tensor(e,i)}break;case 2:i.value?(this._name=i.name||i.uid,this._type=null,this._initializer=new cntk.Tensor(e,i)):(this._name=i.uid,this._type=new cntk.TensorType(e,i.data_type,i.shape),this._initializer=null)}}get name(){return this._name}get type(){return this._type?this._type:this._initializer?this._initializer.type:null}get description(){return""}get initializer(){return this._initializer}},cntk.Node=class{constructor(e,i,s,o){this._metadata=e,this._attributes=[],this._inputs=[],this._outputs=[];let a=[],t=[];const n=[];switch(i){case 1:this._type=s.__type__,this._name=s.name;for(const u of Object.keys(s))u!="__type__"&&u!="name"&&u!="inputs"&&u!="precision"&&this._attributes.push(new cntk.Attribute(e.attribute(this._type,u),u,s[u]));a=s.inputs.map(u=>o[u]?o[u]:new cntk.Argument(i,u)),t=[new cntk.Argument(i,this._name)];break;case 2:{this._name=s.name||s.uid||null;const u=s.uid;if(s.op==57)this._type="Block",s.block_function_op_name&&(this._type=s.block_function_op_name,this._function=!0);else if(Object.prototype.hasOwnProperty.call(s,"op"))this._type=this._metadata.name(s.op),this.type==null&&(this._type=s.op?s.op.toString():"?");else if(this._type=s.type,s.user_defined_state)for(const p of Object.keys(s.user_defined_state))this._attributes.push(new cntk.Attribute(e.attribute(this._type,p),p,s.user_defined_state[p]));if(s.attributes)for(const p of Object.keys(s.attributes))this._attributes.push(new cntk.Attribute(e.attribute(this._type,p),p,s.attributes[p]));for(const p of s.inputs){const c=o[p];c?c.initializer?n.push(c):a.push(c):a.push(new cntk.Argument(i,p))}t.push(new cntk.Argument(i,u+"_Output_0")),a=a.concat(n);break}}let r=0;const h=this._metadata.type(this._function?"Function:"+this._type:this._type);if(h&&h.inputs){for(const u of h.inputs)if(r<a.length||u.option!="optional"){const p=u.option=="variadic"?a.length-r:1,c=[];for(const _ of a.slice(r,r+p))_.name==""&&u.option=="optional"||c.push(_);this._inputs.push(new cntk.Parameter(u.name,c)),r+=p}}this._inputs=this._inputs.concat(a.slice(r).map((u,p)=>new cntk.Parameter((r+p).toString(),[u])));let l=0;if(h&&h.outputs){for(const u of h.outputs)if(l<t.length||u.option!="optional"){const p=u.option=="variadic"?t.length-l:1;this._outputs.push(new cntk.Parameter(u.name,t.slice(l,l+p))),l+=p}}this._outputs=this._outputs.concat(t.slice(l).map(u=>new cntk.Parameter(l.toString(),[u])))}get name(){return this._name}get type(){return this._type}get function(){return this._function||!1}get metadata(){return this._metadata.type(this._function?"Function:"+this._type:this._type)}get attributes(){return this._attributes}get inputs(){return this._inputs}get outputs(){return this._outputs}},cntk.Attribute=class{constructor(e,i,s){if(this._name=i,this._value=s,this._type=null,cntk_v1&&this._value instanceof cntk_v1.TensorShape&&(this._value=new cntk.TensorShape(1,s),this._type="shape"),cntk_v2&&this._value instanceof cntk_v2.NDShape&&(this._value=new cntk.TensorShape(2,s),this._type="shape"),cntk_v2&&this._value instanceof cntk_v2.Axis){const o={__type__:"Axis"};for(const a of Object.keys(s).filter(t=>t!=="name"))o[a]=s[a];this._value=o}if(e){if(e.type){this._type=e.type;const o=cntk_v1[this._type]||cntk_v2[this._type];o&&o[this._value]&&(this._value=o[this._value])}if(Object.prototype.hasOwnProperty.call(e,"visible")&&!e.visible)this._visible=!1;else if(Object.prototype.hasOwnProperty.call(e,"default")){let o=e.default;if(typeof(s=this._value)=="function"&&(s=s()),this._type=="shape"&&(s=s.dimensions),s==o)this._visible=!1;else if(Array.isArray(s)&&Array.isArray(o)){if(o=o.slice(0,o.length),o.length>1&&o[o.length-1]==null)for(o.pop();o.length<s.length;)o.push(o[o.length-1]);s.every((a,t)=>a==o[t])&&(this._visible=!1)}}}}get name(){return this._name}get type(){return this._type}get value(){return this._value}get visible(){return this._visible!=0}},cntk.Tensor=class{constructor(e,i){switch(e){case 1:i.__type__=="LearnableParameter"&&(this._name=i.name||null,this._type=new cntk.TensorType(e,i.precision,i.sampleLayout));break;case 2:this._name=i.name||i.uid||null,this._type=new cntk.TensorType(e,i.data_type,i.shape),this._value=i.value}}get name(){return this._name}get type(){return this._type}get state(){return this._context().state||null}get value(){const e=this._context();return e.state?null:(e.limit=Number.MAX_SAFE_INTEGER,this._decode(e,0))}toString(){const e=this._context();if(e.state)return"";e.limit=1e4;const i=this._decode(e,0);return JSON.stringify(i,null,4)}_context(){const e={index:0,count:0,state:null};if(this._type.dataType=="?")return e.state="Tensor has unknown data type.",e;if(!this._type.shape)return e.state="Tensor has no dimensions.",e;const i=this._value;if(!i)return e.state="Tensor data is empty.",e;switch(this._type.dataType){case"float32":i.float_values&&i.float_values.value&&i.float_values.value.length>0?e.data=i.float_values.value:e.state="Tensor data is empty.";break;default:e.state="Tensor data type is not implemented."}return e.dataType=this._type.dataType,e.shape=this._type.shape.dimensions,e}_decode(e,i){let s=e.shape;e.shape.length==0&&(s=[1]);const o=[],a=s[i];if(i==s.length-1)for(let t=0;t<a;t++){if(e.count>e.limit)return o.push("..."),o;o.push(e.data[e.index++]),e.count++}else for(let t=0;t<a;t++){if(e.count>e.limit)return o.push("..."),o;o.push(this._decode(e,i+1))}return e.shape.length==0?o[0]:o}},cntk.TensorType=class{constructor(e,i,s){switch(this._dataType="?",e){case 1:switch(i){case"float":this._dataType="float32";break;case"double":this._dataType="float64";break;case"half":this._dataType="float16";break;case"":this._dataType="float32"}this._shape=new cntk.TensorShape(e,s);break;case 2:switch(long.Long.isLong(i)&&(i=i.toNumber()),i){case 1:this._dataType="float32"}this._shape=new cntk.TensorShape(e,s)}}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return this._dataType+this._shape.toString()}},cntk.TensorShape=class{constructor(e,i){switch(e){case 1:this._dimensions=i.dims;break;case 2:this._dimensions=i.shape_dim.map(s=>s.low==-1&&s.high==-1&&s.unsigned==1?-1:s&&long.Long.isLong(s)?s.toNumber():s)}}get dimensions(){return this._dimensions}toString(){return this._dimensions&&this._dimensions.length?"["+this._dimensions.join(",")+"]":""}},cntk.Metadata=class{static open(e){return cntk.Metadata._metadata?Promise.resolve(cntk.Metadata._metadata):e.request(null,"cntk-metadata.json","utf-8").then(i=>(cntk.Metadata._metadata=new cntk.Metadata(i),cntk.Metadata._metadata)).catch(()=>(cntk.Metadata._metadata=new cntk.Metadata(null),cntk.Metadata._metadata))}constructor(e){if(this._map={},this._attributeCache={},this._typeMap={},e){const i=JSON.parse(e);if(i){for(const s of i)if(s.name&&s.schema){const o=s.name,a=s.schema;a.name=o,this._map[o]=a,Object.prototype.hasOwnProperty.call(a,"operator")&&(this._typeMap[a.operator.toString()]=o)}}}}name(e){return this._typeMap[e]||null}type(e){return this._map[e]||null}attribute(e,i){let s=this._attributeCache[e];if(!s){s={};const o=this.type(e);if(o&&o.attributes&&o.attributes.length>0)for(const a of o.attributes)s[a.name]=a;this._attributeCache[e]=s}return s[i]||null}},cntk_v1.ComputationNetwork=class{constructor(e){const i=new cntk_v1.Reader(e);i.assert("BCN"),i.assert("BVersion"),this.version=i.uint64(),i.assert("EVersion");const s=i.uint64();i.assert("BNodeList");const o={Minus:function(){},Plus:function(){},GreaterEqual:function(){},Equal:function(){},NotEqual:function(){},Exp:function(){},Log:function(){},Reciprocal:function(){},ElementTimes:function(){},ClassificationError:function(){},RectifiedLinear:function(){},InputValue:function(t,n){this.rows=t.uint64(),this.cols=t.uint64(),this.sampleLayout=new cntk_v1.TensorShape(t,!0),this.dynamicAxisNodeName="",n>=8&&t.uint32()==1&&(this.dynamicAxisNodeName=t.string()),this.learningRateMultiplier=0,n>=10&&(this.learningRateMultiplier=t.float32())},LearnableParameter:function(t,n){if(!(n>=3))throw new cntk.Error("LeanableParameter reader implemented.");this.learningRateMultiplier=t.float32(),this.sampleLayout=new cntk_v1.TensorShape(t),this.value=new cntk_v1.Matrix(t)},CrossEntropyWithSoftmax:function(t){this.evalMode=t.uint32(),this.evalMode>2&&(this.evalMode=0,t.skip(-4))},Times:function(t,n){this.outputRank=n>=3?t.uint64():1,this.inferInputRankToMap=n>=12?t.int32():-1},Dropout:function(t,n){n>=16&&(this.rngSeed=n==16?t.uint32():t.uint64(),this.rngOffset=t.uint64())},ConvolutionBase:function(t,n){n>=5&&(this.kernelShape=new cntk_v1.TensorShape(t),this.mapCount=new cntk_v1.TensorShape(t),this.strides=new cntk_v1.TensorShape(t),this.sharing=t.booleans(t.uint64()),this.autoPadding=t.booleans(t.uint64()),this.lowerPad=new cntk_v1.TensorShape(t),this.upperPad=new cntk_v1.TensorShape(t),this.poolKind=t.enum(),this.imageLayoutKind=t.enum(),this.maxTempMemSizeInSamples=t.uint64()),n>=9&&(this.transpose=t.boolean()),n>=20&&(this.outputShape=new cntk_v1.TensorShape(t)),n>=21&&(this.ceilOutDim=t.boolean()),n>=23&&(this.includePad=t.boolean())},Convolution:function(t,n){o.ConvolutionBase.apply(this,[t,n]),n<5?(this.kernelShape=new cntk_v1.TensorShape([t.uint64(),t.uint64(),1]),this.strides=new cntk_v1.TensorShape([t.uint64(),t.uint64(),1]),this.mapCount=new cntk_v1.TensorShape([t.uint32()]),this.imageLayoutKind=t.enum(),this.autoPadding=[t.boolean()],this.maxTempMemSizeInSamples=t.uint64(),this.poolKind="None",this.convolution2D=!0,this.sharing=[!0],this.lowerPad=new cntk_v1.TensorShape([0]),this.upperPad=new cntk_v1.TensorShape([0])):(this.convolution2D=t.boolean(),this.dilation=n>=18?new cntk_v1.TensorShape(t):new cntk_v1.TensorShape([1]))},Pooling:function(t,n){o.ConvolutionBase.apply(this,[t,n])},PoolingBase:function(t){this.imageLayoutKind=t.enum(),this.windowWidth=t.uint32(),this.windowHeight=t.uint64(),this.horizontalSubsample=t.uint64(),this.verticalSubsample=t.uint64()},MaxPooling:function(t,n){o.PoolingBase.apply(this,[t,n])},ROIPooling:function(t,n){this.roiOutputShape=new cntk_v1.TensorShape(t),this.poolKind=n<26?"Max":t.enum(),this.spatialScale=n<26?.0625:t.float64()},Reshape:function(t){this.beginDimParameter=t.uint32(),this.endDimParameter=t.uint32(),this.replacementSampleLayout=new cntk_v1.TensorShape(t)},ReduceElements:function(t,n){let r=1;n>=27&&(r=t.uint32()),this.axes=[];for(let h=0;h<r;h++)this.axes.push(t.uint32());this.operation=t.string(),n>=24&&(this.keepDimensions=t.boolean())},BatchNormalization:function(t,n){let r=0;if(n>=6)this.spatial=t.boolean(),this.normalizationTimeConstant=t.float64(),this.blendTimeConstant=t.float64(),this.imageLayoutKind=t.enum(),n>=13?this.runCountUntied=n!=19?t.uint64():t.boolean()?0:"SIZE_MAX":r=t.uint64(),this.epsilon=t.float64(),this.useCntkEngine=t.boolean();else{const h=t.int32(),l=t.int32();if(l>h||h<65537||l>65540)throw new cntk.Error("BatchNormalization version not supported.");this.eval=t.boolean(),this.spatial=t.boolean(),h>=65540?this.normalizationTimeConstant=t.float64():t.float64(),h>=65538&&(this.imageLayoutKind=t.enum(),r=t.uint64()),h>=65539&&(this.epsilon=t.float64(),this.useCntkEngine=t.boolean())}n<13&&(this.runCountUntied=16*r,this.convertRunningVariancePending=!0)},Tanh:function(){},Sigmoid:function(){},Logistic:function(){},SquareError:function(){},ErrorPrediction:function(){},RowStack:function(t,n){this.spliceDim=n>=3?t.int32():1},Slice:function(t,n){let r=1;n>=22&&(r=t.int32()),this.index=[],this.axis=[],this.strideMultiplier=[];for(let h=0;h<r;h++)this.index.push([[t.uint64(),t.uint64()]]),n>=3&&this.axis.push(t.int32()),n>=27&&this.strideMultiplier.push(t.int32())},PastValue:function(t,n){if(this.timeStep=t.int32(),n>3)this.sampleLayout=new cntk_v1.TensorShape(t,!1);else{const r=t.uint64();t.uint64(),this.sampleLayout=new cntk_v1.TensorShape([r],!0)}n>=2&&(this.initialStateValue=t.int32())},FutureValue:function(t,n){if(this.timeStep=t.int32(),n>3)this.sampleLayout=new cntk_v1.TensorShape(t,!1);else{const r=t.uint64();t.uint64(),this.sampleLayout=new cntk_v1.TensorShape([r],!0)}n>=2&&(this.initialStateValue=t.int32())},TransposeDimensions:function(t,n){if(n>=3){if(this.axis1=t.int32(),this.axis2=t.int32(),n>=25&&this.axis1==0&&this.axis2==0){const r=t.uint64();this.perm=[];for(let h=0;h<r;h++)this.perm.push(t.uint64())}}else this.axis1=1,this.axis2=2},AveragePooling:function(t,n){o.PoolingBase.apply(this,[t,n])},InvStdDev:function(t){this.hasComputed=t.boolean(),this.value=new cntk_v1.Matrix(t)},Mean:function(t){this.hasComputed=t.boolean(),this.value=new cntk_v1.Matrix(t)},PerDimMeanVarNormalization:function(){},Softmax:function(){},DynamicAxis:function(){}},a=[];this.nodes={};for(let t=0;t<s;t++){const n=this.version>=7?i.string():"";if(n!="float"&&n!="double"&&n!="half"&&n!="")throw new cntk.Error("Invalid precision format '"+n+"'.");const r={__type__:i.string()};r.name=i.string(),r.precision=n;const h=o[r.__type__];if(!h)throw new cntk.Error("Unknown node type '"+r.__type__+"'.");h.apply(r,[i,this.version]),a.push(r),this.nodes[r.name]=r}i.assert("ENodeList"),i.assert("BRelation");for(let t=0;t<s;t++){const n=i.string(),r=this.nodes[n],h=i.uint64(),l=[];for(let u=0;u<h;u++)l.push(i.string());if(this.version<19&&r.__type__=="BatchNormalization"){const u={__type__:"LearnableParameter",name:n+".run_sample_count",precision:r.precision,sampleLayout:new cntk_v1.TensorShape([1]),learningRateMultiplier:0};a.push(u),this.nodes[u.name]=u,l.push(u.name)}r.__type__=="Convolution"&&l.length>1&&l.splice(0,0,l.pop()),r.inputs=l}i.assert("ERelation"),i.assert("BRootNodes"),i.match("BFeatureNodes")&&(this.feature=i.strings(i.uint64()),i.assert("EFeatureNodes")),i.match("BLabelNodes")&&(this.label=i.strings(i.uint64()),i.assert("ELabelNodes")),i.match("BCriterionNodes")&&(this.criterion=i.strings(i.uint64()),i.assert("ECriterionNodes")),this.criterion.length==0&&i.match("BCriteriaNodes")&&(this.criterion=i.strings(i.uint64()),i.assert("ECriteriaNodes")),i.match("BNodesReqMultiSeqHandling")&&(i.strings(i.uint64()),i.assert("ENodesReqMultiSeqHandling")),i.match("BEvalNodes")&&(this.eval=i.strings(i.uint64()),i.assert("EEvalNodes")),i.match("BOutputNodes")&&(this.output=i.strings(i.uint64()),i.assert("EOutputNodes")),i.match("BPairNodes")&&(this.pair=i.strings(i.uint64()),i.assert("EPairNodes")),i.assert("ERootNodes"),i.assert("ECN")}},cntk_v1.Reader=class{constructor(e){this._buffer=e,this._dataView=new DataView(e.buffer,e.byteOffset,e.byteLength),this._position=0}match(e){const i=this._position;for(let s=0;s<e.length;s++)if(this.uint16()!=e.charCodeAt(s))return this._position=i,!1;return this.uint16()==0||(this._position=i,!1)}assert(e){if(!this.match(e))throw new cntk_v1.Error("Invalid '"+e+"' signature.")}skip(e){if(this._position+=e,this._position>this._buffer.length)throw new cntk.Error("Expected "+(this._position-this._buffer.length)+" more bytes. The file might be corrupted. Unexpected end of file.")}boolean(){return this.byte()!=0}booleans(e){const i=[];for(let s=0;s<e;s++)i.push(this.boolean());return i}byte(){const e=this._position;return this.skip(1),this._dataView.getUint8(e)}bytes(e){const i=this._position;return this.skip(e),this._buffer.subarray(i,this._position)}uint16(){const e=this._position;return this.skip(2),this._dataView.getUint16(e,!0)}int32(){const e=this._position;return this.skip(4),this._dataView.getInt32(e,!0)}uint32(){const e=this._position;return this.skip(4),this._dataView.getUint32(e,!0)}uint64(){const e=this.uint32(),i=this.uint32();if(i>65536)throw new cntk_v1.Error("Value not in 48-bit range.");return i<<32|e}float32(){const e=this._position;return this.skip(4),this._dataView.getFloat32(e,!0)}float64(){const e=this._position;return this.skip(8),this._dataView.getFloat64(e,!0)}string(){let e="",i=this.uint16();for(;i!=0;)e+=String.fromCharCode(i),i=this.uint16();return e}strings(e){const i=[];for(let s=0;s<e;s++)i.push(this.string());return i}enum(){return this.int32()}},cntk_v1.TensorShape=class{constructor(e,i=!1){if(e&&Array.isArray(e))return void(this.dims=e);this.dims=[];const s=e.uint32();let o=0;if(s>0&&(o=e.uint32()),i&&o==0){const a=e.uint32();this.dims.push(e.uint32()),this.dims.push(s),this.dims.push(a)}else{s>0&&this.dims.push(o);for(let a=1;a<s;a++)this.dims.push(e.uint32())}}},cntk_v1.Matrix=class{constructor(e){const i=e.byte();switch(i){case 100:{e.assert("BMAT");const s=e.uint64();this.name=e.string(),this.format=e.uint32(),this.rows=e.uint64(),this.columns=e.uint64(),e.bytes(s*this.rows*this.columns),e.assert("EMAT");break}case 115:throw new cntk_v1.Error("Matrix sparse type not implemented.");default:throw new cntk_v1.Error("Matrix type '"+i.toString()+"' not implemented.")}}},cntk_v1.ImageLayoutKind={0:"CHW",1:"HWC"},cntk_v1.PoolKind={0:"None",1:"Max",2:"Average"},cntk_v1.Error=class extends Error{constructor(e){super(e),this.name="Error loading CNTK v1 model."}},cntk.Error=class extends Error{constructor(e){super(e),this.name="Error loading CNTK model."}},typeof module!="undefined"&&typeof module.exports=="object"&&(module.exports.ModelFactory=cntk.ModelFactory);
