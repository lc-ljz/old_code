var zip=zip||{};zip.Archive=class{constructor(e){if(this._entries=[],e.length<4||e[0]!=80||e[1]!=75)throw new zip.Error("Invalid Zip archive.");let t=null;for(let i=e.length-4;i>=0;i--)if(e[i]===80&&e[i+1]===75&&e[i+2]===5&&e[i+3]===6){t=new zip.Reader(e,i+4,e.length);break}if(!t)throw new zip.Error("End of central directory not found.");for(t.skip(12),t.position=t.uint32();t.match([80,75,1,2]);)this._entries.push(new zip.Entry(t))}get entries(){return this._entries}},zip.Entry=class{constructor(e){if(e.uint16(),e.skip(2),this._flags=e.uint16(),(1&this._flags)==1)throw new zip.Error("Encrypted entries not supported.");this._compressionMethod=e.uint16(),e.uint32(),e.uint32(),this._compressedSize=e.uint32(),this._size=e.uint32();let t=e.uint16(),i=e.uint16();const r=e.uint16();e.uint16(),e.uint16(),e.uint32();const s=e.uint32();e.skip(t),e.skip(i),e.bytes(r);const o=e.position;if(e.position=s,!e.match([80,75,3,4]))throw new zip.Error("Invalid local file header signature.");e.skip(22),t=e.uint16(),i=e.uint16();const a=e.bytes(t);this._name="";for(const n of a)this._name+=String.fromCharCode(n);e.skip(i),this._compressedData=e.bytes(this._compressedSize),e.position=o}get name(){return this._name}get data(){if(!this._data){switch(this._compressionMethod){case 0:if(this._size!=this._compressedSize)throw new zip.Error("Invalid compression size.");this._data=new Uint8Array(this._compressedData.length),this._data.set(this._compressedData);break;case 8:if(this._data=new zip.Inflater().inflateRaw(this._compressedData),this._size!=this._data.length)throw new zip.Error("Invalid uncompressed size.");break;default:throw new zip.Error("Invalid compression method.")}delete this._size,delete this._compressedData}return this._data}},zip.HuffmanTree=class{constructor(){this.table=new Uint16Array(16),this.symbol=new Uint16Array(288),zip.HuffmanTree._offsets=zip.HuffmanTree._offsets||new Uint16Array(16)}build(e,t,i){for(let s=0;s<16;++s)this.table[s]=0;for(let s=0;s<i;++s)this.table[e[t+s]]++;this.table[0]=0;let r=0;for(let s=0;s<16;s++)zip.HuffmanTree._offsets[s]=r,r+=this.table[s];for(let s=0;s<i;s++)e[t+s]&&(this.symbol[zip.HuffmanTree._offsets[e[t+s]]++]=s)}static initialize(){if(!zip.HuffmanTree.staticLiteralLengthTree){zip.HuffmanTree.staticLiteralLengthTree=new zip.HuffmanTree,zip.HuffmanTree.staticLiteralLengthTree.table=new Uint8Array([0,0,0,0,0,0,0,24,152,112,0,0,0,0,0,0]);for(let e=0;e<24;++e)zip.HuffmanTree.staticLiteralLengthTree.symbol[e]=256+e;for(let e=0;e<144;++e)zip.HuffmanTree.staticLiteralLengthTree.symbol[24+e]=e;for(let e=0;e<8;++e)zip.HuffmanTree.staticLiteralLengthTree.symbol[168+e]=280+e;for(let e=0;e<112;++e)zip.HuffmanTree.staticLiteralLengthTree.symbol[176+e]=144+e;zip.HuffmanTree.staticDistanceTree=new zip.HuffmanTree,zip.HuffmanTree.staticDistanceTree.table=new Uint8Array([0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0]),zip.HuffmanTree.staticDistanceTree.symbol=new Uint8Array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31])}}},zip.Inflater=class{inflate(e){if(typeof process=="object"&&typeof process.versions=="object"&&process.versions.node!==void 0)return require("zlib").inflateSync(e);if(typeof pako!="undefined")return pako.inflate(e);throw new zip.Error("zlib inflate not supported.")}inflateRaw(e){if(typeof process=="object"&&typeof process.versions=="object"&&process.versions.node!==void 0)return require("zlib").inflateRawSync(e);if(typeof pako!="undefined")return pako.inflateRaw(e);zip.Inflater.initilize(),zip.HuffmanTree.initialize();const t=new zip.BitReader(e),i=new zip.Ouptut,r=new zip.HuffmanTree,s=new zip.HuffmanTree;let o;do switch(o=t.bits(3),o>>>1){case 0:this._inflateUncompressedBlock(t,i);break;case 1:this._inflateBlockData(t,i,zip.HuffmanTree.staticLiteralLengthTree,zip.HuffmanTree.staticDistanceTree);break;case 2:this._decodeTrees(t,r,s),this._inflateBlockData(t,i,r,s);break;default:throw new zip.Error("Unknown block type.")}while((1&o)==0);return i.merge()}_inflateUncompressedBlock(e,t){for(;e.data>8;)e.position--,e.data-=8;e.data=0;const i=e.uint16();if(i!==(65535&~e.uint16()))throw new zip.Error("Invalid uncompressed block length.");const r=e.bytes(i);t.push(r),i>32768?(t.buffer.set(r.subarray(r.length-32768,r.length),0),t.position=32768):(t.reset(),t.buffer.set(r,t.position),t.position+=r.length)}_decodeTrees(e,t,i){const r=e.bits(5)+257,s=e.bits(5)+1,o=e.bits(4)+4;for(let n=0;n<19;n++)zip.Inflater._lengths[n]=0;for(let n=0;n<o;n++)zip.Inflater._lengths[zip.Inflater._codeOrder[n]]=e.bits(3);let a;zip.Inflater._codeTree.build(zip.Inflater._lengths,0,19);for(let n=0;n<r+s;){const f=e.symbol(zip.Inflater._codeTree);switch(f){case 16:{const h=zip.Inflater._lengths[n-1];for(a=e.bits(2)+3;a;a--)zip.Inflater._lengths[n++]=h;break}case 17:for(a=e.bits(3)+3;a;a--)zip.Inflater._lengths[n++]=0;break;case 18:for(a=e.bits(7)+11;a;a--)zip.Inflater._lengths[n++]=0;break;default:zip.Inflater._lengths[n++]=f}}t.build(zip.Inflater._lengths,0,r),i.build(zip.Inflater._lengths,r,s)}_inflateBlockData(e,t,i,r){const s=t.buffer;let o=t.position,a=o;for(;;){o>62464&&(t.position=o,t.push(new Uint8Array(s.subarray(a,o))),o=t.reset(),a=o);let n=e.symbol(i);if(n===256)return t.position=o,t.push(new Uint8Array(s.subarray(a,t.position))),void t.reset();if(n<256)s[o++]=n;else{n-=257;const f=e.bitsBase(zip.Inflater._lengthBits[n],zip.Inflater._lengthBase[n]),h=e.symbol(r);let u=o-e.bitsBase(zip.Inflater._distanceBits[h],zip.Inflater._distanceBase[h]);for(let l=0;l<f;l++)s[o++]=s[u++]}}}static initilize(){zip.HuffmanTree.staticLiteralLengthTree||(zip.Inflater._codeOrder=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],zip.Inflater._codeTree=new zip.HuffmanTree,zip.Inflater._lengths=new Uint8Array(320),zip.Inflater._lengthBits=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,6],zip.Inflater._lengthBase=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,323],zip.Inflater._distanceBits=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],zip.Inflater._distanceBase=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577])}},zip.Ouptut=class{constructor(){this._blocks=[],this.buffer=new Uint8Array(65536),this.position=0}reset(){return this.position>32768&&(this.buffer.set(this.buffer.subarray(this.position-32768,this.position),0),this.position=32768),this.position}push(e){this._blocks.push(e)}merge(){let e=0;for(const r of this._blocks)e+=r.length;const t=new Uint8Array(e);let i=0;for(const r of this._blocks)t.set(r,i),i+=r.length;return t}},zip.BitReader=class{constructor(e){this.buffer=e,this.position=0,this.data=0,this.value=0}bits(e){for(;this.data<24;)this.value|=this.buffer[this.position++]<<this.data,this.data+=8;const t=this.value&65535>>>16-e;return this.value>>>=e,this.data-=e,t}bitsBase(e,t){if(e==0)return t;for(;this.data<24;)this.value|=this.buffer[this.position++]<<this.data,this.data+=8;const i=this.value&65535>>>16-e;return this.value>>>=e,this.data-=e,i+t}bytes(e){const t=this.buffer.subarray(this.position,this.position+e);return this.position+=e,t}uint16(){const e=this.buffer[this.position]|this.buffer[this.position+1]<<8;return this.position+=2,e}symbol(e){for(;this.data<24;)this.value|=this.buffer[this.position++]<<this.data,this.data+=8;let t=0,i=0,r=0,s=this.value;const o=e.table;do i=(i<<1)+(1&s),s>>>=1,r++,t+=o[r],i-=o[r];while(i>=0);return this.value=s,this.data-=r,e.symbol[t+i]}},zip.Reader=class{constructor(e,t,i){this._buffer=e,this._position=t,this._end=i}match(e){if(this._position+e.length<=this._end){for(let t=0;t<e.length;t++)if(this._buffer[this._position+t]!=e[t])return!1}return this._position+=e.length,!0}get position(){return this._position}set position(e){this._position=e>=0?e:this._end+e}peek(){return this._position<this._end}skip(e){if(this._position+e>this._end)throw new zip.Error("Data not available.");this._position+=e}bytes(e){if(this._position+e>this._end)throw new zip.Error("Data not available.");e=e===void 0?this._end:e;const t=this._buffer.subarray(this._position,this._position+e);return this._position+=e,t}uint16(){if(this._position+2>this._end)throw new zip.Error("Data not available.");const e=this._buffer[this._position]|this._buffer[this._position+1]<<8;return this._position+=2,e}uint32(){return this.uint16()|this.uint16()<<16}},zip.Error=class extends Error{constructor(e){super(e),this.name="Zip Error"}},typeof module!="undefined"&&typeof module.exports=="object"&&(module.exports.Archive=zip.Archive,module.exports.Inflater=zip.Inflater);
