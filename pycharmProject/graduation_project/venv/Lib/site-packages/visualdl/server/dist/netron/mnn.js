var mnn=mnn||{},base=base||require("./base"),flatbuffers=flatbuffers||require("./flatbuffers");mnn.ModelFactory=class{match(e){return e.identifier.split(".").pop().toLowerCase()=="mnn"}open(e,a){return a.require("./mnn-schema").then(s=>mnn.Metadata.open(a).then(i=>{const r=e.identifier;try{mnn.schema=flatbuffers.get("mnn").MNN;const t=new flatbuffers.Reader(e.buffer),n=mnn.schema.Net.create(t);return new mnn.Model(i,n)}catch(t){a.exception(t,!1);const n=t&&t.message?t.message:t.toString();throw new mnn.Error(n.replace(/\.$/,"")+" in '"+r+"'.")}}))}},mnn.Model=class{constructor(e,a){switch(a.sourceType){case mnn.schema.NetSource.CAFFE:this._source="Caffe";break;case mnn.schema.NetSource.TENSORFLOW:this._source="TensorFlow";break;case mnn.schema.NetSource.TFLITE:this._source="TensorFlow Lite";break;case mnn.schema.NetSource.ONNX:this._source="ONNX"}this._graphs=[new mnn.Graph(e,a)]}get format(){return"MNN v2"}get source(){return this._source||""}get graphs(){return this._graphs}},mnn.Graph=class{constructor(e,a){this._nodes=[],this._inputs=[],this._outputs=[];const s=new Set;for(let i=0;i<a.oplists.length;i++){const r=a.oplists[i];if(r.type===mnn.schema.OpType.Input){const t=[];for(let n=0;n<r.outputIndexes.length;n++){const o=r.outputIndexes[n],h=a.tensorName[o],c=a.extraTensorDescribe[o],u=c?c.blob:null,p=u?new mnn.TensorType(u.dataType,new mnn.TensorShape(u.dims)):null;t.push(new mnn.Argument(h,p,null))}this._inputs.push(new mnn.Parameter(r.name,!0,t))}else this._nodes.push(new mnn.Node(e,r,a));for(let t=0;t<r.inputIndexes.length;t++){const n=r.inputIndexes[t];s.add(n)}}for(let i=0;i<a.tensorName.length;i++)if(!s.has(i)){const r=a.tensorName[i],t=a.extraTensorDescribe[i],n=t?t.blob:null,o=n?new mnn.TensorType(n.dataType,new mnn.TensorShape(n.dims)):null;this._outputs.push(new mnn.Parameter(r,!0,[new mnn.Argument(r,o,null)]))}}get name(){return""}get groups(){return!1}get nodes(){return this._nodes}get outputs(){return this._outputs}get inputs(){return this._inputs}},mnn.Node=class{constructor(e,a,s){this._metadata=e,this._type=mnn.Utility.enum("OpType",a.type)||"("+a.type.toString()+")",this._name=a.name||"",this._attributes=[],this._inputs=[],this._outputs=[],this._chains=[];const i=[];for(let n=0;n<a.inputIndexes.length;n++){const o=a.inputIndexes[n],h=s.tensorName[o];i.push(new mnn.Argument(h,null,null))}this._inputs.push(new mnn.Parameter("input",!0,i));const r=[];for(let n=0;n<a.outputIndexes.length;n++){const o=a.outputIndexes[n],h=s.tensorName[o];r.push(new mnn.Argument(h,null,null))}this._outputs.push(new mnn.Parameter("output",!0,r));const t=a.main;if(t){const n=new Set;if(t instanceof mnn.schema.Blob){const o=new mnn.TensorType(t.dataType,new mnn.TensorShape(t.dims));let h=null;switch(o.dataType){case"int32":h=t.int32s;break;case"float32":h=t.float32s}this._inputs.push(new mnn.Parameter("value",!0,[new mnn.Argument("",null,new mnn.Tensor("Blob",o,h))]))}else if(t instanceof mnn.schema.Convolution2D){const o=t.common,h=o.outputCount,c=o.inputCount,u=o.kernelX,p=o.kernelY;this._buildTensor(mnn.schema.DataType.DT_FLOAT,"weight",[h,c,u,p],t.weight),this._buildTensor(mnn.schema.DataType.DT_FLOAT,"bias",[h],t.bias),n.add("weight"),n.add("bias")}else if(t instanceof mnn.schema.InnerProduct){const o=t.outputCount,h=t.weightSize/o;this._buildTensor(mnn.schema.DataType.DT_FLOAT,"weight",[o,h],t.weight),this._buildTensor(mnn.schema.DataType.DT_FLOAT,"bias",[o],t.bias),n.add("weight"),n.add("bias")}else if(t instanceof mnn.schema.Scale){const o=t.channels;this._buildTensor(mnn.schema.DataType.DT_FLOAT,"scale",[o],t.scaleData),this._buildTensor(mnn.schema.DataType.DT_FLOAT,"bias",[o],t.biasData),n.add("scaleData"),n.add("biasData")}else if(t instanceof mnn.schema.BatchNorm){const o=t.channels;this._buildTensor(mnn.schema.DataType.DT_FLOAT,"mean",[o],t.meanData),this._buildTensor(mnn.schema.DataType.DT_FLOAT,"slope",[o],t.slopeData),this._buildTensor(mnn.schema.DataType.DT_FLOAT,"variance",[o],t.varData),this._buildTensor(mnn.schema.DataType.DT_FLOAT,"bias",[o],t.biasData),n.add("slopeData"),n.add("meanData"),n.add("varData"),n.add("biasData")}else t instanceof mnn.schema.PRelu?(this._buildTensor(mnn.schema.DataType.DT_FLOAT,"slope",[t.slopeCount],t.slope),n.add("slope")):t instanceof mnn.schema.Normalize&&(this._buildTensor(mnn.schema.DataType.DT_FLOAT,"scale",[t.scale.length],t.scale),n.add("scale"));n.size>0&&this._buildAttributes(e,t,n,this._attributes)}}_buildTensor(e,a,s,i){this._inputs.push(new mnn.Parameter(a,!0,[new mnn.Argument("",null,new mnn.Tensor("Weight",new mnn.TensorType(e,new mnn.TensorShape(s)),i))]))}_buildAttributes(e,a,s,i){if(a)for(const r of Object.keys(a)){if(s&&s.has(r))continue;const t=a[r];if(Object.keys(mnn.schema).find(n=>mnn.schema[n].prototype&&t instanceof mnn.schema[n]))this._buildAttributes(e,t,null,i);else if(t){const n=e.attribute(this.type,r);i.push(new mnn.Attribute(n,r,t))}}}get type(){return this._type}get name(){return this._name}get domain(){return null}get metadata(){return this._metadata.type(this.type)}get group(){return null}get inputs(){return this._inputs}get outputs(){return this._outputs}get chain(){return this._chains}get attributes(){return this._attributes}},mnn.Attribute=class{constructor(e,a,s,i){if(this._type=null,this._value=ArrayBuffer.isView(s)?Array.from(s):s,this._name=a,this._visible=i,e&&e.type){this._type=e.type;const r=mnn.schema[this._type+"Name"];r&&(this._value=r[this._value])}}get name(){return this._name}get type(){return this._type}get value(){return this._value}get visible(){return this._visible!=0}},mnn.Parameter=class{constructor(e,a,s){this._name=e,this._visible=a,this._arguments=s}get name(){return this._name}get visible(){return this._visible}get arguments(){return this._arguments}},mnn.Argument=class{constructor(e,a,s){this._name=e,this._type=a||null,this._initializer=s||null}get name(){return this._name}get type(){return this._initializer?this._initializer.type:this._type}get initializer(){return this._initializer}},mnn.Tensor=class{constructor(e,a,s){this._kind=e,this._type=a,this._data=s.slice(0)}get kind(){return this._kind}get type(){return this._type}get state(){return this._context().state}get value(){const e=this._context();return e.state?null:(e.limit=Number.MAX_SAFE_INTEGER,this._decode(e,0))}toString(){const e=this._context();if(e.state)return"";e.limit=1e4;const a=this._decode(e,0);return JSON.stringify(a,null,4)}_context(){const e={state:null};return this._data&&this._data.length!==0?(e.index=0,e.count=0,e.dataType=this._type.dataType,e.dimensions=this._type.shape.dimensions,e.data=this._data,e):(e.state="Tensor data is empty.",e)}_decode(e,a){let s=e.dimensions;s.length==0&&(s=[1]);const i=[],r=s[a];if(a==s.length-1)for(let t=0;t<r;t++){if(e.count>e.limit)return i.push("..."),i;i.push(e.data[e.index]),e.index++,e.count++}else for(let t=0;t<r;t++){if(e.count>e.limit)return i.push("..."),i;i.push(this._decode(e,a+1))}return e.dimensions.length==0?i[0]:i}},mnn.TensorType=class{constructor(e,a){switch(e){case mnn.schema.DataType.DT_INVALID:this._dataType="?";break;case mnn.schema.DataType.DT_FLOAT:this._dataType="float32";break;case mnn.schema.DataType.DT_DOUBLE:this._dataType="float64";break;case mnn.schema.DataType.DT_INT32:this._dataType="int32";break;case mnn.schema.DataType.DT_UINT8:this._dataType="uint8";break;case mnn.schema.DataType.DT_INT16:this._dataType="int16";break;case mnn.schema.DataType.DT_INT8:this._dataType="int8";break;case mnn.schema.DataType.DT_STRING:this._dataType="string";break;case mnn.schema.DataType.DT_COMPLEX64:this._dataType="complex64";break;case mnn.schema.DataType.DT_INT64:this._dataType="int64";break;case mnn.schema.DataType.DT_BOOL:this._dataType="boolean";break;case mnn.schema.DataType.DT_QINT8:this._dataType="qint8";break;case mnn.schema.DataType.DT_QUINT8:this._dataType="quint8";break;case mnn.schema.DataType.DT_QINT32:this._dataType="qint32";break;case mnn.schema.DataType.DT_BFLOAT16:this._dataType="bfloat16";break;case mnn.schema.DataType.DT_QINT16:this._dataType="qint16";break;case mnn.schema.DataType.DT_QUINT16:this._dataType="quint16";break;case mnn.schema.DataType.DT_UINT16:this._dataType="uint16";break;case mnn.schema.DataType.DT_COMPLEX128:this._dataType="complex128";break;case mnn.schema.DataType.DT_HALF:this._dataType="float16";break;case mnn.schema.DataType.DT_RESOURCE:this._dataType="resource";break;case mnn.schema.DataType.DT_VARIANT:this._dataType="variant";break;default:throw new mnn.Error("Unknown data type '"+JSON.stringify(e)+"'.")}this._shape=a}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return this._dataType+this._shape.toString()}},mnn.TensorShape=class{constructor(e){this._dimensions=Array.from(e)}get dimensions(){return this._dimensions}toString(){return this._dimensions&&this._dimensions.length>0?"["+this._dimensions.map(e=>e?e.toString():"?").join(",")+"]":""}},mnn.Metadata=class{static open(e){return mnn.Metadata._metadata?Promise.resolve(mnn.Metadata._metadata):e.request(null,"mnn-metadata.json","utf-8").then(a=>(mnn.Metadata._metadata=new mnn.Metadata(a),mnn.Metadata._metadata)).catch(()=>(mnn.Metadata._metadata=new mnn.Metadata(null),mnn.Metadata._metadata))}constructor(e){if(this._map=new Map,e){const a=JSON.parse(e);if(a)for(const s of a)s.name&&s.schema&&(s.schema.name=s.name,this._map.set(s.name,s.schema))}}type(e){return this._map.has(e)?this._map.get(e):null}attribute(e,a){const s=this.type(e);if(s){let i=s.attributeMap;if(!i){if(i={},s.attributes)for(const t of s.attributes)i[t.name]=t;s.attributeMap=i}const r=i[a];if(r)return r}return null}},mnn.Utility=class{static enum(e,a){const s=e&&mnn.schema?mnn.schema[e]:void 0;if(s){if(mnn.Utility._enumKeyMap=mnn.Utility._enumKeyMap||new Map,!mnn.Utility._enumKeyMap.has(e)){const r=new Map;for(const t of Object.keys(s))r.set(s[t],t);mnn.Utility._enumKeyMap.set(e,r)}const i=mnn.Utility._enumKeyMap.get(e);if(i.has(a))return i.get(a)}return a}},mnn.Error=class extends Error{constructor(e){super(e),this.name="Error loading MNN model."}},typeof module!="undefined"&&typeof module.exports=="object"&&(module.exports.ModelFactory=mnn.ModelFactory);
