var npz=npz||{},long=long||{Long:require("long")};npz.ModelFactory=class{match(e){if(e.identifier.split(".").pop().toLowerCase()==="npz"){const t=e.entries("zip");return t.length>0&&t.every(n=>n.name.endsWith(".npy"))}return!1}open(e,t){return t.require("./numpy").then(n=>t.require("./pickle").then(h=>{const s=e.identifier;try{const u=[],p=new Map,g=new Map,l=new Map;g.set("_codecs.encode",function(i){return i}),l.set("numpy.core.multiarray._reconstruct",function(i,d,c){this.subtype=i,this.shape=d,this.dtype=c,this.__setstate__=function(a){this.version=a[0],this.shape=a[1],this.typecode=a[2],this.is_f_order=a[3],this.rawdata=a[4]},this.__read__=function(a){const o={};o.__type__=this.subtype,o.dtype=this.typecode,o.shape=this.shape;let r=o.dtype.itemsize;for(let m=0;m<o.shape.length;m++)r*=o.shape[m];if(typeof this.rawdata=="string"){if(o.data=a.unescape(this.rawdata,r),o.data.length!=r)throw new npz.Error("Invalid string array data size.")}else o.data=this.rawdata,o.data.length;return o}}),l.set("numpy.dtype",function(i,d,c){switch(i){case"i1":this.name="int8",this.itemsize=1;break;case"i2":this.name="int16",this.itemsize=2;break;case"i4":this.name="int32",this.itemsize=4;break;case"i8":this.name="int64",this.itemsize=8;break;case"u1":this.name="uint8",this.itemsize=1;break;case"u2":this.name="uint16",this.itemsize=2;break;case"u4":this.name="uint32",this.itemsize=4;break;case"u8":this.name="uint64",this.itemsize=8;break;case"f4":this.name="float32",this.itemsize=4;break;case"f8":this.name="float64",this.itemsize=8;break;default:if(i.startsWith("V"))this.itemsize=Number(i.substring(1)),this.name="void"+(8*this.itemsize).toString();else if(i.startsWith("O"))this.itemsize=Number(i.substring(1)),this.name="object";else if(i.startsWith("S"))this.itemsize=Number(i.substring(1)),this.name="string";else if(i.startsWith("U"))this.itemsize=Number(i.substring(1)),this.name="string";else{if(!i.startsWith("M"))throw new npz.Error("Unknown dtype '"+i.toString()+"'.");this.itemsize=Number(i.substring(1)),this.name="datetime"}}this.align=d,this.copy=c,this.__setstate__=function(a){switch(a.length){case 8:this.version=a[0],this.byteorder=a[1],this.subarray=a[2],this.names=a[3],this.fields=a[4],this.elsize=a[5],this.alignment=a[6],this.int_dtypeflags=a[7];break;default:throw new npz.Error("Unknown numpy.dtype setstate length '"+a.length.toString()+"'.")}}});const _=(i,d)=>{if(g.has(i))return g.get(i).apply(null,d);const c={__type__:i};if(!l.has(i))throw new npz.Error("Unknown function '"+i+"'.");return l.get(i).apply(c,d),c},y=new Map([["i1","int8"],["i2","int16"],["i4","int32"],["i8","int64"],["u1","uint8"],["u2","uint16"],["u4","uint32"],["u8","uint64"],["f2","float16"],["f4","float32"],["f8","float64"]]);for(const i of e.entries("zip")){if(!i.name.endsWith(".npy"))throw new npz.Error("Invalid file name '"+i.name+"'.");const d=i.name.replace(/\.npy$/,"").split("/"),c=d.pop(),a=d.length>=2?d.join("/"):"";if(!p.has(a)){const m={name:a,parameters:[]};u.push(m),p.set(a,m)}const o=p.get(a);let r=new n.Array(i.data);if(r.byteOrder==="|"){if(r.dataType!=="O")throw new npz.Error("Invalid data type '"+r.dataType+"'.");r={dataType:new h.Unpickler(r.data).load(_).dtype.name,shape:null,data:null,byteOrder:"|"}}o.parameters.push({name:c,dataType:y.has(r.dataType)?y.get(r.dataType):r.dataType,shape:r.shape,data:r.data,byteOrder:r.byteOrder})}return new npz.Model(u,"NumPy Zip")}catch(u){const p=u&&u.message?u.message:u.toString();throw new npz.Error(p.replace(/\.$/,"")+" in '"+s+"'.")}}))}},npz.Model=class{constructor(e,t){this._format=t,this._graphs=[],this._graphs.push(new npz.Graph(e))}get format(){return this._format}get graphs(){return this._graphs}},npz.Graph=class{constructor(e){this._nodes=[];for(const t of e)this._nodes.push(new npz.Node(t))}get inputs(){return[]}get outputs(){return[]}get nodes(){return this._nodes}},npz.Parameter=class{constructor(e,t){this._name=e,this._arguments=t}get name(){return this._name}get visible(){return!0}get arguments(){return this._arguments}},npz.Argument=class{constructor(e,t){if(typeof e!="string")throw new npz.Error("Invalid argument identifier '"+JSON.stringify(e)+"'.");this._name=e,this._initializer=t||null}get name(){return this._name}get type(){return this._initializer.type}get initializer(){return this._initializer}},npz.Node=class{constructor(e){this._name=e.name,this._inputs=[];for(const t of e.parameters){const n=this._name?[this._name,t.name].join("/"):t.name,h=new npz.Tensor(n,t.dataType,t.shape,t.data,t.byteOrder);this._inputs.push(new npz.Parameter(t.name,[new npz.Argument(n,h)]))}}get type(){return"Module"}get name(){return this._name}get metadata(){return null}get inputs(){return this._inputs}get outputs(){return[]}get attributes(){return[]}},npz.Tensor=class{constructor(e,t,n,h,s){this._name=e,this._type=new npz.TensorType(t,new npz.TensorShape(n)),this._shape=n,this._data=h,this._byteOrder=s}get kind(){return""}get name(){return this._name}get type(){return this._type}get state(){return this._context().state}get value(){const e=this._context();return e.state?null:(e.limit=Number.MAX_SAFE_INTEGER,this._decode(e,0))}toString(){const e=this._context();if(e.state)return"";e.limit=1e4;const t=this._decode(e,0);return npz.Tensor._stringify(t,"","    ")}_context(){const e={index:0,count:0,state:null};if(this._byteOrder!=="<"&&this._byteOrder!==">")return e.state="Tensor byte order is not supported.",e;if(this._reference)return e.state="Tensor reference not implemented.",e;if(!this._data||this._data.length==0)return e.state="Tensor data is empty.",e;switch(this._type.dataType){case"float16":e.itemSize=2;break;case"float32":e.itemSize=4;break;case"float64":e.itemSize=8;break;case"int8":e.itemSize=1;break;case"int16":e.itemSize=2;break;case"int32":e.itemSize=4;break;case"int64":e.itemSize=8;break;case"uint8":e.itemSize=1;break;case"uint16":e.itemSize=2;break;case"uint32":e.itemSize=4;break;default:return e.state="Tensor data type is not supported.",e}return e.dimensions=this._type.shape.dimensions,e.dataType=this._type.dataType,e.littleEndian=this._byteOrder=="<",e.data=this._data,e.rawData=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength),e}_decode(e,t){const n=e.littleEndian,h=e.dimensions.length==0?[1]:e.dimensions,s=[],u=h[t];if(t==h.length-1)for(let p=0;p<u;p++){if(e.count>e.limit)return s.push("..."),s;if(e.rawData){switch(e.dataType){case"float16":s.push(e.rawData.getFloat16(e.index,n));break;case"float32":s.push(e.rawData.getFloat32(e.index,n));break;case"float64":s.push(e.rawData.getFloat64(e.index,n));break;case"int8":s.push(e.rawData.getInt8(e.index,n));break;case"int16":s.push(e.rawData.getInt16(e.index,n));break;case"int32":s.push(e.rawData.getInt32(e.index,n));break;case"int64":s.push(long.Long.fromBytes(e.data.subarray(e.index,e.index+8),!0,n));break;case"uint8":s.push(e.rawData.getUint8(e.index,n));break;case"uint16":s.push(e.rawData.getUint16(e.index,n));break;case"uint32":s.push(e.rawData.getUint32(e.index,n))}e.index+=e.itemSize,e.count++}}else for(let p=0;p<u;p++){if(e.count>e.limit)return s.push("..."),s;s.push(this._decode(e,t+1))}return e.dimensions.length==0?s[0]:s}static _stringify(e,t,n){if(Array.isArray(e)){const h=[];h.push(t+"[");const s=e.map(u=>npz.Tensor._stringify(u,t+n,n));return s.length>0&&h.push(s.join(`,
`)),h.push(t+"]"),h.join(`
`)}return typeof e=="string"?t+e:e==1/0?t+"Infinity":e==-1/0?t+"-Infinity":isNaN(e)?t+"NaN":t+e.toString()}},npz.TensorType=class{constructor(e,t){this._dataType=e,this._shape=t}get dataType(){return this._dataType||"?"}get shape(){return this._shape}toString(){return this.dataType+this._shape.toString()}},npz.TensorShape=class{constructor(e){this._dimensions=e}get dimensions(){return this._dimensions}toString(){return this._dimensions&&this._dimensions.length!=0?"["+this._dimensions.join(",")+"]":""}},npz.Error=class extends Error{constructor(e){super(e),this.name="Error loading Chainer model."}},typeof module!="undefined"&&typeof module.exports=="object"&&(module.exports.ModelFactory=npz.ModelFactory);
