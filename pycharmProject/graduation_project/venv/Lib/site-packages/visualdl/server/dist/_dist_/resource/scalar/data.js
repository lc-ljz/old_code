import N from"../../../web_modules/bignumberjs.js";import h from"../../../web_modules/lodash/compact.js";import f from"../../../web_modules/lodash/maxBy.js";import g from"../../../web_modules/lodash/minBy.js";import{quantile as x}from"../../utils/index.js";export const transform=({datasets:n,smoothing:i})=>n.map(o=>{const e=o.map(m=>[...m,Number.NaN,Number.NaN]);let r=new N(e.length>0?0:Number.NaN),l=0,c=0;const u=new N(i);return e.forEach((m,a)=>{const t=new N(m[2]),s=m[0]=Math.floor(m[0]);if(a===0&&(c=s),m[4]=Math.floor(s-c),!t.isFinite())m[3]=t.toNumber();else{r=r.multipliedBy(u).plus(u.minus(1).negated().multipliedBy(t)),l++;let p=new N(1);u.isEqualTo(1)||(p=u.exponentiatedBy(l).minus(1).negated()),m[3]=r.dividedBy(p).toNumber()}}),e}),singlePointRange=n=>({min:n?Math.min(n*2,0):-.5,max:n?Math.max(n*2,0):.5}),range=({datasets:n})=>n==null?void 0:n.map(i=>{var o,e;if(i.length==0)return{min:Number.NaN,max:Number.NaN};const r=i.map(l=>l[2]);return{min:(o=Math.min(...r))!==null&&o!==void 0?o:Number.NaN,max:(e=Math.max(...r))!==null&&e!==void 0?e:Number.NaN}}),axisRange=({datasets:n,outlier:i})=>{var o,e,r,l;const c=h(n==null?void 0:n.map(a=>{if(a.length===0)return;const t=a.map(d=>d[2]);if(i){const d=a.map(b=>b[2]).sort();return{min:x(d,.05),max:x(t,.95)}}else{var s,p;return{min:(s=Math.min(...t))!==null&&s!==void 0?s:0,max:(p=Math.max(...t))!==null&&p!==void 0?p:0}}})),u=(o=(e=g(c,a=>a.min))===null||e===void 0?void 0:e.min)!==null&&o!==void 0?o:0,m=(r=(l=f(c,a=>a.max))===null||l===void 0?void 0:l.max)!==null&&r!==void 0?r:0;if(!(u===0&&m===0))return{min:u>0?u*.9:u*1.1,max:m>0?m*1.1:m*.9}},nearestPoint=(n,i,o,e)=>{const r=[];return n.forEach((l,c)=>{const u=i[c];let m=Number.POSITIVE_INFINITY,a=e;for(let t=0;t<l.length;t++){const s=Math.abs(l[t][o]-e);m>s&&(m=s,a=l[t][o])}r.push(...l.filter(t=>t[o]===a).map(t=>({run:u,item:t})))}),r},parseSmoothing=n=>{const i=Number.parseFloat(String(n));let o=.6;return Number.isFinite(i)&&i<1&&i>=0&&(o=Math.round(i*100)/100),o};
