var uff=uff||{},base=base||require("./base"),long=long||{Long:require("long")},protobuf=protobuf||require("./protobuf");uff.ModelFactory=class{match(t){const s=t.identifier,a=s.split(".").pop().toLowerCase();if(a==="uff"||a==="pb"){const n=t.tags("pb");if(n.size>0&&n.has(1)&&n.get(1)===0&&n.has(2)&&n.get(2)===0&&n.has(3)&&n.get(3)===2&&n.has(4)&&n.get(4)===2&&n.has(5)&&n.get(5)===2)return!0}if(a==="pbtxt"||s.toLowerCase().endsWith(".uff.txt")){const n=t.tags("pbtxt");if(n.has("version")&&n.has("descriptors")&&n.has("graphs"))return!0}return!1}open(t,s){return s.require("./uff-proto").then(()=>{let a=null;const n=t.identifier;if(n.split(".").pop().toLowerCase()==="pbtxt"||n.toLowerCase().endsWith(".uff.txt"))try{uff.proto=protobuf.get("uff").uff;const e=protobuf.TextReader.create(t.text);a=uff.proto.MetaGraph.decodeText(e)}catch(e){throw new uff.Error("File text format is not uff.MetaGraph ("+e.message+") in '"+n+"'.")}else try{uff.proto=protobuf.get("uff").uff;const e=protobuf.Reader.create(t.buffer);a=uff.proto.MetaGraph.decode(e)}catch(e){throw new uff.Error("File format is not uff.MetaGraph ("+e.message+") in '"+n+"'.")}return uff.Metadata.open(s).then(e=>{try{return new uff.Model(e,a)}catch(i){s.exception(i,!1);const r=i&&i.message?i.message:i.toString();throw new uff.Error(r.replace(/\.$/,"")+" in '"+n+"'.")}})})}},uff.Model=class{constructor(t,s){this._version=s.version,this._imports=s.descriptors.map(n=>n.id+" v"+n.version.toString()).join(", ");const a=new Map(s.referenced_data.map(n=>[n.key,n.value]));for(const n of s.graphs)for(const e of n.nodes)for(const i of e.fields)i.value.type==="ref"&&a.has(i.value.ref)&&(i.value=a.get(i.value.ref));this._graphs=s.graphs.map(n=>new uff.Graph(t,n))}get format(){return"UFF"+(this._version?" v"+this._version.toString():"")}get imports(){return this._imports}get graphs(){return this._graphs}},uff.Graph=class{constructor(t,s){this._name=s.id,this._inputs=[],this._outputs=[],this._nodes=[];const a=new Map,n=new Map;for(const e of s.nodes){for(const i of e.inputs)n.set(i,n.has(i)?n.get(i)+1:1),a.set(i,new uff.Argument(i));a.has(e.id)||a.set(e.id,new uff.Argument(e.id))}for(let e=s.nodes.length-1;e>=0;e--){const i=s.nodes[e];if(i.operation==="Const"&&i.inputs.length===0&&n.get(i.id)===1){const r={};for(const o of i.fields)r[o.key]=o.value;if(r.dtype&&r.shape&&r.values){const o=new uff.Tensor(r.dtype,r.shape,r.values);a.set(i.id,new uff.Argument(i.id,o.type,o)),s.nodes.splice(e,1)}}if(i.operation==="Input"&&i.inputs.length===0){const r={};for(const h of i.fields)r[h.key]=h.value;const o=r.dtype&&r.shape?new uff.TensorType(r.dtype,r.shape):null;a.set(i.id,new uff.Argument(i.id,o,null))}}for(const e of s.nodes)e.operation!=="Input"?e.operation!=="MarkOutput"||e.inputs.length!==1?this._nodes.push(new uff.Node(t,e,a)):this._outputs.push(new uff.Parameter(e.id,[a.get(e.inputs[0])])):this._inputs.push(new uff.Parameter(e.id,[a.get(e.id)]))}get name(){return this._name}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}},uff.Parameter=class{constructor(t,s){this._name=t,this._arguments=s}get name(){return this._name}get visible(){return!0}get arguments(){return this._arguments}},uff.Argument=class{constructor(t,s,a){if(typeof t!="string")throw new uff.Error("Invalid argument identifier '"+JSON.stringify(t)+"'.");this._name=t,this._type=s||null,this._initializer=a||null}get name(){return this._name}get type(){return this._type}get initializer(){return this._initializer}},uff.Node=class{constructor(t,s,a){this._name=s.id,this._operation=s.operation,this._metadata=t.type(s.operation),this._attributes=[],this._inputs=[],this._outputs=[];const n=t.type(s.operation);if(s.inputs&&s.inputs.length>0){let e=0;if(n&&n.inputs){for(const i of n.inputs)if(e<s.inputs.length||i.option!="optional"){const r=i.option=="variadic"?s.input.length-e:1,o=s.inputs.slice(e,e+r).map(h=>a.get(h));e+=r,this._inputs.push(new uff.Parameter(i.name,o))}}this._inputs=this._inputs.concat(s.inputs.slice(e).map((i,r)=>{const o=e+r==0?"input":(e+r).toString();return new uff.Parameter(o,[a.get(i)])}))}this._outputs.push(new uff.Parameter("output",[a.get(s.id)]));for(const e of s.fields)this._attributes.push(new uff.Attribute(t.attribute(this._operation,e.key),e.key,e.value))}get name(){return this._name}get type(){return this._operation}get metadata(){return this._metadata}get inputs(){return this._inputs}get outputs(){return this._outputs}get attributes(){return this._attributes}},uff.Attribute=class{constructor(t,s,a){switch(this._name=s,a.type){case"s":this._value=a.s,this._type="string";break;case"s_list":this._value=a.s_list,this._type="string[]";break;case"d":this._value=a.d,this._type="float64";break;case"d_list":this._value=a.d_list.val,this._type="float64[]";break;case"i":this._value=a.i,this._type="int64";break;case"i_list":this._value=a.i_list.val,this._type="int64[]";break;case"b":this._value=a.b,this._type="boolean";break;case"b_list":this._value=a.b_list,this._type="boolean[]";break;case"blob":this._value=a.blob;break;case"dtype":this._value=new uff.TensorType(a,null).dataType;break;case"dim_orders_list":this._value=a.dim_orders_list.val;break;default:throw new uff.Error("Unknown attribute '"+s+"'format '"+JSON.stringify(a)+"'.")}}get type(){return this._type}get name(){return this._name}get value(){return this._value}},uff.Tensor=class{constructor(t,s,a){switch(this._type=new uff.TensorType(t,s),a.type){case"blob":this._data=a.blob;break;default:throw new uff.Error("Unknown values format '"+JSON.stringify(a.type)+"'.")}}get kind(){return"Const"}get type(){return this._type}get state(){return this._context().state}get value(){const t=this._context();return t.state?null:(t.limit=Number.MAX_SAFE_INTEGER,this._decode(t,0))}toString(){const t=this._context();if(t.state)return"";t.limit=1e4;const s=this._decode(t,0);return JSON.stringify(s,null,4)}_context(){const t={state:null,index:0,count:0};return this._data==null||this._data.length>8&&this._data[0]===40&&this._data[1]===46&&this._data[2]===46&&this._data[3]===46&&this._data[this._data.length-1]===41&&this._data[this._data.length-2]===46&&this._data[this._data.length-3]===46&&this._data[this._data.length-4]===46?(t.state="Tensor data is empty.",t):(t.dataType=this._type.dataType,t.shape=this._type.shape.dimensions,t.data=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength),t)}_decode(t,s){const a=t.shape.length==0?[1]:t.shape,n=a[s],e=[];if(s==a.length-1)for(let i=0;i<n;i++){if(t.count>t.limit)return e.push("..."),e;switch(t.dataType){case"int8":e.push(t.data.getInt8(t.index)),t.index+=1,t.count++;break;case"int16":e.push(t.data.getInt16(t.index)),t.index+=2,t.count++;break;case"int32":e.push(t.data.getInt32(t.index,!0)),t.index+=4,t.count++;break;case"int64":e.push(new long.Long(t.data.getUint32(t.index,!0),t.data.getUint32(t.index+4,!0),!1)),t.index+=8,t.count++;break;case"float16":e.push(t.data.getFloat16(t.index,!0)),t.index+=2,t.count++;break;case"float32":e.push(t.data.getFloat32(t.index,!0)),t.index+=4,t.count++}}else for(let i=0;i<n;i++){if(t.count>t.limit)return e.push("..."),e;e.push(this._decode(t,s+1))}return t.shape.length==0?e[0]:e}},uff.TensorType=class{constructor(t,s){if(t.type!=="dtype")throw new uff.Error("Unknown data type format '"+JSON.stringify(t.type)+"'.");switch(t.dtype){case uff.proto.DataType.DT_INT8:this._dataType="int8";break;case uff.proto.DataType.DT_INT16:this._dataType="int16";break;case uff.proto.DataType.DT_INT32:this._dataType="int32";break;case uff.proto.DataType.DT_INT64:this._dataType="int64";break;case uff.proto.DataType.DT_FLOAT16:this._dataType="float16";break;case uff.proto.DataType.DT_FLOAT32:this._dataType="float32";break;default:throw new uff.Error("Unknown data type '"+JSON.stringify(t)+"'.")}this._shape=s?new uff.TensorShape(s):null}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return this.dataType+this._shape.toString()}},uff.TensorShape=class{constructor(t){if(t.type!=="i_list")throw new uff.Error("Unknown shape format '"+JSON.stringify(t.type)+"'.");this._dimensions=t.i_list.val}get dimensions(){return this._dimensions}toString(){return this._dimensions&&this._dimensions.length!=0?"["+this._dimensions.join(",")+"]":""}},uff.Metadata=class{static open(t){return uff.Metadata._metadata?Promise.resolve(uff.Metadata._metadata):t.request(null,"uff-metadata.json","utf-8").then(s=>(uff.Metadata._metadata=new uff.Metadata(s),uff.Metadata._metadata)).catch(()=>(uff.Metadata._metadata=new uff.Metadata(null),uff.Metadata._metadata))}constructor(t){if(this._map=new Map,this._attributeCache=new Map,t){const s=JSON.parse(t);if(s)for(const a of s)a.name&&a.schema&&(a.schema.name=a.name,this._map.set(a.name,a.schema))}}type(t){return this._map.get(t)}attribute(t,s){const a=t+":"+s;if(!this._attributeCache.has(a)){const n=this.type(t);if(n&&n.attributes&&n.attributes.length>0)for(const e of n.attributes)this._attributeCache.set(t+":"+e.name,e);this._attributeCache.has(a)||this._attributeCache.set(a,null)}return this._attributeCache.get(a)}},uff.Error=class extends Error{constructor(t){super(t),this.name="Error loading UFF model."}},typeof module!="undefined"&&typeof module.exports=="object"&&(module.exports.ModelFactory=uff.ModelFactory);
