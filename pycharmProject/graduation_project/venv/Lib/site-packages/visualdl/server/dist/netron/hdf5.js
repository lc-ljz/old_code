var hdf5=hdf5||{},long=long||{Long:require("long")},zip=zip||require("./zip");hdf5.File=class{constructor(e){const t=new hdf5.Reader(e,0);if(this._globalHeap=new hdf5.GlobalHeap(t),!t.match(`\x89HDF\r

`))throw new hdf5.Error("Not a valid HDF5 file.");const s=t.byte();switch(s){case 0:case 1:{if(this._freeSpaceStorageVersion=t.byte(),this._rootGroupEntryVersion=t.byte(),t.skip(1),this._sharedHeaderMessageVersionFormat=t.byte(),t.initialize(),t.skip(1),this._groupLeafNodeK=t.uint16(),this._groupInternalNodeK=t.uint16(),t.skip(4),s>0&&(this._indexedStorageInternalNodeK=t.uint16(),this.seek(2)),this._baseAddress=t.offset(),t.offset(),this._endOfFileAddress=t.offset(),t.offset(),this._baseAddress!=0)throw new hdf5.Error("Base address is not zero.");const i=new hdf5.SymbolTableEntry(t);this._rootGroup=new hdf5.Group(t,i,null,this._globalHeap,"","");break}case 2:case 3:{t.initialize(),t.byte(),this._baseAddress=t.offset(),this._superBlockExtensionAddress=t.offset(),this._endOfFileAddress=t.offset();const i=new hdf5.DataObjectHeader(t.at(t.offset()));this._rootGroup=new hdf5.Group(t,null,i,this._globalHeap,"","");break}default:throw new hdf5.Error("Unsupported Superblock version "+s+".")}}get rootGroup(){return this._rootGroup}},hdf5.Group=class{constructor(e,t,s,i,a,r){this._reader=e,this._entry=t,this._dataObjectHeader=s,this._globalHeap=i,this._name=r,this._path=a=="/"?a+r:a+"/"+r}get name(){return this._name}get path(){return this._path}group(e){this._decodeGroups();const t=e.indexOf("/");if(t!=-1){const s=e.substring(t+1),i=e.substring(0,t),a=this.group(i);if(a!=null)return a.group(s)}else{const s=this._groupMap[e];if(s)return s}return null}get groups(){return this._decodeGroups(),this._groups}attribute(e){return this._decodeDataObject(),this._attributes[e]}get attributes(){return this._decodeDataObject(),this._attributes}get value(){return this._decodeDataObject(),this._value}_decodeDataObject(){if(this._dataObjectHeader||(this._dataObjectHeader=new hdf5.DataObjectHeader(this._reader.at(this._entry.objectHeaderAddress))),!this._attributes){this._attributes={};for(const a of this._dataObjectHeader.attributes){const r=a.name,n=a.decodeValue(this._globalHeap);this._attributes[r]=n}this._value=null;const e=this._dataObjectHeader.datatype,t=this._dataObjectHeader.dataspace,s=this._dataObjectHeader.dataLayout,i=this._dataObjectHeader.filterPipeline;e&&t&&s&&(this._value=new hdf5.Variable(this._reader,this._globalHeap,e,t,s,i))}}_decodeGroups(){if(!this._groups)if(this._groupMap={},this._groups=[],this._entry){if(this._entry.treeAddress||this._entry.heapAddress){const e=new hdf5.Heap(this._reader.at(this._entry.heapAddress)),t=new hdf5.Tree(this._reader.at(this._entry.treeAddress));for(const s of t.nodes)for(const i of s.entries){const a=e.getString(i.linkNameOffset),r=new hdf5.Group(this._reader,i,null,this._globalHeap,this._path,a);this._groups.push(r),this._groupMap[a]=r}}}else{this._decodeDataObject();for(const e of this._dataObjectHeader.links)if(Object.prototype.hasOwnProperty.call(e,"objectHeaderAddress")){const t=e.name,s=new hdf5.DataObjectHeader(this._reader.at(e.objectHeaderAddress)),i=new hdf5.Group(this._reader,null,s,this._globalHeap,this._path,t);this._groups.push(i),this._groupMap[t]=i}}}},hdf5.Variable=class{constructor(e,t,s,i,a,r){this._reader=e,this._globalHeap=t,this._datatype=s,this._dataspace=i,this._dataLayout=a,this._filterPipeline=r}get type(){return this._datatype.type}get littleEndian(){return this._datatype.littleEndian}get shape(){return this._dataspace.shape}get value(){const e=this.data;if(e){const t=new hdf5.Reader(e),s=this._dataspace.read(this._datatype,t);return this._dataspace.decode(this._datatype,s,s,this._globalHeap)}return null}get data(){switch(this._dataLayout.layoutClass){case 1:if(this._dataLayout.address)return this._reader.at(this._dataLayout.address).bytes(this._dataLayout.size);break;case 2:{const e=new hdf5.Tree(this._reader.at(this._dataLayout.address),this._dataLayout.dimensionality);if(this._dataLayout.dimensionality==2&&this._dataspace.shape.length==1){let t=this._dataLayout.datasetElementSize;for(let i=0;i<this._dataspace.shape.length;i++)t*=this._dataspace.shape[i];const s=new Uint8Array(t);for(const i of e.nodes){if(i.fields.length!==2||i.fields[1]!==0||i.filterMask!==0)return null;const a=i.fields[0]*this._dataLayout.datasetElementSize;let r=i.data;if(this._filterPipeline)for(const n of this._filterPipeline.filters)r=n.decode(r);for(let n=0;n<r.length;n++)s[a+n]=r[n]}return s}break}default:throw new hdf5.Error("Unknown data layout class '"+this.layoutClass+"'.")}return null}},hdf5.Reader=class{constructor(e){e&&(this._buffer=e,this._dataView=new DataView(e.buffer,e.byteOffset,e.byteLength),this._position=0,this._offset=0)}initialize(){this._offsetSize=this.byte(),this._lengthSize=this.byte()}skip(e){if(this._offset+=e,this._position+this._offset>this._buffer.length)throw new hdf5.Error("Expected "+(this._position+this._offset-this._buffer.length)+" more bytes. The file might be corrupted. Unexpected end of file.")}int8(){const e=this._offset;return this.skip(1),this._dataView.getInt8(this._position+e)}byte(){const e=this._offset;return this.skip(1),this._dataView.getUint8(this._position+e)}bytes(e){const t=this._offset;return this.skip(e),this._buffer.subarray(this._position+t,this._position+this._offset)}int16(){const e=this._offset;return this.skip(2),this._dataView.getInt16(this._position+e,!0)}uint16(){const e=this._offset;return this.skip(2),this._dataView.getUint16(this._position+e,!0)}int32(){const e=this._offset;return this.skip(4),this._dataView.getInt32(this._position+e,!0)}uint32(){const e=this._offset;return this.skip(4),this._dataView.getUint32(this._position+e,!0)}int64(){const e=this._offset;this.skip(8);const t=this._dataView.getUint32(this._position+e,!0),s=this._dataView.getUint32(this._position+e+4,!0);return new long.Long(t,s,!1).toNumber()}uint64(){const e=this._offset;this.skip(8);const t=this._dataView.getUint32(this._position+e,!0),s=this._dataView.getUint32(this._position+e+4,!0);return new long.Long(t,s,!0).toNumber()}uint(e){switch(e){case 0:return this.byte();case 1:return this.uint16();case 2:return this.uint32();case 3:return this.uint64()}}float16(){const e=this._offset;this.skip(2);const t=this._dataView.getUint16(this._position+e,!0),s=(32768&t)>>15,i=(31744&t)>>10,a=1023&t;return i==0?(s?-1:1)*Math.pow(2,-14)*(a/Math.pow(2,10)):i==31?a?NaN:1/0*(s?-1:1):(s?-1:1)*Math.pow(2,i-15)*(1+a/Math.pow(2,10))}float32(){const e=this._offset;return this.skip(4),this._dataView.getFloat32(this._position+e,!0)}float64(){const e=this._offset;return this.skip(8),this._dataView.getFloat64(this._position+e,!0)}string(e,t){if(!e||e==-1){let i=this._position+this._offset;for(;this._buffer[i]!=0;)i++;e=i-this._position-this._offset+1}const s=this.bytes(e);return hdf5.Reader.decode(s,t)}static decode(e,t){let s="";return t=="utf-8"?(hdf5.Reader._utf8Decoder||(hdf5.Reader._utf8Decoder=new TextDecoder("utf-8")),s=hdf5.Reader._utf8Decoder.decode(e)):(hdf5.Reader._asciiDecoder||(hdf5.Reader._asciiDecoder=new TextDecoder("ascii")),s=hdf5.Reader._asciiDecoder.decode(e)),s.replace(/\0/g,"")}offset(){switch(this._offsetSize){case 8:{const e=this.uint32(),t=this.uint32();return e===4294967295&&t===4294967295?void 0:new long.Long(e,t,!0).toNumber()}case 4:{const e=this.uint32();return e===4294967295?void 0:e}}throw new hdf5.Error("Unsupported offset size '"+this._offsetSize+"'.")}length(){switch(this._lengthSize){case 8:{const e=this.uint32(),t=this.uint32();return e===4294967295&&t===4294967295?void 0:new long.Long(e,t,!0).toNumber()}case 4:{const e=this.uint32();return e===4294967295?void 0:e}}throw new hdf5.Error("Unsupported length size '"+this._lengthSize+"'.")}at(e){const t=new hdf5.Reader(null);return t._buffer=this._buffer,t._dataView=this._dataView,t._position=e,t._offset=0,t._offsetSize=this._offsetSize,t._lengthSize=this._lengthSize,t}clone(){const e=new hdf5.Reader(this._buffer,this._position);return e._buffer=this._buffer,e._dataView=this._dataView,e._position=this._position,e._offset=this._offset,e._offsetSize=this._offsetSize,e._lengthSize=this._lengthSize,e}align(e){this._offset%e!=0&&(this._offset=(Math.floor(this._offset/e)+1)*e)}match(e){if(this._position+this._offset+e.length>this._buffer.length)return!1;const t=this._offset,s=this.bytes(e.length);for(let i=0;i<e.length;i++)if(e.charCodeAt(i)!=s[i])return this._offset=t,!1;return!0}get position(){return this._position+this._offset}get size(){return this._buffer.length}},hdf5.SymbolTableNode=class{constructor(e){if(!e.match("SNOD"))throw new hdf5.Error("Not a valid 'SNOD' block.");const t=e.byte();if(t!=1)throw new hdf5.Error("Unsupported symbol table node version '"+t+"'.");{e.skip(1);const s=e.uint16();this.entries=[];for(let i=0;i<s;i++)this.entries.push(new hdf5.SymbolTableEntry(e))}}},hdf5.SymbolTableEntry=class{constructor(e){this.linkNameOffset=e.offset(),this.objectHeaderAddress=e.offset();const t=e.uint32();switch(e.skip(4),t){case 0:break;case 1:{const s=e.clone();this.treeAddress=s.offset(),this.heapAddress=s.offset();break}default:throw new hdf5.Error("Unsupported cache type '"+t+"'.")}e.skip(16)}},hdf5.DataObjectHeader=class{constructor(e){this.attributes=[],this.links=[],this.continuations=[];const t=(e.match("OHDR"),e.byte());switch(t){case 1:{e.skip(1);const s=e.uint16();e.uint32();const i=e.uint32();e.align(8);let a=e.position+i;for(let r=0;r<s;r++){const n=e.uint16(),c=e.uint16(),o=e.byte();if(e.skip(3),e.align(8),(!this._readMessage(e,n,c,o)||e.position>=a)&&this.continuations.length>0){const h=this.continuations.shift();e=e.at(h.offset),a=h.offset+h.length}else e.align(8)}break}case 2:{const s=e.byte();(32&s)!=0&&(e.uint32(),e.uint32(),e.uint32(),e.uint32()),(16&s)!=0&&(e.uint16(),e.uint16());const i=e.uint(3&s);let a=!0,r=e.position+i;for(;a&&e.position<r;){const n=e.byte(),c=e.uint16(),o=e.byte();if(e.position<r&&((4&s)!=0&&e.uint16(),a=this._readMessage(e,n,c,o)),(!a||e.position>=r)&&this.continuations.length>0){const h=this.continuations.shift();if(e=e.at(h.offset),r=h.offset+h.length,!e.match("OCHK"))throw new hdf5.Error("Invalid continuation block signature.");a=!0}}break}default:throw new hdf5.Error("Unsupported data object header version '"+t+"'.")}}_readMessage(e,t,s,i){switch(t){case 0:return!1;case 1:this.dataspace=s!=4||i!=1?new hdf5.Dataspace(e.clone()):null;break;case 2:this.linkInfo=new hdf5.LinkInfo(e.clone());break;case 3:this.datatype=new hdf5.Datatype(e.clone());break;case 4:case 5:this.fillValue=new hdf5.FillValue(e.clone(),t);break;case 6:this.links.push(new hdf5.Link(e.clone()));break;case 8:this.dataLayout=new hdf5.DataLayout(e.clone());break;case 10:this.groupInfo=new hdf5.GroupInfo(e.clone());break;case 11:this.filterPipeline=new hdf5.FilterPipeline(e.clone());break;case 12:this.attributes.push(new hdf5.Attribute(e.clone()));break;case 13:this.comment=e.string(-1,"ascii");break;case 16:this.continuations.push(new hdf5.ObjectHeaderContinuation(e.clone()));break;case 17:this.symbolTable=new hdf5.SymbolTable(e.clone());break;case 14:case 18:this.objectModificationTime=new hdf5.ObjectModificationTime(e.clone(),t);break;case 21:this.attributeInfo=new hdf5.AttributeInfo(e.clone());break;default:throw new hdf5.Error("Unsupported message type '"+t+"'.")}return e.skip(s),!0}},hdf5.Message=class{constructor(e,t,s){this._type=e,this._data=t,this._flags=s}},hdf5.Dataspace=class{constructor(e){this._sizes=[];const t=e.byte();switch(t){case 1:this._dimensions=e.byte(),this._flags=e.byte(),e.skip(1),e.skip(4);for(let s=0;s<this._dimensions;s++)this._sizes.push(e.length());if((1&this._flags)!=0){this._maxSizes=[];for(let s=0;s<this._dimensions;s++)if(this._maxSizes.push(e.length()),this._maxSizes[s]!=this._sizes[s])throw new hdf5.Error("Max size is not supported.")}if((2&this._flags)!=0)throw new hdf5.Error("Permutation indices not supported.");break;case 2:this._dimensions=e.byte(),this._flags=e.byte(),this._type=e.byte();for(let s=0;s<this._dimensions;s++)this._sizes.push(e.length());if((1&this._flags)!=0){this._maxSizes=[];for(let s=0;s<this._dimensions;s++)this._maxSizes.push(e.length())}break;default:throw new hdf5.Error("Unsupported dataspace message version '"+t+"'.")}}get shape(){return this._sizes}read(e,t){return this._dimensions==0?e.read(t):this._readArray(e,t,this._sizes,0)}_readArray(e,t,s,i){const a=[],r=s[i];if(i==s.length-1)for(let n=0;n<r;n++)a.push(e.read(t));else for(let n=0;n<r;n++)a.push(this._readArray(e,t,s,i+1));return a}decode(e,t,s){return this._dimensions==0?e.decode(t,s):this._decodeArray(e,t,s,this._sizes,0)}_decodeArray(e,t,s,i,a){const r=i[a];if(a==i.length-1)for(let n=0;n<r;n++)t[n]=e.decode(t[n],s);else for(let n=0;n<r;n++)t[n]=this._decodeArray(e,t[n],i,a+1);return t}},hdf5.LinkInfo=class{constructor(e){const t=e.byte();switch(t){case 0:{const s=e.byte();(1&s)!=0&&(this.maxCreationIndex=e.uint64()),this.fractalHeapAddress=e.offset(),this.nameIndexTreeAddress=e.offset(),(2&s)!=0&&(this.creationOrderIndexTreeAddress=e.offset());break}default:throw new hdf5.Error("Unsupported link info message version '"+t+"'.")}}},hdf5.Datatype=class{constructor(e){const t=e.byte(),s=t>>4;switch(this._class=15&t,s){case 1:case 2:switch(this._flags=e.byte()|e.byte()<<8|e.byte()<<16,this._size=e.uint32(),this._class){case 0:this._bitOffset=e.uint16(),this._bitPrecision=e.uint16();break;case 8:{this._base=new hdf5.Datatype(e),this._names=[],this._values=[];const i=65535&this._flags;for(let a=0;a<i;a++){const r=e.clone().string(-1,"ascii");this._names.push(r),e.skip(8*Math.round((r.length+1)/8))}for(let a=0;a<i;a++)this._values.push(this._base.read(e));break}}break;default:throw new hdf5.Error("Unsupported datatype version '"+s+"'.")}}get type(){switch(this._class){case 0:if((65526&this._flags)==0)if((this._flags&&8)!==0)switch(this._size){case 1:return"int8";case 2:return"int16";case 4:return"int32";case 8:return"int64"}else switch(this._size){case 1:return"uint8";case 2:return"uint16";case 4:return"uint32";case 8:return"uint64"}break;case 1:if(this._size==2&&this._flags==3872)return"float16";if(this._size==4&&this._flags==7968)return"float32";if(this._size==8&&this._flags==16160)return"float64";break;case 3:return"string";case 5:return"uint8[]";case 8:if(this._base.type==="int8"&&this._names.length===2&&this._names[0]==="FALSE"&&this._names[1]==="TRUE"&&this._values.length===2&&this._values[0]===0&&this._values[1]===1)return"boolean";break;case 9:if((15&this._flags)==1)return"char[]"}throw new hdf5.Error("Unsupported datatype class '"+this._class+"'.")}get littleEndian(){switch(this._class){case 0:case 1:return(1&this.flags)==0}return!0}read(e){switch(this._class){case 0:if(this._size==1)return(8&this._flags)!=0?e.int8():e.byte();if(this._size==2)return(8&this._flags)!=0?e.int16():e.uint16();if(this._size==4)return(8&this._flags)!=0?e.int32():e.uint32();if(this._size==8)return(8&this._flags)!=0?e.int64():e.uint64();throw new hdf5.Error("Unsupported fixed-point datatype.");case 1:if(this._size==2&&this._flags==3872)return e.float16();if(this._size==4&&this._flags==7968)return e.float32();if(this._size==8&&this._flags==16160)return e.float64();throw new hdf5.Error("Unsupported floating-point datatype.");case 3:switch(this._flags>>8&15){case 0:return hdf5.Reader.decode(e.bytes(this._size),"ascii");case 1:return hdf5.Reader.decode(e.bytes(this._size),"utf-8")}throw new hdf5.Error("Unsupported character encoding.");case 5:return e.bytes(this._size);case 9:return{length:e.uint32(),globalHeapID:new hdf5.GlobalHeapID(e)}}throw new hdf5.Error("Unsupported datatype class '"+this._class+"'.")}decode(e,t){switch(this._class){case 0:case 1:case 3:case 5:return e;case 9:{const s=t.get(e.globalHeapID);if(s!=null){switch(this._flags>>8&15){case 0:return hdf5.Reader.decode(s.data,"ascii");case 1:return hdf5.Reader.decode(s.data,"utf-8")}throw new hdf5.Error("Unsupported character encoding.")}break}default:throw new hdf5.Error("Unsupported datatype class '"+this._class+"'.")}return null}},hdf5.FillValue=class{constructor(e,t){switch(t){case 4:{const s=e.uint32();this.data=e.bytes(s);break}case 5:default:{const s=e.byte();switch(s){case 1:case 2:{e.byte(),e.byte();const i=e.byte();if(s===1||i===1){const a=e.uint32();this.data=e.bytes(a)}break}default:throw new hdf5.Error("Unsupported fill value version '"+s+"'.")}break}}}},hdf5.Link=class{constructor(e){const t=e.byte();switch(t){case 1:{const s=e.byte();this.type=(8&s)!=0?e.byte():0,(4&s)!=0&&(this.creationOrder=e.uint32());const i=(16&s)!=0&&e.byte()==1?"utf-8":"ascii";switch(this.name=e.string(e.uint(3&s),i),this.type){case 0:this.objectHeaderAddress=e.offset()}break}default:throw new hdf5.Error("Unsupported link message version '"+t+"'.")}}},hdf5.DataLayout=class{constructor(e){const t=e.byte();switch(t){case 1:case 2:switch(this.dimensionality=e.byte(),this.layoutClass=e.byte(),e.skip(5),this.layoutClass){case 1:this.address=e.offset(),this.dimensionSizes=[];for(let s=0;s<this.dimensionality-1;s++)this.dimensionSizes.push(e.int32());break;case 2:this.address=e.offset(),this.dimensionSizes=[];for(let s=0;s<this.dimensionality-1;s++)this.dimensionSizes.push(e.int32());this.datasetElementSize=e.int32();break;default:throw new hdf5.Error("Unsupported data layout class '"+this.layoutClass+"'.")}break;case 3:switch(this.layoutClass=e.byte(),this.layoutClass){case 1:this.address=e.offset(),this.size=e.length();break;case 2:this.dimensionality=e.byte(),this.address=e.offset(),this.dimensionSizes=[];for(let s=0;s<this.dimensionality-1;s++)this.dimensionSizes.push(e.int32());this.datasetElementSize=e.int32();break;case 0:default:throw new hdf5.Error("Unsupported data layout class '"+this.layoutClass+"'.")}break;default:throw new hdf5.Error("Unsupported data layout version '"+t+"'.")}}},hdf5.GroupInfo=class{constructor(e){const t=e.byte();switch(t){case 0:{const s=e.byte();(1&s)!=0&&(this.maxCompactLinks=e.uint16(),this.minDenseLinks=e.uint16()),(2&s)!=0&&(this.estimatedEntriesNumber=e.uint16(),this.estimatedLinkNameLengthEntires=e.uint16());break}default:throw new hdf5.Error("Unsupported group info version '"+t+"'.")}}},hdf5.FilterPipeline=class{constructor(e){const t=e.byte();switch(t){case 1:{this.filters=[];const s=e.byte();e.skip(2),e.skip(4);for(let i=0;i<s;i++)this.filters.push(new hdf5.Filter(e)),e.align(8);break}default:throw new hdf5.Error("Unsupported filter pipeline message version '"+t+"'.")}}},hdf5.Filter=class{constructor(e){this.id=e.int16();const t=e.int16();this.flags=e.int16();const s=e.int16();this.name=e.string(t,"ascii"),this.clientData=e.bytes(4*s)}decode(e){switch(this.id){case 1:{const t=e.subarray(2,e.length);return new zip.Inflater().inflateRaw(t)}default:throw hdf5.Error("Unsupported filter '"+this.name+"'.")}}},hdf5.Attribute=class{constructor(e){const t=e.byte();switch(t){case 1:{e.skip(1);const s=e.uint16(),i=e.uint16(),a=e.uint16();this.name=e.string(s,"utf-8"),e.align(8),this._datatype=new hdf5.Datatype(e.clone()),e.skip(i),e.align(8),this._dataspace=new hdf5.Dataspace(e.clone()),e.skip(a),e.align(8),this._data=this._dataspace.read(this._datatype,e);break}case 3:{e.byte();const s=e.uint16(),i=e.uint16(),a=e.uint16(),r=e.byte()==1?"utf-8":"ascii";this.name=e.string(s,r),this._datatype=new hdf5.Datatype(e.clone()),e.skip(i),this._dataspace=new hdf5.Dataspace(e.clone()),e.skip(a),this._data=this._dataspace.read(this._datatype,e);break}default:throw new hdf5.Error("Unsupported attribute message version '"+t+"'.")}}decodeValue(e){return this._data?this._dataspace.decode(this._datatype,this._data,e):null}},hdf5.ObjectHeaderContinuation=class{constructor(e){this.offset=e.offset(),this.length=e.length()}},hdf5.SymbolTable=class{constructor(e){this._treeAddress=e.offset(),this._heapAddress=e.offset()}},hdf5.ObjectModificationTime=class{constructor(e,t){switch(t){case 14:this.year=e.uint32(),this.month=e.uint16(),this.day=e.uint16(),this.hour=e.uint16(),this.minute=e.uint16(),this.second=e.uint16(),e.skip(2);break;case 18:{const s=e.byte();switch(e.skip(3),s){case 1:this.timestamp=e.uint32();break;default:throw new hdf5.Error("Unsupported object modification time message version '"+s+"'.")}break}}}},hdf5.AttributeInfo=class{constructor(e){const t=e.byte();switch(t){case 0:{const s=e.byte();(1&s)!=0&&(this.maxCreationIndex=e.uint64()),this.fractalHeapAddress=e.offset(),this.attributeNameTreeAddress=e.offset(),(2&s)!=0&&(this.attributeCreationOrderTreeAddress=e.offset());break}default:throw new hdf5.Error("Unsupported attribute info message version '"+t+"'.")}}},hdf5.Tree=class{constructor(e,t){if(!e.match("TREE"))throw new hdf5.Error("Not a valid 'TREE' block.");this.type=e.byte(),this.level=e.byte();const s=e.uint16();switch(e.offset(),e.offset(),this.nodes=[],this.type){case 0:for(let i=0;i<s;i++){e.length();const a=e.offset();if(this.level==0)this.nodes.push(new hdf5.SymbolTableNode(e.at(a)));else{const r=new hdf5.Tree(e.at(a));this.nodes=this.nodes.concat(r.nodes)}}break;case 1:for(let i=0;i<s;i++){const a=e.int32(),r=e.int32(),n=[];for(let o=0;o<t;o++)n.push(e.uint64());const c=e.offset();if(this.level==0){const o=e.at(c).bytes(a);this.nodes.push({data:o,fields:n,filterMask:r})}else{const o=new hdf5.Tree(e.at(c),t);this.nodes=this.nodes.concat(o.nodes)}}break;default:throw new hdf5.Error("Unsupported B-Tree node type '"+this.type+"'.")}}},hdf5.Heap=class{constructor(e){if(this._reader=e,!e.match("HEAP"))throw new hdf5.Error("Not a valid 'HEAP' block.");const t=e.byte();switch(t){case 0:e.skip(3),this._dataSize=e.length(),this._offsetToHeadOfFreeList=e.length(),this._dataAddress=e.offset();break;default:throw new hdf5.Error("Unsupported Local Heap version '"+t+"'.")}}getString(e){return this._reader.at(this._dataAddress+e).string(-1,"utf-8")}},hdf5.GlobalHeap=class{constructor(e){this._reader=e,this._collections=new Map}get(e){const t=e.address;return this._collections.has(t)||this._collections.set(t,new hdf5.GlobalHeapCollection(this._reader.at(t))),this._collections.get(e.address).getObject(e.objectIndex)}},hdf5.GlobalHeapCollection=class{constructor(e){const t=e.position;if(!e.match("GCOL"))throw new hdf5.Error("Not a valid 'GCOL' block.");const s=e.byte();switch(s){case 1:{e.skip(3),this._objects=new Map;const i=t+e.length();for(;e.position<i;){const a=e.uint16();if(a==0)break;this._objects.set(a,new hdf5.GlobalHeapObject(e)),e.align(8)}break}default:throw new hdf5.Error("Unsupported global heap collection version '"+s+"'.")}}getObject(e){return this._objects.has(e)?this._objects.get(e):null}},hdf5.GlobalHeapObject=class{constructor(e){e.uint16(),e.skip(4),this.data=e.bytes(e.length())}},hdf5.GlobalHeapID=class{constructor(e){this.address=e.offset(),this.objectIndex=e.uint32()}},hdf5.Error=class extends Error{constructor(e){super(e),this.name="HDF5 Error"}},typeof module!="undefined"&&typeof module.exports=="object"&&(module.exports.File=hdf5.File);
