var pickle=pickle||{};pickle.Unpickler=class{constructor(a){this._reader=new pickle.Reader(a,0)}load(a,h){const t=this._reader,r=[];let e=[];const p=new Map;for(;t.position<t.length;){const c=t.byte();switch(c){case pickle.OpCode.PROTO:{const s=t.byte();if(s>5)throw new pickle.Error("Unsupported protocol version '"+s+"'.");break}case pickle.OpCode.GLOBAL:e.push([t.line(),t.line()].join("."));break;case pickle.OpCode.STACK_GLOBAL:e.push([e.pop(),e.pop()].reverse().join("."));break;case pickle.OpCode.PUT:{const s=parseInt(t.line(),10);p.set(s,e[e.length-1]);break}case pickle.OpCode.OBJ:{const s=e;e=r.pop(),e.push(a(s.pop(),s));break}case pickle.OpCode.GET:{const s=parseInt(t.line(),10);e.push(p.get(s));break}case pickle.OpCode.POP:e.pop();break;case pickle.OpCode.POP_MARK:e=r.pop();break;case pickle.OpCode.DUP:e.push(e[e.length-1]);break;case pickle.OpCode.PERSID:e.push(h(t.line()));break;case pickle.OpCode.BINPERSID:e.push(h(e.pop()));break;case pickle.OpCode.REDUCE:{const s=e.pop(),o=e.pop();e.push(a(o,s));break}case pickle.OpCode.NEWOBJ:{const s=e.pop(),o=e.pop();e.push(a(o,s));break}case pickle.OpCode.BINGET:e.push(p.get(t.byte()));break;case pickle.OpCode.LONG_BINGET:e.push(p.get(t.uint32()));break;case pickle.OpCode.BINPUT:p.set(t.byte(),e[e.length-1]);break;case pickle.OpCode.LONG_BINPUT:p.set(t.uint32(),e[e.length-1]);break;case pickle.OpCode.BININT:e.push(t.int32());break;case pickle.OpCode.BININT1:e.push(t.byte());break;case pickle.OpCode.LONG:e.push(parseInt(t.line(),10));break;case pickle.OpCode.BININT2:e.push(t.uint16());break;case pickle.OpCode.BINBYTES:e.push(t.bytes(t.int32()));break;case pickle.OpCode.SHORT_BINBYTES:e.push(t.bytes(t.byte()));break;case pickle.OpCode.FLOAT:e.push(parseFloat(t.line()));break;case pickle.OpCode.BINFLOAT:e.push(t.float64());break;case pickle.OpCode.INT:{const s=t.line();s=="01"?e.push(!0):s=="00"?e.push(!1):e.push(parseInt(s,10));break}case pickle.OpCode.EMPTY_LIST:case pickle.OpCode.EMPTY_TUPLE:case pickle.OpCode.EMPTY_SET:e.push([]);break;case pickle.OpCode.ADDITEMS:{const s=e;e=r.pop();const o=e[e.length-1];for(let i=0;i<s.length;i++)o.push(s[i]);break}case pickle.OpCode.DICT:{const s=e;e=r.pop();const o={};for(let i=0;i<s.length;i+=2)o[s[i]]=s[i+1];e.push(o);break}case pickle.OpCode.LIST:{const s=e;e=r.pop(),e.push(s);break}case pickle.OpCode.TUPLE:{const s=e;e=r.pop(),e.push(s);break}case pickle.OpCode.SETITEM:{const s=e.pop(),o=e.pop(),i=e[e.length-1];i.__setitem__?i.__setitem__(o,s):i[o]=s;break}case pickle.OpCode.SETITEMS:{const s=e;e=r.pop();const o=e[e.length-1];for(let i=0;i<s.length;i+=2)o.__setitem__?o.__setitem__(s[i],s[i+1]):o[s[i]]=s[i+1];break}case pickle.OpCode.EMPTY_DICT:e.push({});break;case pickle.OpCode.APPEND:{const s=e.pop();e[e.length-1].push(s);break}case pickle.OpCode.APPENDS:{const s=e;e=r.pop();const o=e[e.length-1];o.push.apply(o,s);break}case pickle.OpCode.STRING:{const s=t.line();e.push(s.substr(1,s.length-2));break}case pickle.OpCode.BINSTRING:e.push(t.string(t.uint32()));break;case pickle.OpCode.SHORT_BINSTRING:e.push(t.string(t.byte()));break;case pickle.OpCode.UNICODE:e.push(t.line());break;case pickle.OpCode.BINUNICODE:e.push(t.string(t.uint32(),"utf-8"));break;case pickle.OpCode.SHORT_BINUNICODE:e.push(t.string(t.byte(),"utf-8"));break;case pickle.OpCode.BUILD:{const s=e.pop();let o=e.pop();if(o.__setstate__)o.__setstate__.__call__?o.__setstate__.__call__([o,s]):o.__setstate__(s);else for(const i in s)o[i]=s[i];o.__read__&&(o=o.__read__(this)),e.push(o);break}case pickle.OpCode.MARK:r.push(e),e=[];break;case pickle.OpCode.NEWTRUE:e.push(!0);break;case pickle.OpCode.NEWFALSE:e.push(!1);break;case pickle.OpCode.LONG1:{const s=t.bytes(t.byte());let o=0;switch(s.length){case 0:o=0;break;case 1:o=s[0];break;case 2:o=s[1]<<8|s[0];break;case 3:o=s[2]<<16|s[1]<<8|s[0];break;case 4:o=s[3]<<24|s[2]<<16|s[1]<<8|s[0];break;default:o=Array.prototype.slice.call(s,0)}e.push(o);break}case pickle.OpCode.LONG4:e.push(t.bytes(t.uint32()));break;case pickle.OpCode.TUPLE1:e.push([e.pop()]);break;case pickle.OpCode.TUPLE2:{const s=e.pop(),o=e.pop();e.push([o,s]);break}case pickle.OpCode.TUPLE3:{const s=e.pop(),o=e.pop(),i=e.pop();e.push([i,o,s]);break}case pickle.OpCode.MEMOIZE:p.set(p.size,e[e.length-1]);break;case pickle.OpCode.FRAME:t.bytes(8);break;case pickle.OpCode.NONE:e.push(null);break;case pickle.OpCode.STOP:return e.pop();default:throw new pickle.Error("Unknown opcode '"+c+"'.")}}throw new pickle.Error("Unexpected end of file.")}read(a){return this._reader.bytes(a)}unescape(a,h){const t=a.length,r=new Uint8Array(t);if(h&&h==t){for(let c=0;c<h;c++)r[c]=a.charCodeAt(c);return r}let e=0,p=0;for(;e<t;){let c=a.charCodeAt(e++);if(c!==92||e>=t)r[p++]=c;else switch(c=a.charCodeAt(e++),c){case 39:r[p++]=39;break;case 92:r[p++]=92;break;case 34:r[p++]=34;break;case 114:r[p++]=13;break;case 110:r[p++]=10;break;case 116:r[p++]=9;break;case 98:r[p++]=8;break;case 88:case 120:{const s=e-1,o=p;for(let i=0;i<2;i++){if(e>=t){e=s,p=o,r[p]=92;break}let n=a.charCodeAt(e++);if(n=n>=65&&n<=70?n-55:n>=97&&n<=102?n-87:n>=48&&n<=57?n-48:-1,n===-1){e=s,p=o,r[p]=92;break}r[p]=r[p]<<4|n}p++;break}default:if(c<48||c>57)r[p++]=92,r[p++]=c;else{e--;const s=e,o=p;for(let i=0;i<3;i++){if(e>=t){e=s,p=o,r[p]=92;break}const n=a.charCodeAt(e++);if(n<48||n>57){e=s,p=o,r[p]=92;break}r[p]=r[p]<<3|n-48}p++}}}return r.slice(0,p)}},pickle.OpCode={MARK:40,EMPTY_TUPLE:41,STOP:46,POP:48,POP_MARK:49,DUP:50,BINBYTES:66,SHORT_BINBYTES:67,FLOAT:70,BINFLOAT:71,INT:73,BININT:74,BININT1:75,LONG:76,BININT2:77,NONE:78,PERSID:80,BINPERSID:81,REDUCE:82,STRING:83,BINSTRING:84,SHORT_BINSTRING:85,UNICODE:86,BINUNICODE:88,EMPTY_LIST:93,APPEND:97,BUILD:98,GLOBAL:99,DICT:100,APPENDS:101,GET:103,BINGET:104,LONG_BINGET:106,LIST:108,OBJ:111,PUT:112,BINPUT:113,LONG_BINPUT:114,SETITEM:115,TUPLE:116,SETITEMS:117,EMPTY_DICT:125,PROTO:128,NEWOBJ:129,TUPLE1:133,TUPLE2:134,TUPLE3:135,NEWTRUE:136,NEWFALSE:137,LONG1:138,LONG4:139,SHORT_BINUNICODE:140,BINUNICODE8:141,BINBYTES8:142,EMPTY_SET:143,ADDITEMS:144,FROZENSET:145,NEWOBJ_EX:146,STACK_GLOBAL:147,MEMOIZE:148,FRAME:149},pickle.Reader=class{constructor(a){a&&(this._buffer=a,this._dataView=new DataView(a.buffer,a.byteOffset,a.byteLength),this._position=0),pickle.Reader._utf8Decoder=pickle.Reader._utf8Decoder||new TextDecoder("utf-8"),pickle.Reader._asciiDecoder=pickle.Reader._asciiDecoder||new TextDecoder("ascii")}get length(){return this._buffer.byteLength}get position(){return this._position}byte(){const a=this._position;return this.skip(1),this._dataView.getUint8(a)}bytes(a){const h=this._position;return this.skip(a),this._buffer.subarray(h,this._position)}uint16(){const a=this.position;return this.skip(2),this._dataView.getUint16(a,!0)}int32(){const a=this.position;return this.skip(4),this._dataView.getInt32(a,!0)}uint32(){const a=this.position;return this.skip(4),this._dataView.getUint32(a,!0)}float32(){const a=this.position;return this.skip(4),this._dataView.getFloat32(a,!0)}float64(){const a=this.position;return this.skip(8),this._dataView.getFloat64(a,!0)}skip(a){if(this._position+=a,this._position>this._buffer.length)throw new pickle.Error("Expected "+(this._position-this._buffer.length)+" more bytes. The file might be corrupted. Unexpected end of file.")}string(a,h){const t=this.bytes(a);return h=="utf-8"?pickle.Reader._utf8Decoder.decode(t):pickle.Reader._asciiDecoder.decode(t)}line(){const a=this._buffer.indexOf(10,this._position);if(a==-1)throw new pickle.Error("Could not find end of line.");const h=a-this._position,t=this.string(h,"ascii");return this.skip(1),t}},pickle.Error=class extends Error{constructor(a){super(a),this.name="Unpickle Error"}},typeof module!="undefined"&&typeof module.exports=="object"&&(module.exports.Unpickler=pickle.Unpickler);
