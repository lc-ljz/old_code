var mlnet=mlnet||{},zip=zip||require("./zip");mlnet.ModelFactory=class{match(t){if(t.identifier.split(".").pop().toLowerCase()==="zip"){const e=t.entries("zip");if(e.length>0){const s=new Set(["TransformerChain","Predictor"]);if(e.some(r=>s.has(r.name.split("\\").shift().split("/").shift())))return!0}}return!1}open(t,e){const s=t.identifier;return mlnet.Metadata.open(e).then(r=>{try{const n=new mlnet.ModelReader(t.entries("zip"));return new mlnet.Model(r,n)}catch(n){const i=n&&n.message?n.message:n.toString();throw new mlnet.Error(i.replace(/\.$/,"")+" in '"+s+"'.")}})}},mlnet.Model=class{constructor(t,e){this._format="ML.NET",e.version&&e.version.length>0&&(this._format+=" v"+e.version),this._graphs=[],this._graphs.push(new mlnet.Graph(t,e))}get format(){return this._format}get graphs(){return this._graphs}},mlnet.Graph=class{constructor(t,e){if(this._inputs=[],this._outputs=[],this._nodes=[],this._groups=!1,e.schema&&e.schema.inputs)for(const r of e.schema.inputs)this._inputs.push(new mlnet.Parameter(r.name,[new mlnet.Argument(r.name,new mlnet.TensorType(r.type))]));const s=new Map;e.dataLoaderModel&&this._loadTransformer(t,s,"",e.dataLoaderModel),e.predictor&&this._loadTransformer(t,s,"",e.predictor),e.transformerChain&&this._loadTransformer(t,s,"",e.transformerChain)}_loadTransformer(t,e,s,r){switch(r.__type__){case"TransformerChain":case"Text":this._loadChain(t,e,r.__name__,r.chain);break;default:this._createNode(t,e,s,r)}}_loadChain(t,e,s,r){this._groups=!0;const n=s.split("/").splice(1).join("/");for(const i of r)this._loadTransformer(t,e,n,i)}_createNode(t,e,s,r){if(r.inputs&&r.outputs){for(const n of r.inputs)n.name=e[n.name]?e[n.name].argument:n.name;for(const n of r.outputs)if(e[n.name]){e[n.name].counter++;const i=n.name+`
`+e[n.name].counter.toString();e[n.name].argument=i,n.name=i}else e[n.name]={argument:n.name,counter:0}}this._nodes.push(new mlnet.Node(t,s,r))}get groups(){return this._groups}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}},mlnet.Parameter=class{constructor(t,e){this._name=t,this._arguments=e}get name(){return this._name}get visible(){return!0}get arguments(){return this._arguments}},mlnet.Argument=class{constructor(t,e){if(typeof t!="string")throw new mlnet.Error("Invalid argument identifier '"+JSON.stringify(t)+"'.");this._name=t,this._type=e}get name(){return this._name}get type(){return this._type}},mlnet.Node=class{constructor(t,e,s){if(this._metadata=t,this._group=e,this._name=s.__name__,this._type=s.__type__,this._inputs=[],this._outputs=[],this._attributes=[],s.inputs){let r=0;for(const n of s.inputs)this._inputs.push(new mlnet.Parameter(r.toString(),[new mlnet.Argument(n.name)])),r++}if(s.outputs){let r=0;for(const n of s.outputs)this._outputs.push(new mlnet.Parameter(r.toString(),[new mlnet.Argument(n.name)])),r++}for(const r of Object.keys(s).filter(n=>!n.startsWith("_")&&n!=="inputs"&&n!=="outputs")){const n=t.attribute(this._type,this._name);this._attributes.push(new mlnet.Attribute(n,r,s[r]))}}get group(){return this._group}get type(){return this._type}get name(){return this._name}get metadata(){return this._metadata.type(this._type)}get inputs(){return this._inputs}get outputs(){return this._outputs}get attributes(){return this._attributes}},mlnet.Attribute=class{constructor(t,e,s){if(this._name=e,this._value=s,t&&(t.type&&(this._type=t.type),this._type)){let r=mlnet;const n=this._type.split(".");for(;r&&n.length>0;)r=r[n.shift()];if(r){mlnet.Attribute._reverseMap=mlnet.Attribute._reverseMap||{};let i=mlnet.Attribute._reverseMap[this._type];if(!i){i={};for(const o of Object.keys(r))i[r[o.toString()]]=o;mlnet.Attribute._reverseMap[this._type]=i}Object.prototype.hasOwnProperty.call(i,this._value)&&(this._value=i[this._value])}}}get type(){return this._type}get name(){return this._name}get value(){return this._value}get visible(){return!0}},mlnet.TensorType=class{constructor(t){if(mlnet.TensorType._map=mlnet.TensorType._map||new Map([["Byte","uint8"],["Boolean","boolean"],["Single","float32"],["Double","float64"],["UInt32","uint32"],["TextSpan","string"]]),this._dataType="?",this._shape=new mlnet.TensorShape(null),mlnet.TensorType._map.has(t.name))this._dataType=mlnet.TensorType._map.get(t.name);else if(t.name=="VBuffer"){if(!mlnet.TensorType._map.has(t.itemType.name))throw new mlnet.Error("Unknown data type '"+t.itemType.name+"'.");this._dataType=mlnet.TensorType._map.get(t.itemType.name),this._shape=new mlnet.TensorShape(t.dims)}else{if(t.name!="Key2")throw new mlnet.Error("Unknown data type '"+t.name+"'.");this._dataType="key2"}}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return this.dataType+this._shape.toString()}},mlnet.TensorShape=class{constructor(t){this._dimensions=t}get dimensions(){return this._dimensions}toString(){return this._dimensions&&this._dimensions.length!=0?"["+this._dimensions.join(",")+"]":""}},mlnet.Metadata=class{static open(t){return mlnet.Metadata._metadata?Promise.resolve(mlnet.Metadata._metadata):t.request(null,"mlnet-metadata.json","utf-8").then(e=>(mlnet.Metadata._metadata=new mlnet.Metadata(e),mlnet.Metadata._metadata)).catch(()=>(mlnet.Metadata._metadata=new mlnet.Metadata(null),mlnet.Metadata._metadatas))}constructor(t){if(this._map={},this._attributeCache={},t){const e=JSON.parse(t);if(e)for(const s of e)s.name&&s.schema&&(s.schema.name=s.name,this._map[s.name]=s.schema)}}type(t){return this._map[t]||null}attribute(t,e){let s=this._attributeCache[t];if(!s){s={};const r=this.type(t);if(r&&r.attributes&&r.attributes.length>0)for(const n of r.attributes)s[n.name]=n;this._attributeCache[t]=s}return s[e]||null}},mlnet.ModelReader=class{constructor(t){const e=new mlnet.ComponentCatalog;e.register("AffineNormExec",mlnet.AffineNormSerializationUtils),e.register("AnomalyPredXfer",mlnet.AnomalyPredictionTransformer),e.register("BinaryPredXfer",mlnet.BinaryPredictionTransformer),e.register("BinaryLoader",mlnet.BinaryLoader),e.register("CaliPredExec",mlnet.CalibratedPredictor),e.register("CdfNormalizeFunction",mlnet.CdfColumnFunction),e.register("CharToken",mlnet.TokenizingByCharactersTransformer),e.register("ChooseColumnsTransform",mlnet.ColumnSelectingTransformer),e.register("ClusteringPredXfer",mlnet.ClusteringPredictionTransformer),e.register("ConcatTransform",mlnet.ColumnConcatenatingTransformer),e.register("CopyTransform",mlnet.ColumnCopyingTransformer),e.register("ConvertTransform",mlnet.TypeConvertingTransformer),e.register("CSharpTransform",mlnet.CSharpTransform),e.register("DropColumnsTransform",mlnet.DropColumnsTransform),e.register("FAFMPredXfer",mlnet.FieldAwareFactorizationMachinePredictionTransformer),e.register("FastForestBinaryExec",mlnet.FastForestClassificationPredictor),e.register("FastTreeBinaryExec",mlnet.FastTreeBinaryModelParameters),e.register("FastTreeTweedieExec",mlnet.FastTreeTweedieModelParameters),e.register("FastTreeRankerExec",mlnet.FastTreeRankingModelParameters),e.register("FastTreeRegressionExec",mlnet.FastTreeRegressionModelParameters),e.register("FeatWCaliPredExec",mlnet.FeatureWeightsCalibratedModelParameters),e.register("FieldAwareFactMacPredict",mlnet.FieldAwareFactorizationMachineModelParameters),e.register("GcnTransform",mlnet.LpNormNormalizingTransformer),e.register("GenericScoreTransform",mlnet.GenericScoreTransform),e.register("IidChangePointDetector",mlnet.IidChangePointDetector),e.register("IidSpikeDetector",mlnet.IidSpikeDetector),e.register("ImageClassificationTrans",mlnet.ImageClassificationTransformer),e.register("ImageClassificationPred",mlnet.ImageClassificationModelParameters),e.register("ImageLoaderTransform",mlnet.ImageLoadingTransformer),e.register("ImageScalerTransform",mlnet.ImageResizingTransformer),e.register("ImagePixelExtractor",mlnet.ImagePixelExtractingTransformer),e.register("KeyToValueTransform",mlnet.KeyToValueMappingTransformer),e.register("KeyToVectorTransform",mlnet.KeyToVectorMappingTransformer),e.register("KMeansPredictor",mlnet.KMeansModelParameters),e.register("LinearRegressionExec",mlnet.LinearRegressionModelParameters),e.register("LightGBMRegressionExec",mlnet.LightGbmRegressionModelParameters),e.register("LightGBMBinaryExec",mlnet.LightGbmBinaryModelParameters),e.register("Linear2CExec",mlnet.LinearBinaryModelParameters),e.register("LinearModelStats",mlnet.LinearModelParameterStatistics),e.register("MaFactPredXf",mlnet.MatrixFactorizationPredictionTransformer),e.register("MFPredictor",mlnet.MatrixFactorizationModelParameters),e.register("MulticlassLinear",mlnet.LinearMulticlassModelParameters),e.register("MultiClassLRExec",mlnet.MaximumEntropyModelParameters),e.register("MultiClassNaiveBayesPred",mlnet.NaiveBayesMulticlassModelParameters),e.register("MultiClassNetPredictor",mlnet.MultiClassNetPredictor),e.register("MulticlassPredXfer",mlnet.MulticlassPredictionTransformer),e.register("NgramTransform",mlnet.NgramExtractingTransformer),e.register("NgramHashTransform",mlnet.NgramHashingTransformer),e.register("NltTokenizeTransform",mlnet.NltTokenizeTransform),e.register("Normalizer",mlnet.NormalizingTransformer),e.register("NormalizeTransform",mlnet.NormalizeTransform),e.register("OnnxTransform",mlnet.OnnxTransformer),e.register("OptColTransform",mlnet.OptionalColumnTransform),e.register("OVAExec",mlnet.OneVersusAllModelParameters),e.register("pcaAnomExec",mlnet.PcaModelParameters),e.register("PcaTransform",mlnet.PrincipalComponentAnalysisTransformer),e.register("PipeDataLoader",mlnet.CompositeDataLoader),e.register("PlattCaliExec",mlnet.PlattCalibrator),e.register("PMixCaliPredExec",mlnet.ParameterMixingCalibratedModelParameters),e.register("PoissonRegressionExec",mlnet.PoissonRegressionModelParameters),e.register("ProtonNNMCPred",mlnet.ProtonNNMCPred),e.register("RegressionPredXfer",mlnet.RegressionPredictionTransformer),e.register("RowToRowMapper",mlnet.RowToRowMapperTransform),e.register("SsaForecasting",mlnet.SsaForecastingTransformer),e.register("SSAModel",mlnet.AdaptiveSingularSpectrumSequenceModelerInternal),e.register("SelectColumnsTransform",mlnet.ColumnSelectingTransformer),e.register("StopWordsTransform",mlnet.StopWordsTransform),e.register("TensorFlowTransform",mlnet.TensorFlowTransformer),e.register("TermLookupTransform",mlnet.ValueMappingTransformer),e.register("TermTransform",mlnet.ValueToKeyMappingTransformer),e.register("TermManager",mlnet.TermManager),e.register("Text",mlnet.TextFeaturizingEstimator),e.register("TextLoader",mlnet.TextLoader),e.register("TextNormalizerTransform",mlnet.TextNormalizingTransformer),e.register("TokenizeTextTransform",mlnet.WordTokenizingTransformer),e.register("TransformerChain",mlnet.TransformerChain),e.register("ValueMappingTransformer",mlnet.ValueMappingTransformer),e.register("XGBoostMulticlass",mlnet.XGBoostMulticlass);const s=new mlnet.ModelHeader(e,t,"",null),r=s.openText("TrainingInfo/Version.txt");r&&(this.version=r.split(" ").shift().split("\r").shift());const n=s.openBinary("Schema");n&&(this.schema=new mlnet.BinaryLoader(null,n).schema);const i=s.open("TransformerChain");i&&(this.transformerChain=i);const o=s.open("DataLoaderModel");o&&(this.dataLoaderModel=o);const a=s.open("Predictor");a&&(this.predictor=a)}},mlnet.ComponentCatalog=class{constructor(){this._map=new Map}register(t,e){this._map.set(t,e)}create(t,e){if(!this._map.has(t))throw new mlnet.Error("Unknown loader signature '"+t+"'.");const s=this._map.get(t);return Reflect.construct(s,[e])}},mlnet.ModelHeader=class{constructor(t,e,s,r){if(this._entries=e,this._catalog=t,this._directory=s,r){const n=new mlnet.Reader(r),i=new TextDecoder("ascii");n.assert("ML\0MODEL"),this.versionWritten=n.uint32(),this.versionReadable=n.uint32();const o=n.uint64();n.uint64();const a=n.uint64(),l=n.uint64(),c=n.uint64();n.uint64(),this.modelSignature=i.decode(n.bytes(8)),this.modelVersionWritten=n.uint32(),this.modelVersionReadable=n.uint32(),this.loaderSignature=i.decode(n.bytes(24).filter(u=>u!=0)),this.loaderSignatureAlt=i.decode(n.bytes(24).filter(u=>u!=0));const m=n.uint64();n.uint64();const p=n.uint64(),M=n.uint32();if(a!=0&&c!=0){n.position=a;const u=l>>3,f=[];let g=0;for(let h=0;h<u;h++){const d=n.uint64();f.push(d-g),g=d}n.position=c,this.strings=[];for(let h=0;h<u;h++){const d=f[h]>>1;let T="";for(let _=0;_<d;_++)T+=String.fromCharCode(n.uint16());this.strings.push(T)}}p!=0&&(n.position=p,this.assemblyName=i.decode(n.bytes(M))),n.position=m,n.assert("LEDOM\0LM"),this._reader=n,this._reader.position=o}}get reader(){return this._reader}string(t){const e=this.reader.int32();return t===null&&e<0?null:this.strings[e]}open(t){const e=(t=(this._directory.length>0?this._directory+"/":this._directory)+t)+"/Model.key",s=this._entries.find(r=>r.name==e||r.name==e.replace(/\//g,"\\"));if(s){const r=new mlnet.ModelHeader(this._catalog,this._entries,t,s.data),n=this._catalog.create(r.loaderSignature,r);return n.__type__=n.__type__||r.loaderSignature,n.__name__=t,n}return null}openBinary(t){t=(this._directory.length>0?this._directory+"/":this._directory)+t;const s=this._entries.find(r=>r.name==t||r.name==t.replace(/\//g,"\\"));return s?new mlnet.Reader(s.data):null}openText(t){t=(this._directory.length>0?this._directory+"/":this._directory)+t;const s=this._entries.find(r=>r.name.split("\\").join("/")==t);return s?new TextDecoder().decode(s.data):null}check(t,e,s){return t===this.modelSignature&&e>=this.modelVersionReadable&&s<=this.modelVersionWritten}},mlnet.Reader=class{constructor(t){this._buffer=t,this._dataView=new DataView(t.buffer,t.byteOffset,t.byteLength),this._position=0}set position(t){this._position=t}get position(){return this._position}skip(t){if(this._position+=t,this._position>this._buffer.length)throw new mlnet.Error("Expected "+(this._position-this._buffer.length)+" more bytes. The file might be corrupted. Unexpected end of file.")}match(t){const e=this._position;for(let s=0;s<t.length;s++)if(this.byte()!=t.charCodeAt(s))return this._position=e,!1;return!0}assert(t){if(!this.match(t))throw new mlnet.Error("Invalid '"+t.split("\0").join("")+"' signature.")}boolean(){return this.byte()!=0}booleans(t){const e=[];for(let s=0;s<t;s++)e.push(this.boolean());return e}byte(){const t=this._position;return this.skip(1),this._dataView.getUint8(t)}bytes(t){const e=this._position;return this.skip(t),this._buffer.subarray(e,this._position)}int16(){const t=this._position;return this.skip(2),this._dataView.getInt16(t,!0)}uint16(){const t=this._position;return this.skip(2),this._dataView.getUint16(t,!0)}int32(){const t=this._position;return this.skip(4),this._dataView.getInt32(t,!0)}int32s(t){const e=[];for(let s=0;s<t;s++)e.push(this.int32());return e}uint32(){const t=this._position;return this.skip(4),this._dataView.getUint32(t,!0)}uint32s(t){const e=[];for(let s=0;s<t;s++)e.push(this.uint32());return e}int64(){const t=this.uint32(),e=this.uint32();if(t==4294967295&&e==2147483647)return Number.MAX_SAFE_INTEGER;if(e==-1)return-t;if(e!=0)throw new mlnet.Error("Value not in 48-bit range.");return e<<32|t}uint64(){const t=this.uint32(),e=this.uint32();if(e==0)return t;if(e>1048576)throw new mlnet.Error("Value not in 48-bit range.");return 4294967296*e+t}float32(){const t=this._position;return this.skip(4),this._dataView.getFloat32(t,!0)}float32s(t){const e=[];for(let s=0;s<t;s++)e.push(this.float32());return e}float64(){const t=this._position;return this.skip(8),this._dataView.getFloat64(t,!0)}float64s(t){const e=[];for(let s=0;s<t;s++)e.push(this.float64());return e}string(){const t=this.leb128(),e=this.bytes(t);return new TextDecoder("utf-8").decode(e)}leb128(){let t,e=0,s=0;do t=this.byte(),e|=(127&t)<<s,s+=7;while((128&t)!=0);return e}},mlnet.BinaryLoader=class{constructor(t,e){t&&(t.modelVersionWritten>=65538&&(this.Threads=t.reader.int32(),this.GeneratedRowIndexName=t.string(null)),this.ShuffleBlocks=t.modelVersionWritten>=65539?t.reader.float64():4,e=t.openBinary("Schema.idv")),e.assert("CML\0DVB\0"),e.bytes(8),e.bytes(8);const s=e.uint64(),r=e.int64();e.int64();const n=e.int32();e.position=r,e.assert("\0BVD\0LMC"),e.position=s,this.schema={},this.schema.inputs=[];for(let i=0;i<n;i++){const o={};o.name=e.string(),o.type=new mlnet.Codec(e),o.compression=e.byte(),o.rowsPerBlock=e.leb128(),o.lookupOffset=e.int64(),o.metadataTocOffset=e.int64(),this.schema.inputs.push(o)}}},mlnet.TransformerChain=class{constructor(t){const e=t.reader,s=e.int32();this.scopes=[],this.chain=[];for(let r=0;r<s;r++){this.scopes.push(e.int32());const n="Transform_"+("00"+r).slice(-3),i=t.open(n);this.chain.push(i)}}},mlnet.TransformBase=class{constructor(){}},mlnet.RowToRowTransformBase=class extends mlnet.TransformBase{constructor(t){super(t)}},mlnet.RowToRowTransformerBase=class{constructor(){}},mlnet.RowToRowMapperTransformBase=class extends mlnet.RowToRowTransformBase{constructor(t){super(t)}},mlnet.OneToOneTransformerBase=class{constructor(t){const e=t.reader.int32();this.inputs=[],this.outputs=[];for(let s=0;s<e;s++){const r=t.string(),n=t.string();this.outputs.push({name:r}),this.inputs.push({name:n})}}},mlnet.ColumnCopyingTransformer=class{constructor(t){const e=t.reader.uint32();this.inputs=[],this.outputs=[];for(let s=0;s<e;s++)this.outputs.push({name:t.string()}),this.inputs.push({name:t.string()})}},mlnet.ColumnConcatenatingTransformer=class{constructor(t){const e=t.reader;if(t.modelVersionReadable>=65539){const s=e.int32();for(let r=0;r<s;r++){this.outputs=[],this.outputs.push({name:t.string()});const n=e.int32();this.inputs=[];for(let i=0;i<n;i++){const o={name:t.string()},a=t.string(null);a&&(o.alias=a),this.inputs.push(o)}}}else{this.precision=e.int32();const s=e.int32(),r=[],n=[];for(let o=0;o<s;o++){r.push(t.string());const a=e.int32(),l=[];for(let c=0;c<a;c++)l.push(t.string());n.push(l)}const i=[];if(t.modelVersionReadable>=65538)for(let o=0;o<s;o++){n[o].length;const a={};if(i.push(a),t.modelVersionReadable>=65538)for(;;){const l=e.int32();if(l==-1)break;a[l]=t.string()}}if(s>1)throw new mlnet.Error("");this.outputs=[];for(let o=0;o<s;o++)this.outputs.push({name:r[o]}),this.inputs=n[o]}}},mlnet.PredictionTransformerBase=class{constructor(t){this.Model=t.open("Model");const e=t.openBinary("TrainSchema");e&&new mlnet.BinaryLoader(null,e).schema}},mlnet.MatrixFactorizationModelParameters=class{constructor(t){const e=t.reader;this.NumberOfRows=e.int32(),t.modelVersionWritten<65538&&e.uint64(),this.NumberOfColumns=e.int32(),t.modelVersionWritten<65538&&e.uint64(),this.ApproximationRank=e.int32(),this._leftFactorMatrix=e.float32s(this.NumberOfRows*this.ApproximationRank),this._rightFactorMatrix=e.float32s(this.NumberOfColumns*this.ApproximationRank)}},mlnet.MatrixFactorizationPredictionTransformer=class extends mlnet.PredictionTransformerBase{constructor(t){super(t),this.MatrixColumnIndexColumnName=t.string(),this.MatrixRowIndexColumnName=t.string()}},mlnet.FieldAwareFactorizationMachinePredictionTransformer=class extends mlnet.PredictionTransformerBase{constructor(t){super(t);const e=t.reader;this.inputs=[];for(let s=0;s<this.FieldCount;s++)this.inputs.push({name:t.string()});this.Threshold=e.float32(),this.ThresholdColumn=t.string(),this.inputs.push({name:this.ThresholdColumn})}},mlnet.SingleFeaturePredictionTransformerBase=class extends mlnet.PredictionTransformerBase{constructor(t){super(t);const e=t.string(null);this.inputs=[],this.inputs.push({name:e}),this.outputs=[],this.outputs.push({name:e})}},mlnet.ClusteringPredictionTransformer=class extends mlnet.SingleFeaturePredictionTransformerBase{constructor(t){super(t)}},mlnet.AnomalyPredictionTransformer=class extends mlnet.SingleFeaturePredictionTransformerBase{constructor(t){super(t);const e=t.reader;this.Threshold=e.float32(),this.ThresholdColumn=t.string()}},mlnet.AffineNormSerializationUtils=class{constructor(t){const e=t.reader;e.int32(),this.NumFeatures=e.int32(),e.int32()==-1&&(this.ScalesSparse=e.float32s(e.int32()),this.OffsetsSparse=e.float32s(e.int32()))}},mlnet.RegressionPredictionTransformer=class extends mlnet.SingleFeaturePredictionTransformerBase{constructor(t){super(t)}},mlnet.BinaryPredictionTransformer=class extends mlnet.SingleFeaturePredictionTransformerBase{constructor(t){super(t);const e=t.reader;this.Threshold=e.float32(),this.ThresholdColumn=t.string()}},mlnet.MulticlassPredictionTransformer=class extends mlnet.SingleFeaturePredictionTransformerBase{constructor(t){super(t),this.TrainLabelColumn=t.string(null),this.inputs.push({name:this.TrainLabelColumn})}},mlnet.PredictorBase=class{constructor(t){if(t.reader.int32()!=4)throw new mlnet.Error("Invalid float type size.")}},mlnet.ModelParametersBase=class{constructor(t){if(t.reader.int32()!==4)throw new mlnet.Error("This file was saved by an incompatible version.")}},mlnet.ImageClassificationModelParameters=class extends mlnet.ModelParametersBase{constructor(t){super(t);const e=t.reader;this.classCount=e.int32(),this.imagePreprocessorTensorInput=e.string(),this.imagePreprocessorTensorOutput=e.string(),this.graphInputTensor=e.string(),this.graphOutputTensor=e.string(),this.modelFile="TFModel"}},mlnet.NaiveBayesMulticlassModelParameters=class extends mlnet.ModelParametersBase{constructor(t){super(t);const e=t.reader;this._labelHistogram=e.int32s(e.int32()),this._featureCount=e.int32(),this._featureHistogram=[];for(let s=0;s<this._labelHistogram.length;s++)this._labelHistogram[s]>0&&this._featureHistogram.push(e.int32s(this._featureCount));this._absentFeaturesLogProb=e.float64s(this._labelHistogram.length)}},mlnet.LinearModelParameters=class extends mlnet.ModelParametersBase{constructor(t){super(t);const e=t.reader;this.Bias=e.float32(),e.int32(),this.Indices=e.int32s(e.int32()),this.Weights=e.float32s(e.int32())}},mlnet.LinearBinaryModelParameters=class extends mlnet.LinearModelParameters{constructor(t){super(t),t.modelVersionWritten>131073&&(this.Statistics=t.open("ModelStats"))}},mlnet.ModelStatisticsBase=class{constructor(t){const e=t.reader;this.ParametersCount=e.int32(),this.TrainingExampleCount=e.int64(),this.Deviance=e.float32(),this.NullDeviance=e.float32()}},mlnet.LinearModelParameterStatistics=class extends mlnet.ModelStatisticsBase{constructor(t){super(t);const e=t.reader;if(t.modelVersionWritten<65538&&!e.boolean())return;const s=e.float32s(this.ParametersCount);e.int32()==this.ParametersCount||(this.stdErrorIndices=e.int32s(this.ParametersCount)),this._coeffStdError=s,this._bias=e.float32();const r=e.byte(),n=e.int32(),i=e.float32s(n);r?this._weights=i:this.weightsIndices=e.int32s(n)}},mlnet.LinearMulticlassModelParametersBase=class extends mlnet.ModelParametersBase{constructor(t){super(t);const e=t.reader,s=e.int32(),r=e.int32();if(this.Biases=e.float32s(r),e.int32()==0){e.int32(),e.int32(),this.Weights=[];for(let o=0;o<r;o++){const a=e.float32s(s);this.Weights.push(a)}}else{const o=e.int32s(e.int32());e.int32();const a=[];for(let l=0;l<r;l++)a.push(e.int32s(o[l+1]-o[l]));e.int32(),this.Weights=[];for(let l=0;l<r;l++){const c=e.float32s(o[l+1]-o[l]);this.Weights.push(c)}}const n=t.openBinary("LabelNames");if(n){this.LabelNames=[];for(let o=0;o<r;o++){const a=n.int32();this.LabelNames.push(t.strings[a])}}const i=t.open("ModelStats");i&&(this.Statistics=i)}},mlnet.LinearMulticlassModelParameters=class extends mlnet.LinearMulticlassModelParametersBase{constructor(t){super(t)}},mlnet.RegressionModelParameters=class extends mlnet.LinearModelParameters{constructor(t){super(t)}},mlnet.PoissonRegressionModelParameters=class extends mlnet.RegressionModelParameters{constructor(t){super(t)}},mlnet.LinearRegressionModelParameters=class extends mlnet.RegressionModelParameters{constructor(t){super(t)}},mlnet.MaximumEntropyModelParameters=class extends mlnet.LinearMulticlassModelParametersBase{constructor(t){super(t)}},mlnet.TokenizingByCharactersTransformer=class extends mlnet.OneToOneTransformerBase{constructor(t){super(t);const e=t.reader;this.UseMarkerChars=e.boolean(),this.IsSeparatorStartEnd=t.modelVersionReadable<65538||e.boolean()}},mlnet.SequencePool=class{constructor(t){this.idLim=t.int32(),this.start=t.int32s(this.idLim+1),this.bytes=t.bytes(this.start[this.idLim])}},mlnet.NgramExtractingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(t){super(t);const e=t.reader;this.inputs.length==1&&this._option(t,e,this)}_option(t,e,s){const r=t.modelVersionReadable>=65538;s.NgramLength=e.int32(),s.SkipLength=e.int32(),r&&(s.Weighting=e.int32()),s.NonEmptyLevels=e.booleans(s.NgramLength),s.NgramMap=new mlnet.SequencePool(e),r&&(s.InvDocFreqs=e.float64s(e.int32()))}},mlnet.NgramHashingTransformer=class extends mlnet.RowToRowTransformerBase{constructor(t){super(t);const e=t.modelVersionWritten<65539,s=t.reader;e&&s.int32(),this.inputs=[],this.outputs=[];const r=s.int32();if(!e)for(let n=0;n<r;n++){this.outputs.push(t.string());const i=s.int32();for(let o=0;o<i;o++){const a=t.string();this.inputs.push(a)}}}},mlnet.WordTokenizingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(t){super(t);const e=t.reader;if(this.inputs.length==1){this.Separators=[];const s=e.int32();for(let r=0;r<s;r++)this.Separators.push(String.fromCharCode(e.int16()))}}},mlnet.TextNormalizingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(t){super(t);const e=t.reader;this.CaseMode=e.byte(),this.KeepDiacritics=e.boolean(),this.KeepPunctuations=e.boolean(),this.KeepNumbers=e.boolean()}},mlnet.TextNormalizingTransformer.CaseMode={Lower:0,Upper:1,None:2},mlnet.PrincipalComponentAnalysisTransformer=class extends mlnet.OneToOneTransformerBase{constructor(t){super(t);const e=t.reader;if(t.modelVersionReadable===65537&&e.int32()!==4)throw new mlnet.Error("This file was saved by an incompatible version.");this.TransformInfos=[];for(let s=0;s<this.inputs.length;s++){const r={};r.Dimension=e.int32(),r.Rank=e.int32(),r.Eigenvectors=[];for(let n=0;n<r.Rank;n++)r.Eigenvectors.push(e.float32s(r.Dimension));r.MeanProjected=e.float32s(e.int32()),this.TransformInfos.push(r)}}},mlnet.LpNormNormalizingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(t){super(t);const e=t.reader;t.modelVersionWritten<=65538&&e.int32(),this.inputs.length==1&&(this.EnsureZeroMean=e.boolean(),this.Norm=e.byte(),this.Scale=e.float32())}},mlnet.KeyToVectorMappingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(t){super(t);const e=t.reader;t.modelVersionWritten==65537&&e.int32();const s=this.inputs.length;this.Bags=e.booleans(s)}},mlnet.TypeConvertingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(t){super(t)}},mlnet.ImageLoadingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(t){super(t),this.ImageFolder=t.string(null)}},mlnet.ImageResizingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(t){super(t);const e=t.reader;if(this.inputs.length==1)this._option(e,this);else{this.Options=[];for(let s=0;s<this.inputs.length;s++){const r={};this._option(e,r),this.Options.push(r)}}}_option(t,e){e.Width=t.int32(),e.Height=t.int32(),e.Resizing=t.byte(),e.Anchor=t.byte()}},mlnet.ImageResizingTransformer.ResizingKind={IsoPad:0,IsoCrop:1,Fill:2},mlnet.ImageResizingTransformer.Anchor={Right:0,Left:1,Top:2,Bottom:3,Center:4},mlnet.ImagePixelExtractingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(t){super(t);const e=t.reader;if(this.inputs.length==1)this._option(t,e,this);else{this.Options=[];for(let s=0;s<this.inputs.length;s++){const r={};this._option(t,e,r),this.Options.push(r)}}}_option(t,e,s){s.ColorsToExtract=e.byte(),s.OrderOfExtraction=t.modelVersionWritten<=65538?mlnet.ImagePixelExtractingTransformer.ColorsOrder.ARGB:e.byte();let r=s.ColorsToExtract;r=(5&r)+(r>>1&5),r=(3&r)+(r>>2&3),s.Planes=255&r,s.OutputAsFloatArray=e.boolean(),s.OffsetImage=e.float32(),s.ScaleImage=e.float32(),s.InterleavePixelColors=e.boolean()}},mlnet.ImagePixelExtractingTransformer.ColorBits={Alpha:1,Red:2,Green:4,Blue:8,Rgb:14,All:15},mlnet.ImagePixelExtractingTransformer.ColorsOrder={ARGB:1,ARBG:2,ABRG:3,ABGR:4,AGRB:5,AGBR:6},mlnet.NormalizingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(t){super(t);const e=t.reader;this.Options=[];for(let s=0;s<this.inputs.length;s++){let r=!1,n=0,i="";t.modelVersionWritten<65538?(r=e.boolean(),n=[e.int32()],i=e.byte()):(r=e.boolean(),i=e.byte(),n=e.int32s(e.int32()));let o="";switch(i){case 9:o="float32";break;case 10:o="float64";break;default:throw new mlnet.Error("Unknown NormalizingTransformer item kind '"+i+"'.")}const a=o+(r?"["+n.map(m=>m.toString()).join(",")+"]":""),l="Normalizer_"+("00"+s).slice(-3),c=t.open(l);this.Options.push({type:a,func:c})}}},mlnet.KeyToValueMappingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(t){super(t)}},mlnet.ValueToKeyMappingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(t){super(t);const e=t.reader;if(t.modelVersionWritten>=65539)this.textMetadata=e.booleans(this.outputs.length+this.inputs.length);else{this.textMetadata=[];for(let r=0;r<this.columnPairs.length;r++)this.textMetadata.push(!1)}const s=t.open("Vocabulary");s&&(this.termMap=s.termMap)}},mlnet.TermMap=class{constructor(t){const e=t.reader,s=e.byte();switch(s){case 0:{this.values=[];const r=e.int32();for(let n=0;n<r;n++)this.values.push(t.string());break}case 1:{const r=new mlnet.Codec(e),n=e.int32();this.values=r.read(e,n);break}default:throw new mlnet.Error("Unknown term map type '"+s.toString()+"'.")}}},mlnet.TermManager=class{constructor(t){const e=t.reader.int32();if(this.termMap=[],!(t.modelVersionWritten>=65538))throw new mlnet.Error("Unsupported TermManager version.");for(let s=0;s<e;++s)this.termMap.push(new mlnet.TermMap(t))}},mlnet.ValueMappingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(t){super(t),this.keyColumnName="Key",t.check("TXTLOOKT",65538,65538)&&(this.keyColumnName="Term")}},mlnet.KeyToVectorTransform=class{constructor(){}},mlnet.GenericScoreTransform=class{constructor(){}},mlnet.CompositeDataLoader=class{constructor(t){t.open("Loader");const e=t.reader;e.int32();const s=e.int32(),r=[];for(let n=0;n<s;n++){let i="",o=null;t.modelVersionReadable>=65538&&(i=t.string(),o=t.string(null)),r.push([i,o])}this.chain=[];for(let n=0;n<s;n++){const i="Transform_"+("00"+n).slice(-3),o=t.open(i);this.chain.push(o)}}},mlnet.RowToRowMapperTransform=class extends mlnet.RowToRowTransformBase{constructor(t){super(t);const e=t.open("Mapper");this.__type__=e.__type__;for(const s of Object.keys(e))this[s]=e[s]}},mlnet.ImageClassificationTransformer=class extends mlnet.RowToRowTransformerBase{constructor(t){super(t);const e=t.reader;this.addBatchDimensionInput=e.boolean();const s=e.int32();this.inputs=[];for(let n=0;n<s;n++)this.inputs.push({name:t.string()});this.outputs=[];const r=e.int32();for(let n=0;n<r;n++)this.outputs.push({name:t.string()});this.labelColumn=e.string(),this.checkpointName=e.string(),this.arch=e.int32(),this.scoreColumnName=e.string(),this.predictedColumnName=e.string(),this.learningRate=e.float32(),this.classCount=e.int32(),this.keyValueAnnotations=[];for(let n=0;n<this.classCount;n++)this.keyValueAnnotations.push(t.string());this.predictionTensorName=e.string(),this.softMaxTensorName=e.string(),this.jpegDataTensorName=e.string(),this.resizeTensorName=e.string()}},mlnet.OnnxTransformer=class extends mlnet.RowToRowTransformerBase{constructor(t){super(t);const e=t.reader;this.modelFile="OnnxModel";const s=t.modelVersionWritten>65537?e.int32():1;this.inputs=[];for(let n=0;n<s;n++)this.inputs.push({name:t.string()});const r=t.modelVersionWritten>65537?e.int32():1;this.outputs=[];for(let n=0;n<r;n++)this.outputs.push({name:t.string()});if(t.modelVersionWritten>65548){const n=e.int32();this.LoadedCustomShapeInfos=[];for(let i=0;i<n;i++)this.LoadedCustomShapeInfos.push({name:t.string(),shape:e.int32s(e.int32())})}}},mlnet.OptionalColumnTransform=class extends mlnet.RowToRowMapperTransformBase{constructor(t){super(t)}},mlnet.TensorFlowTransformer=class extends mlnet.RowToRowTransformerBase{constructor(t){super(t);const e=t.reader;this.IsFrozen=!(t.modelVersionReadable>=65538)||e.boolean(),this.AddBatchDimensionInput=!(t.modelVersionReadable>=65539)||e.boolean();const s=e.int32();this.inputs=[];for(let n=0;n<s;n++)this.inputs.push({name:t.string()});const r=t.modelVersionReadable>=65538?e.int32():1;this.outputs=[];for(let n=0;n<r;n++)this.outputs.push({name:t.string()})}},mlnet.OneVersusAllModelParameters=class extends mlnet.ModelParametersBase{constructor(t){super(t);const e=t.reader;this.UseDist=e.boolean();const s=e.int32();this.chain=[];for(let r=0;r<s;r++){const n="SubPredictor_"+("00"+r).slice(-3),i=t.open(n);this.chain.push(i)}}},mlnet.TextFeaturizingEstimator=class{constructor(t){if(t.modelVersionReadable===65537){const e=t.reader.int32();this.chain=[],t.open("Loader");for(let s=0;s<e;s++){const r="Step_"+("00"+s).slice(-3),n=t.open(r);this.chain.push(n)}}else{const e=t.open("Chain");this.chain=e.chain}}},mlnet.TextLoader=class{constructor(t){const e=t.reader;e.int32(),this.MaxRows=e.int64(),this.Flags=e.uint32(),this.InputSize=e.int32();const s=e.int32();this.Separators=[];for(let r=0;r<s;r++)this.Separators.push(String.fromCharCode(e.uint16()));this.Bindinds=new mlnet.TextLoader.Bindinds(t)}},mlnet.TextLoader.Bindinds=class{constructor(t){const e=t.reader.int32();for(let s=0;s<e;s++);}},mlnet.CalibratedPredictorBase=class{constructor(t,e){this.SubPredictor=t,this.Calibrator=e}},mlnet.ValueMapperCalibratedPredictorBase=class extends mlnet.CalibratedPredictorBase{constructor(t,e){super(t,e)}},mlnet.CalibratedModelParametersBase=class{constructor(t){this.Predictor=t.open("Predictor"),this.Calibrator=t.open("Calibrator")}},mlnet.ValueMapperCalibratedModelParametersBase=class extends mlnet.CalibratedModelParametersBase{constructor(t){super(t)}},mlnet.CalibratedPredictor=class extends mlnet.ValueMapperCalibratedPredictorBase{constructor(t){super(t.open("Predictor"),t.open("Calibrator"))}},mlnet.ParameterMixingCalibratedModelParameters=class extends mlnet.ValueMapperCalibratedModelParametersBase{constructor(t){super(t)}},mlnet.FieldAwareFactorizationMachineModelParameters=class{constructor(t){const e=t.reader;this.Norm=e.boolean(),this.FieldCount=e.int32(),this.FeatureCount=e.int32(),this.LatentDim=e.int32(),this.LinearWeights=e.float32s(e.int32()),this.LatentWeights=e.float32s(e.int32())}},mlnet.KMeansModelParameters=class extends mlnet.ModelParametersBase{constructor(t){super(t);const e=t.reader;this.k=e.int32(),this.Dimensionality=e.int32(),this.Centroids=[];for(let s=0;s<this.k;s++){const r=t.modelVersionWritten>=65538?e.int32():this.Dimensionality,n=r<this.Dimensionality?e.int32s(r):null,i=e.float32s(r);this.Centroids.push({indices:n,values:i})}}},mlnet.PcaModelParameters=class extends mlnet.ModelParametersBase{constructor(t){super(t);const e=t.reader;this.Dimension=e.int32(),this.Rank=e.int32();const s=e.boolean();this.Mean=s?e.float32s(this.Dimension):[],this.EigenVectors=[];for(let r=0;r<this.Rank;++r)this.EigenVectors.push(e.float32s(this.Dimension))}},mlnet.TreeEnsembleModelParameters=class extends mlnet.ModelParametersBase{constructor(t){super(t);const e=t.reader,s=t.modelVersionWritten>=this.VerDefaultValueSerialized,r=t.modelVersionWritten>=this.VerCategoricalSplitSerialized;this.TrainedEnsemble=new mlnet.InternalTreeEnsemble(t,s,r),this.InnerOptions=t.string(null),t.modelVersionWritten>=this.verNumFeaturesSerialized&&(this.NumFeatures=e.int32())}},mlnet.InternalTreeEnsemble=class{constructor(t,e,s){const r=t.reader;this.Trees=[];const n=r.int32();for(let i=0;i<n;i++)switch(r.byte()){case mlnet.InternalTreeEnsemble.TreeType.Regression:this.Trees.push(new mlnet.InternalRegressionTree(t,e,s));break;case mlnet.InternalTreeEnsemble.TreeType.FastForest:this.Trees.push(new mlnet.InternalQuantileRegressionTree(t,e,s));break;case mlnet.InternalTreeEnsemble.TreeType.Affine:throw new mlnet.Error("Affine regression trees unsupported");default:throw new mlnet.Error("Unknown ensemble tree type.")}this.Bias=r.float64(),this.FirstInputInitializationContent=t.string(null)}},mlnet.InternalRegressionTree=class{constructor(t,e,s){const r=t.reader;if(this.NumLeaves=r.int32(),this.MaxOuptut=r.float64(),this.Weight=r.float64(),this.LteChild=r.int32s(r.int32()),this.GtChild=r.int32s(r.int32()),this.SplitFeatures=r.int32s(r.int32()),s){const n=r.int32s(r.int32());if(n.length>0){this.CategoricalSplitFeatures=[],this.CategoricalSplitFeatureRanges=[];for(const i of n)this.CategoricalSplitFeatures[i]=r.int32s(r.int32()),this.CategoricalSplitFeatureRanges[i]=r.int32s(2)}}this.Thresholds=r.uint32s(r.int32()),this.RawThresholds=r.float32s(r.int32()),this.DefaultValueForMissing=e?r.float32s(r.int32()):null,this.LeafValues=r.float64s(r.int32()),this.SplitGain=r.float64s(r.int32()),this.GainPValue=r.float64s(r.int32()),this.PreviousLeafValue=r.float64s(r.int32())}},mlnet.InternalTreeEnsemble.TreeType={Regression:0,Affine:1,FastForest:2},mlnet.TreeEnsembleModelParametersBasedOnRegressionTree=class extends mlnet.TreeEnsembleModelParameters{constructor(t){super(t)}},mlnet.FastTreeTweedieModelParameters=class extends mlnet.TreeEnsembleModelParametersBasedOnRegressionTree{constructor(t){super(t)}get VerNumFeaturesSerialized(){return 65537}get VerDefaultValueSerialized(){return 65538}get VerCategoricalSplitSerialized(){return 65539}},mlnet.FastTreeRankingModelParameters=class extends mlnet.TreeEnsembleModelParametersBasedOnRegressionTree{constructor(t){super(t)}get VerNumFeaturesSerialized(){return 65538}get VerDefaultValueSerialized(){return 65540}get VerCategoricalSplitSerialized(){return 65541}},mlnet.FastTreeBinaryModelParameters=class extends mlnet.TreeEnsembleModelParametersBasedOnRegressionTree{constructor(t){super(t)}get VerNumFeaturesSerialized(){return 65538}get VerDefaultValueSerialized(){return 65540}get VerCategoricalSplitSerialized(){return 65541}},mlnet.FastTreeRegressionModelParameters=class extends mlnet.TreeEnsembleModelParametersBasedOnRegressionTree{constructor(t){super(t)}get VerNumFeaturesSerialized(){return 65538}get VerDefaultValueSerialized(){return 65540}get VerCategoricalSplitSerialized(){return 65541}},mlnet.LightGbmRegressionModelParameters=class extends mlnet.TreeEnsembleModelParametersBasedOnRegressionTree{constructor(t){super(t)}get VerNumFeaturesSerialized(){return 65538}get VerDefaultValueSerialized(){return 65540}get VerCategoricalSplitSerialized(){return 65541}},mlnet.LightGbmBinaryModelParameters=class extends mlnet.TreeEnsembleModelParametersBasedOnRegressionTree{constructor(t){super(t)}get VerNumFeaturesSerialized(){return 65538}get VerDefaultValueSerialized(){return 65540}get VerCategoricalSplitSerialized(){return 65541}},mlnet.FeatureWeightsCalibratedModelParameters=class extends mlnet.ValueMapperCalibratedModelParametersBase{constructor(t){super(t)}},mlnet.FastTreePredictionWrapper=class{constructor(){}},mlnet.FastForestClassificationPredictor=class extends mlnet.FastTreePredictionWrapper{constructor(t){super(t)}},mlnet.PlattCalibrator=class{constructor(t){const e=t.reader;this.ParamA=e.float64(),this.ParamB=e.float64()}},mlnet.Codec=class{constructor(t){this.name=t.string();const e=t.leb128(),s=t.bytes(e);switch(t=new mlnet.Reader(s),this.name){case"Boolean":case"Single":case"Double":case"Byte":case"Int32":case"UInt32":case"Int64":case"TextSpan":break;case"VBuffer":this.itemType=new mlnet.Codec(t),this.dims=t.int32s(t.int32());break;case"Key":case"Key2":this.itemType=new mlnet.Codec(t),this.count=t.uint64();break;default:throw new mlnet.Error("Unknown codec '"+this.name+"'.")}}read(t,e){const s=[];switch(this.name){case"Single":for(let r=0;r<e;r++)s.push(t.float32());break;case"Int32":for(let r=0;r<e;r++)s.push(t.int32());break;case"Int64":for(let r=0;r<e;r++)s.push(t.int64());break;default:throw new mlnet.Error("Unknown codec read operation '"+this.name+"'.")}return s}},mlnet.SequentialTransformerBase=class{constructor(t){const e=t.reader;this.WindowSize=e.int32(),this.InitialWindowSize=e.int32(),this.inputs=[],this.inputs.push({name:t.string()}),this.outputs=[],this.outputs.push({name:t.string()}),this.ConfidenceLowerBoundColumn=e.string(),this.ConfidenceUpperBoundColumn=e.string(),this.Type=new mlnet.Codec(e)}},mlnet.AnomalyDetectionStateBase=class{constructor(t){const e=t.reader;this.LogMartingaleUpdateBuffer=mlnet.AnomalyDetectionStateBase._deserializeFixedSizeQueueDouble(e),this.RawScoreBuffer=mlnet.AnomalyDetectionStateBase._deserializeFixedSizeQueueDouble(e),this.LogMartingaleValue=e.float64(),this.SumSquaredDist=e.float64(),this.MartingaleAlertCounter=e.int32()}static _deserializeFixedSizeQueueDouble(t){t.int32();const e=t.int32(),s=[];for(let r=0;r<e;r++)s.push(t.float64());return s}},mlnet.SequentialAnomalyDetectionTransformBase=class extends mlnet.SequentialTransformerBase{constructor(t){super(t);const e=t.reader;this.Martingale=e.byte(),this.ThresholdScore=e.byte(),this.Side=e.byte(),this.PowerMartingaleEpsilon=e.float64(),this.AlertThreshold=e.float64(),this.State=new mlnet.AnomalyDetectionStateBase(t)}},mlnet.TimeSeriesUtils=class{static deserializeFixedSizeQueueSingle(t){t.int32();const e=t.int32(),s=[];for(let r=0;r<e;r++)s.push(t.float32());return s}},mlnet.IidAnomalyDetectionBase=class extends mlnet.SequentialAnomalyDetectionTransformBase{constructor(t){super(t);const e=t.reader;this.WindowedBuffer=mlnet.TimeSeriesUtils.deserializeFixedSizeQueueSingle(e),this.InitialWindowedBuffer=mlnet.TimeSeriesUtils.deserializeFixedSizeQueueSingle(e)}},mlnet.IidAnomalyDetectionBaseWrapper=class{constructor(t){const e=new mlnet.IidAnomalyDetectionBase(t);for(const s of Object.keys(e))this[s]=e[s]}},mlnet.IidChangePointDetector=class extends mlnet.IidAnomalyDetectionBaseWrapper{constructor(t){super(t)}},mlnet.IidSpikeDetector=class extends mlnet.IidAnomalyDetectionBaseWrapper{constructor(t){super(t)}},mlnet.SequenceModelerBase=class{constructor(){}},mlnet.RankSelectionMethod={Fixed:0,Exact:1,Fact:2},mlnet.AdaptiveSingularSpectrumSequenceModelerInternal=class extends mlnet.SequenceModelerBase{constructor(t){super(t);const e=t.reader;this._seriesLength=e.int32(),this._windowSize=e.int32(),this._trainSize=e.int32(),this._rank=e.int32(),this._discountFactor=e.float32(),this._rankSelectionMethod=e.byte();const s=e.byte();this._alpha=e.float32s(e.int32()),t.modelVersionReadable>=65538&&(this._state=e.float32s(e.int32())),this.ShouldComputeForecastIntervals=e.byte(),this._observationNoiseVariance=e.float32(),this._autoregressionNoiseVariance=e.float32(),this._observationNoiseMean=e.float32(),this._autoregressionNoiseMean=e.float32(),t.modelVersionReadable>=65538&&(this._nextPrediction=e.float32()),this._maxRank=e.int32(),this._shouldStablize=e.byte(),this._shouldMaintainInfo=e.byte(),this._maxTrendRatio=e.float64(),s&&(this._wTrans=e.float32s(e.int32()),this._y=e.float32s(e.int32())),this._buffer=mlnet.TimeSeriesUtils.deserializeFixedSizeQueueSingle(e)}},mlnet.SequentialForecastingTransformBase=class extends mlnet.SequentialTransformerBase{constructor(t){super(t);const e=t.reader;this._outputLength=e.int32()}},mlnet.SsaForecastingBaseWrapper=class extends mlnet.SequentialForecastingTransformBase{constructor(t){super(t);const e=t.reader;this.IsAdaptive=e.boolean(),this.Horizon=e.int32(),this.ConfidenceLevel=e.float32(),this.WindowedBuffer=mlnet.TimeSeriesUtils.deserializeFixedSizeQueueSingle(e),this.InitialWindowedBuffer=mlnet.TimeSeriesUtils.deserializeFixedSizeQueueSingle(e),this.Model=t.open("SSA")}},mlnet.SsaForecastingTransformer=class extends mlnet.SsaForecastingBaseWrapper{constructor(t){super(t)}},mlnet.ColumnSelectingTransformer=class{constructor(t){const e=t.reader;if(t.check("DRPCOLST",65538,65538))throw new mlnet.Error("'LoadDropColumnsTransform' not supported.");if(t.check("CHSCOLSF",65537,65537)){e.int32(),this.KeepHidden=this._getHiddenOption(e.byte());const s=e.int32();this.inputs=[];for(let r=0;r<s;r++){const n=t.string();this.inputs.push(n),t.string(),this._getHiddenOption(e.byte())}}else{const s=e.boolean();this.KeepHidden=e.boolean(),this.IgnoreMissing=e.boolean();const r=e.int32();this.inputs=[];for(let n=0;n<r;n++)this.inputs.push({name:t.string()});s?this.ColumnsToKeep=this.inputs:this.ColumnsToDrop=this.inputs}}_getHiddenOption(t){switch(t){case 1:return!0;case 2:return!1;default:throw new mlnet.Error("Unsupported hide option specified")}}},mlnet.XGBoostMulticlass=class{},mlnet.NltTokenizeTransform=class{},mlnet.DropColumnsTransform=class{},mlnet.StopWordsTransform=class{},mlnet.CSharpTransform=class{},mlnet.GenericScoreTransform=class{},mlnet.NormalizeTransform=class{},mlnet.CdfColumnFunction=class{constructor(){}},mlnet.MultiClassNetPredictor=class{},mlnet.ProtonNNMCPred=class{},mlnet.Error=class extends Error{constructor(t){super(t),this.name="ML.NET Error"}},module&&module.exports&&(module.exports.ModelFactory=mlnet.ModelFactory);
