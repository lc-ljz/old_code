var mxnet=mxnet||{},long=long||{Long:require("long")},zip=zip||require("./zip"),ndarray=ndarray||{};mxnet.ModelFactory=class{match(t){const s=t.identifier.split(".").pop().toLowerCase();if(s==="model"||s==="mar"){if(t.entries("zip").length>0)return!0}else if(s=="json"){const e=t.text;if(e.indexOf('"nodes":',0)!=-1)try{const a=JSON.parse(e);if(a&&a.nodes&&a.arg_nodes&&a.heads)return!0}catch(a){}}else if(s=="params"){const e=t.buffer,a=[18,1,0,0,0,0,0,0];if(e&&e.length>a.length&&a.every((o,h)=>o==e[h]))return!0}return!1}open(t,s){const e=t.identifier,a=t.identifier.split(".").pop().toLowerCase();let o=null,h=null,n=null,c=null;switch(a){case"json":try{return o=JSON.parse(t.text),o&&o.nodes&&o.nodes.some(i=>i&&i.op=="tvm_op")&&(n="TVM"),c=mxnet.ModelFactory._basename(e,"json","symbol"),c?t.request(c+"-0000.params",null).then(i=>this._openModel(e,n,null,o,null,i,s)).catch(()=>this._openModel(e,n,null,o,null,h,s)):this._openModel(e,n,null,o,null,null,s)}catch(i){throw s.exception(i,!1),new mxnet.Error(i.message),null}case"params":return h=t.buffer,c=mxnet.ModelFactory._basename(t.identifier,"params"),c?t.request(c+"-symbol.json","utf-8").then(i=>(o=JSON.parse(i),o&&o.nodes&&o.nodes.some(p=>p&&p.op=="tvm_op")&&(n="TVM"),this._openModel(e,n,null,o,null,h,s))).catch(()=>this._openModel(e,n,null,null,null,h,s)):this._openModel(e,n,null,null,null,h,s);case"mar":case"model":{const i=new Map;try{for(const m of t.entries("zip"))i.set(m.name,m)}catch(m){throw new mxnet.Error("Failed to decompress Zip archive. "+m.message)}let p=i.get(i.has("MANIFEST.json")?"MANIFEST.json":"MAR-INF/MANIFEST.json"),u="";if(!p){const m=Array.from(i.keys()).filter(w=>w.endsWith("/")).filter(w=>i.get(w+"MANIFEST.json"));if(m.length!=1)throw new mxnet.Error("Manifest not found in '"+t.identifier+"'.");u=m[0],p=i.get(u+"MANIFEST.json")}const _=new TextDecoder("utf-8");let r=null;try{r=JSON.parse(_.decode(p.data))}catch(m){throw new mxnet.Error("Failed to read manifest. "+m.message)}let l=null,d=null,f=null,g=null;if(r.Model){if(l=r.Model["Model-Format"],l&&l!="MXNet-Symbolic")throw new mxnet.Error("Model format '"+l+"' not supported.");if(n="MXNet Model Server",r["Model-Archive-Version"]&&(n+=" v"+r["Model-Archive-Version"].toString()),!r.Model.Symbol)throw new mxnet.Error("Manifest does not contain symbol entry.");d=i.get(u+r.Model.Symbol),r.Model.Signature&&(f=i.get(u+r.Model.Signature)),r.Model.Parameters&&(g=i.get(u+r.Model.Parameters))}else{if(!r.model)throw new mxnet.Error("Manifest does not contain model.");if(n="MXNet Model Archive",r.specificationVersion&&(n+=" v"+r.specificationVersion.toString()),r.model.modelName){d=i.get(u+r.model.modelName+"-symbol.json");let m=null;for(m of Array.from(i.keys()))if(m=m.substring(u.length),m.endsWith(".params")&&m.startsWith(r.model.modelName)){g=i.get(m);break}if(!d&&!g){for(m of Object.keys(i))if(m=m.substring(u.length),m.endsWith(".params")){g=i.get(m);break}}}}if(!d&&!g)throw new mxnet.Error("Model does not contain symbol entry.");try{d&&(o=JSON.parse(_.decode(d.data)))}catch(m){throw new mxnet.Error("Failed to load symbol entry."+m.message)}g&&(h=g.data);let y=null;try{f&&(y=JSON.parse(_.decode(f.data)))}catch(m){}try{return this._openModel(e,n,r,o,y,h,s)}catch(m){const w=m&&m.message?m.message:m.toString();throw new mxnet.Error(w.replace(/\.$/,"")+" in '"+e+"'.")}}default:throw new mxnet.Error("Unsupported file extension.")}}_openModel(t,s,e,a,o,h,n){return mxnet.Metadata.open(n).then(c=>{const i=new Map;if(h)try{const p=new ndarray.Stream(h);for(const u of Object.keys(p.arrays)){const _=u.startsWith("arg:")||u.startsWith("aux:")?u.substring(4):u;i.set(_,p.arrays[u])}}catch(p){}try{return new mxnet.Model(c,s,e,a,o,i)}catch(p){n.exception(p,!1);const u=p&&p.message?p.message:p.toString();throw new mxnet.Error(u.replace(/\.$/,"")+" in '"+t+"'.")}})}static _basename(t,s,e){const a=t.split(".");if(a.length>=2&&a.pop().toLowerCase()===s){const o=a.join(".").split("-");if(o.length>=2){const h=o.pop();if(e){if(h!=e)return null}else for(let n=0;n<h.length;n++){const c=h.charAt(n);if(!(c>="0"&&c<="9"||c>="A"&&c<="Z"||c>="a"&&c<="z"))return null}return o.join("-")}}return null}},mxnet.Model=class{constructor(t,s,e,a,o,h){if(!a&&!h)throw new mxnet.Error("JSON symbol data not available.");if(a){if(!Object.prototype.hasOwnProperty.call(a,"nodes"))throw new mxnet.Error("JSON file does not contain an MXNet 'nodes' property.");if(!Object.prototype.hasOwnProperty.call(a,"arg_nodes"))throw new mxnet.Error("JSON file does not contain an MXNet 'arg_nodes' property.");if(!Object.prototype.hasOwnProperty.call(a,"heads"))throw new mxnet.Error("JSON file does not contain an MXNet 'heads' property.")}if(e){if(e.Model&&e.Model["Model-Name"]&&(this._name=e.Model["Model-Name"]),e.Model&&e.Model.Description&&this._name!=e.Model.Description&&(this._description=e.Model.Description),e.Engine&&e.Engine.MXNet){const n=mxnet.Model._convert_version(e.Engine.MXNet);this._runtime="MXNet v"+(n||e.Engine.MXNet.toString())}if(e.License&&(this._license=e.License),e.model&&e.model.modelName&&(this._name=e.model.modelName),e.model&&e.model.modelVersion&&(this._version=e.model.modelVersion),e.model&&e.model.modelName&&this._name!=e.model.description&&(this._description=e.model.description),e.runtime&&(this._runtime=e.runtime),e.engine&&e.engine.engineName){const n=e.engine.engineVersion?e.engine.engineName+" "+e.engine.engineVersion:e.engine.engineName;this._runtime=this._runtime?this._runtime+" ("+n+")":n}e.publisher&&e.publisher.author&&(this._author=e.publisher.author,e.publisher.email&&(this._author=this._author+" <"+e.publisher.email+">")),e.license&&(this._license=e.license)}if(this._format=s,!this._format&&a&&a.attrs&&a.attrs.mxnet_version){const n=mxnet.Model._convert_version(a.attrs.mxnet_version);n&&(this._format="MXNet v"+n)}this._format||(this._format="MXNet"),this._graphs=[],this._graphs.push(new mxnet.Graph(t,e,a,o,h))}get format(){return this._format}get name(){return this._name}get version(){return this._version}get description(){return this._description}get author(){return this._author}get license(){return this._license}get runtime(){return this._runtime}get graphs(){return this._graphs}static _convert_version(t){if(Array.isArray(t)&&t.length==2&&t[0]=="int"){const s=Math.floor(t[1]/1e4)%100,e=Math.floor(t[1]/100)%100,a=Math.floor(t[1])%100;return[s.toString(),e.toString(),a.toString()].join(".")}return null}},mxnet.Graph=class{constructor(t,s,e,a,o){this._metadata=t,this._nodes=[],this._inputs=[],this._outputs=[];const h=new Map;if(o)for(const n of o){const c=n[0],i=n[1];h.set(c,new mxnet.Tensor("Initializer",c,new mxnet.TensorType(i.dataType,new mxnet.TensorShape(i.shape.dimensions)),i.data))}if(e){const n=e.nodes,c={};if(a&&a.inputs)for(const r of a.inputs)c[r.data_name]=r;const i={};if(a&&a.outputs)for(const r of a.outputs)i[r.data_name]=r;for(const r of n)r.outputs=[];for(const r of n)r.inputs=r.inputs.map(l=>mxnet.Graph._updateOutput(n,l));const p={};for(const r of n)for(const l of r.outputs)p[l]=(p[l]||0)+1;const u={};for(const r of e.arg_nodes)u[r]=r<n.length?n[r]:null;for(let r=0;r<e.heads.length;r++){const l=e.heads[r],d=mxnet.Graph._updateOutput(n,l),f=n[d[0]]?n[d[0]].name:"output"+(r==0?"":(r+1).toString());let g=null;const y=i[f];y&&y.data_shape&&(g=new mxnet.TensorType(-1,new mxnet.TensorShape(y.data_shape))),this._outputs.push(new mxnet.Parameter(f,[new mxnet.Argument("["+d.join(",")+"]",g,null)]))}const _={};for(const r of n.filter((l,d)=>!u[d]))this._nodes.push(new mxnet.Node(this._metadata,r,u,_,h));for(const r of Object.keys(u)){const l=u[r];if(l&&(!l.inputs||l.inputs.length==0)&&l.outputs&&l.outputs.length==1){const d=l.outputs[0],f=l.name;let g=null;const y=c[f];y&&y.data_shape&&(g=new mxnet.TensorType(-1,new mxnet.TensorShape(y.data_shape))),this._inputs.push(new mxnet.Parameter(f,[new mxnet.Argument("["+d.join(",")+"]",g)]))}}}else if(o){let n=null;const c=[];let i=Object.keys(o).every(p=>p.indexOf("_")!=-1)?"_":"";if(i.length==0&&(i=Object.keys(o).every(p=>p.indexOf(".")!=-1)?".":""),!(i.length>0))throw new mxnet.Error("Unsupported key format in params.");{const p={};for(const u of Object.keys(o)){const _=u.split(i);let r=_.pop();(u.endsWith("moving_mean")||u.endsWith("moving_var"))&&(r=[_.pop(),r].join(i));const l=_.join(i);n=p[l],n||(n={name:l,op:"Weights",params:[]},p[l]=n,c.push(n)),p[l].params.push({name:r,id:u})}}for(n of c)this._nodes.push(new mxnet.Node(t,n,{},{},o))}}get name(){return""}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}static _updateOutput(t,s){const e=s[0],a=t[e],o=s[1];if(a)for(;o>=a.outputs.length;)a.outputs.push([e,a.outputs.length]);return[e,o]}},mxnet.Parameter=class{constructor(t,s){this._name=t,this._arguments=s}get name(){return this._name}get visible(){return!0}get arguments(){return this._arguments}},mxnet.Argument=class{constructor(t,s,e){if(typeof t!="string")throw new mxnet.Error("Invalid argument identifier '"+JSON.stringify(t)+"'.");this._name=t,this._type=s||null,this._initializer=e||null}get name(){return this._initializer?this._initializer.name:this._name}get type(){return this._initializer?this._initializer.type:this._type}get initializer(){return this._initializer}},mxnet.Node=class{constructor(t,s,e,a,o){this._metadata=t,this._type=s.op,this._name=s.name,this._attributes=[],this._inputs=[],this._outputs=[];const h=s.attrs||s.attr||s.param;if(h){this._type=="tvm_op"&&h.func_name&&(this._type=h.func_name);for(const i of Object.keys(h))this._type!="tvm_op"&&i!="func_name"&&this._attributes.push(new mxnet.Attribute(this._metadata,this.type,i,h[i]))}let n=null;const c=t.type(this.type);if(s.inputs){let i=s.inputs;this._type=="RNN"&&(i=i.map(_=>{const r=_[0],l=e[r];return l&&l.op=="null"&&l.name&&l.name.endsWith("_parameters")&&l.attr&&l.attr.__init__?(this._attributes.push(new mxnet.Attribute(this._metadata,this.type,l.name,l.attr.__init__)),delete e[r],null):_}),i=i.filter(_=>_!=null));const p={};for(const _ of i){const r="["+_.join(",")+"]";if(n=a[r],!n){const l=_[0],d=e[l];if(d&&d.name&&(!d.inputs||d.inputs.length==0)&&d.outputs&&d.outputs.length==1)if(n=o.get(d.name)||null,n)delete e[l];else{let f=this._name;if(f.endsWith("_fwd")&&(f=f.slice(0,-3)),d.name&&(d.name.startsWith(f+"_")||d.name.startsWith(f+"."))){let g=-1,y=[];if(d.attrs&&d.attrs.__dtype__&&d.attrs.__shape__)try{g=parseInt(d.attrs.__dtype__),y=JSON.parse("["+d.attrs.__shape__.replace("(","").replace(")","").split(" ").join("").split(",").map(w=>w||'"?"').join(",")+"]")}catch(w){}let m=null;m=g!==-1||y.length>0?new mxnet.TensorType(g,new mxnet.TensorShape(y)):new mxnet.TensorType(-1,new mxnet.TensorShape(null)),n=new mxnet.Tensor("Initializer",d.name,m,null),delete e[l]}}}n&&(p[r]=n,a[r]=n)}let u=0;if(c&&c.inputs){for(const _ of c.inputs)if(u<i.length||_.option!="optional"){const r=_.option=="variadic"?i.length-u:1,l=[];for(const d of i.slice(u,u+r)){const f="["+d.join(",")+"]";f==""&&_.option=="optional"||l.push(new mxnet.Argument(f,_.type,p[f]))}this._inputs.push(new mxnet.Parameter(_.name,l)),u+=r}}u<i.length&&(this._inputs=this._inputs.concat(i.slice(u).map((_,r)=>{const l="["+_.join(",")+"]";return new mxnet.Parameter((u+r).toString(),[new mxnet.Argument(l,null,p[l])])})))}if(s.outputs){const i=s.outputs;let p=0;if(c&&c.outputs){for(const u of c.outputs)if(p<i.length||u.option!="optional"){const _=[],r=u.option=="variadic"?i.length-p:1;for(const l of i.slice(p,p+r))_.push(new mxnet.Argument("["+l.join(",")+"]",null,null));this._outputs.push(new mxnet.Parameter(u.name,_)),p+=r}}p<i.length&&(this._outputs=this._outputs.concat(i.slice(p).map((u,_)=>new mxnet.Parameter((p+_).toString(),[new mxnet.Argument("["+u.join(",")+"]",null,null)]))))}if(s.params)for(const i of s.params)this._inputs.push(new mxnet.Parameter(i.name,[new mxnet.Argument(i.id,null,o.get(i.id)||null)]))}get type(){return this._type}get metadata(){return this._metadata.type(this._type)}get name(){return this._name}get inputs(){return this._inputs}get outputs(){return this._outputs}get attributes(){return this._attributes}},mxnet.Attribute=class{constructor(t,s,e,a){let o;this._name=e,this._value=a;const h=t.attribute(s,e);if(h&&h.type)switch(h.type){case"boolean":switch(a){case"True":this._value=!0;break;case"False":this._value=!1}break;case"int32":o=Number.parseInt(this._value,10),this._value=Number.isNaN(this._value-o)?a:o;break;case"float32":case"float64":o=Number.parseFloat(this._value),this._value=Number.isNaN(this._value-o)?a:o;break;case"int32[]":if(this._value.length>2&&this._value.startsWith("(")&&this._value.endsWith(")")){let n=[];const c=this._value.substring(1,this._value.length-1).split(",").map(i=>i.trim()).map(i=>i.endsWith("L")?i.substring(0,i.length-1):i);for(const i of c)o=Number.parseInt(i,10),Number.isNaN(i-o)?n=null:n!=null&&n.push(o);n!=null&&(this._value=n)}}if(h){if(Object.prototype.hasOwnProperty.call(h,"visible")&&!h.visible)this._visible=!1;else if(Object.prototype.hasOwnProperty.call(h,"default")){let n=h.default;if(this._value==n)this._visible=!1;else if(Array.isArray(this._value)&&Array.isArray(n)){if(n=n.slice(0,n.length),n.length>1&&n[n.length-1]==null)for(n.pop();n.length<this._value.length;)n.push(n[n.length-1]);this._value.every((c,i)=>c==n[i])&&(this._visible=!1)}}}}get name(){return this._name}get type(){return this._type}get value(){return this._value}get visible(){return this._visible!=0}},mxnet.Tensor=class{constructor(t,s,e,a){this._kind=t,this._name=s,this._type=e,this._data=a}get kind(){return"Initializer"}get name(){return this._name}get type(){return this._type}get state(){return this._context().state}get value(){const t=this._context();return t.state?null:(t.limit=Number.MAX_SAFE_INTEGER,this._decode(t,0))}toString(){const t=this._context();if(t.state)return"";t.limit=1e4;const s=this._decode(t,0);return JSON.stringify(s,null,4)}_context(){const t={state:null,index:0,count:0};return this._data?this._type||this._type.dataType!=="?"?this._type.shape.length<1?(t.state="Tensor has unknown shape.",t):(t.dataType=this._type.dataType,t.dimensions=this._type.shape.dimensions,t.data=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength),t):(t.state="Tensor has no data type.",t):(t.state="Tensor data is empty.",t)}_decode(t,s){const e=[],a=t.dimensions[s];if(s==t.dimensions.length-1)for(let o=0;o<a;o++){if(t.count>t.limit)return e.push("..."),e;switch(t.dataType){case"float32":e.push(t.data.getFloat32(t.index,!0)),t.index+=4,t.count++;break;case"float64":e.push(t.data.getFloat64(t.index,!0)),t.index+=8,t.count++;break;case"float16":e.push(mxnet.Tensor._decodeNumberFromFloat16(t.data.getUint16(t.index,!0))),t.index+=2,t.count++;break;case"uint8":e.push(t.data.getUint8(t.index,!0)),t.index+=1,t.count++;break;case"int32":e.push(t.data.getInt32(t.index,!0)),t.index+=4,t.count++;break;case"int8":e.push(t.data.getInt8(t.index,!0)),t.index+=1,t.count++;break;case"int64":e.push(new long.Long(t.data.getUint32(t.index,!0),t.data.getUint32(t.index+4,!0),!1)),t.index+=8,t.count++}}else for(let o=0;o<a;o++){if(t.count>t.limit)return e.push("..."),e;e.push(this._decode(t,s+1))}return e}static _decodeNumberFromFloat16(t){const s=(32768&t)>>15,e=(31744&t)>>10,a=1023&t;return e==0?(s?-1:1)*Math.pow(2,-14)*(a/Math.pow(2,10)):e==31?a?NaN:1/0*(s?-1:1):(s?-1:1)*Math.pow(2,e-15)*(1+a/Math.pow(2,10))}},mxnet.TensorType=class{constructor(t,s){switch(t){case 0:this._dataType="float32";break;case 1:this._dataType="float64";break;case 2:this._dataType="float16";break;case 3:this._dataType="uint8";break;case 4:this._dataType="int32";break;case 5:this._dataType="int8";break;case 6:this._dataType="int64";break;case-1:this._dataType="?";break;default:throw new mxnet.Error("Unknown type '"+t+"'.")}this._shape=s}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return this._dataType+this._shape.toString()}},mxnet.TensorShape=class{constructor(t){this._dimensions=t}get dimensions(){return this._dimensions}toString(){return this._dimensions?this._dimensions.length==0?"":"["+this._dimensions.map(t=>t.toString()).join(",")+"]":""}},mxnet.Metadata=class{static open(t){return mxnet.Metadata._metadata?Promise.resolve(mxnet.Metadata._metadata):t.request(null,"mxnet-metadata.json","utf-8").then(s=>(mxnet.Metadata._metadata=new mxnet.Metadata(s),mxnet.Metadata._metadata)).catch(()=>(mxnet.Metadata._metadata=new mxnet.Metadata(null),mxnet.Metadata._metadata))}constructor(t){if(this._map={},this._attributeCache={},t){const s=JSON.parse(t);if(s)for(const e of s)e.name&&e.schema&&(e.schema.name=e.name,this._map[e.name]=e.schema)}}type(t){return this._map[t]||null}attribute(t,s){let e=this._attributeCache[t];if(!e){e={};const a=this.type(t);if(a&&a.attributes)for(const o of a.attributes)e[o.name]=o;this._attributeCache[t]=e}return e[s]||null}},mxnet.Error=class extends Error{constructor(t){super(t),this.name="Error loading MXNet model."}},ndarray.Stream=class{constructor(t){this._arrays={};const s=new ndarray.Reader(t);if(!s.checkSignature([18,1,0,0,0,0,0,0]))throw new ndarray.Error("Invalid signature.");if(!s.checkSignature([0,0,0,0,0,0,0,0]))throw new ndarray.Error("Invalid reserved block.");const e=[];for(let h=s.uint64();h>0;h--)e.push(new ndarray.Array(s));const a=new TextDecoder("ascii"),o=[];for(let h=s.uint64();h>0;h--){const n=a.decode(s.read(s.uint64()));o.push(n)}if(o.length!=e.length)throw new ndarray.Error("Label count mismatch.");for(let h=0;h<o.length;h++)this._arrays[o[h]]=e[h]}get arrays(){return this._arrays}},ndarray.Array=class{constructor(t){ndarray.Array._dataTypeSizeTable=[4,8,2,1,4,1,8],t.checkSignature([201,250,147,249])?this._loadV2(t):t.checkSignature([200,250,147,249])?this._loadV1(t):this._loadV0(t)}_loadV2(t){let s=0;switch(t.uint32()){case 0:s=0;break;case 1:s=1;break;case 2:s=2}if(this.sshape=null,s>0&&(this.sshape=new ndarray.Shape(t,!0)),this._shape=new ndarray.Shape(t,!0),this._shape.dimensions.length==0)return;if(this._context=new ndarray.Context(t),this._dataType=t.uint32(),s>0)throw new ndarray.Error("Not implemented.");const e=(this._dataType<ndarray.Array._dataTypeSizeTable.length?ndarray.Array._dataTypeSizeTable[this._dataType]:0)*this._shape.size();this._data=t.read(e)}_loadV1(t){if(this._shape=new ndarray.Shape(t,!0),this._shape.dimensions.length==0)return;this._context=new ndarray.Context(t),this._dataType=t.uint32();const s=(this._dataType<ndarray.Array._dataTypeSizeTable.length?ndarray.Array._dataTypeSizeTable[this._dataType]:0)*this._shape.size();this._data=t.read(s)}_loadV0(t){this._shape=new ndarray.Shape(t,!1),this._context=new ndarray.Context(t),this._dataType=t.uint32();const s=(this._dataType<ndarray.Array._dataTypeSizeTable.length?ndarray.Array._dataTypeSizeTable[this._dataType]:0)*this._shape.size();this._data=t.read(s)}get dataType(){return this._dataType}get shape(){return this._shape}get data(){return this._data}},ndarray.Shape=class{constructor(t,s){const e=t.uint32();this._dimensions=[];for(let a=0;a<e;a++)this._dimensions.push(s?t.uint64():t.uint32())}get dimensions(){return this._dimensions}size(){return this._dimensions.reduce((t,s)=>t*s)}},ndarray.Context=class{constructor(t){this._deviceType=t.uint32(),this._deviceId=t.uint32()}},ndarray.Reader=class{constructor(t){this._buffer=t,this._position=0,this._end=t.length}checkSignature(t){if(this._position+t.length<=this._end){for(let s=0;s<t.length;s++)if(this._buffer[this._position+s]!=t[s])return!1}return this._position+=t.length,!0}read(t){if(this._position+t>this._end)throw new ndarray.Error("Data not available.");const s=this._buffer.subarray(this._position,this._position+t);return this._position+=t,s}uint16(){if(this._position+2>this._end)throw new ndarray.Error("Data not available.");const t=this._buffer[this._position]|this._buffer[this._position+1]<<8;return this._position+=2,t}uint32(){return this.uint16()|this.uint16()<<16}uint64(){const t=this.uint32();if(this.uint32()!=0)throw new ndarray.Error("Large int64 value.");return t}},ndarray.Error=class extends Error{constructor(t){super(t),this.name="NDArray Error"}},typeof module!="undefined"&&typeof module.exports=="object"&&(module.exports.ModelFactory=mxnet.ModelFactory);
