var paddle=paddle||{},base=base||require("./base"),long=long||{Long:require("long")},protobuf=protobuf||require("./protobuf");paddle.ModelFactory=class{match(t){const e=t.identifier,r=e.split(".").pop().toLowerCase();return e==="__model__"||r==="paddle"||r==="pdmodel"}open(t,e){return e.require("./paddle-proto").then(()=>{let r=null;const s=t.identifier;try{paddle.proto=protobuf.get("paddle").paddle.framework.proto;const i=protobuf.Reader.create(t.buffer);r=paddle.proto.ProgramDesc.decode(i)}catch(i){throw new paddle.Error("File format is not paddle.ProgramDesc ("+i.message+") in '"+s+"'.")}return paddle.Metadata.open(e).then(i=>{try{const p=new Set;for(const a of r.blocks){const o=new Set;for(const n of a.vars)n.persistable&&n.type&&n.type.type!=paddle.proto.VarType.Type.FETCH_LIST&&n.type.type!=paddle.proto.VarType.Type.FEED_MINIBATCH&&o.add(n.name);for(const n of a.ops)for(const u of n.inputs)for(const l of u.arguments)o.has(l)&&p.add(l)}const h=Array.from(p).map(a=>t.request(a,null));return Promise.all(h).then(a=>{const o=new Map,n=Array.from(p);for(let u=0;u<n.length;u++)o.set(n[u],a[u]);return new paddle.Model(i,r,o)}).catch(a=>new paddle.Model(i,r,new Map))}catch(p){throw e.exception(p,!1),new paddle.Error(p.message)}})})}},paddle.Model=class{constructor(t,e,r){this._graphs=e.blocks.map(s=>new paddle.Graph(t,s,r))}get graphs(){return this._graphs}get format(){return"PaddlePaddle"}},paddle.Graph=class{constructor(t,e,r){this._nodes=[],this._inputs=[],this._outputs=[],this._name=`blocks[${e.idx}]`;const s=new Map;for(const a of e.vars){const o=a.type&&a.type.type&&a.type.lod_tensor&&a.type.lod_tensor.tensor?new paddle.TensorType(a.type.lod_tensor.tensor):null,n=a.persistable&&a.type&&a.type.type!=paddle.proto.VarType.Type.FETCH_LIST&&a.type.type!=paddle.proto.VarType.Type.FEED_MINIBATCH?new paddle.Tensor(o,r.get(a.name)):null;s.set(a.name,new paddle.Argument(a.name,o,n))}const i={};for(let a=0;a<e.ops.length;a++){for(const o of e.ops[a].inputs)o.arguments=o.arguments.map(n=>i[n]?i[n]:n);for(const o of e.ops[a].outputs)o.arguments=o.arguments.map(n=>{if(i[n]){const u=n+`
`+a.toString();return i[n]=u,u}return i[n]=n,n})}for(const a of e.ops){for(const o of a.inputs)for(const n of o.arguments){const u=n;s.has(u)||s.set(u,new paddle.Argument(u,null,null))}for(const o of a.outputs)for(const n of o.arguments){const u=n;s.has(u)||s.set(u,new paddle.Argument(u,null,null))}}let p=null,h=null;for(const a of e.ops)if(a.type=="feed"){const o=a.attrs.filter(n=>n.name=="col")[0].i.toString();this._inputs.push(new paddle.Parameter(o,a.outputs[0].arguments.map(n=>s.get(n))))}else if(a.type=="fetch"){const o=a.attrs.filter(n=>n.name=="col")[0].i.toString();this._outputs.push(new paddle.Parameter(o,a.inputs[0].arguments.map(n=>s.get(n))))}else{const o=new paddle.Node(t,a,s);a.inputs.length==1&&a.inputs[0].arguments.length==1&&a.outputs.length>=1&&a.outputs[0].arguments.length==1&&a.inputs[0].arguments[0].split(`
`).shift()==a.outputs[0].arguments[0].split(`
`).shift()&&p&&h==a.inputs[0].arguments[0].split(`
`).shift()?p.chain.push(o):(this._nodes.push(o),p=null,h=null,a.outputs.length==1&&a.outputs[0].arguments.length==1&&(p=o,h=a.outputs[0].arguments[0].split(`
`).shift()))}}get name(){return this._name}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}},paddle.Parameter=class{constructor(t,e){this._name=t,this._arguments=e}get name(){return this._name}get visible(){return!0}get arguments(){return this._arguments}},paddle.Argument=class{constructor(t,e,r){if(typeof t!="string")throw new paddle.Error("Invalid argument identifier '"+JSON.stringify(t)+"'.");this._name=t,this._type=e||null,this._initializer=r||null}get name(){return this._name}get type(){return this._type?this._type:this._initializer?this._initializer.type:null}get initializer(){return this._initializer}},paddle.Node=class{constructor(t,e,r){this._metadata=t,this._type=e.type,this._attributes=[],this._inputs=[],this._outputs=[],this._chain=[];for(const s of e.attrs){const i=t.attribute(this._type,this._name);this._attributes.push(new paddle.Attribute(i,s))}for(const s of e.inputs)s.arguments.length>0&&this._inputs.push(new paddle.Parameter(s.parameter,s.arguments.map(i=>r.get(i))));for(const s of e.outputs)s.arguments.length>0&&this._outputs.push(new paddle.Parameter(s.parameter,s.arguments.map(i=>r.get(i))));this._update(this._inputs,"X"),this._update(this._inputs,"Input"),this._update(this._outputs,"Y"),this._update(this._outputs,"Out")}get type(){return this._type}get name(){return""}get metadata(){return this._metadata.type(this._type)}get attributes(){return this._attributes}get inputs(){return this._inputs}get outputs(){return this._outputs}get chain(){return this._chain}_update(t,e){let r=null;for(let s=0;s<t.length;s++)if(t[s].name==e){r=t[s],t.splice(s,1);break}r&&t.splice(0,0,r)}},paddle.Attribute=class{constructor(t,e){switch(this._name=e.name,this._value="?",e.type){case paddle.proto.AttrType.STRING:this._type="string",this._value=e.s;break;case paddle.proto.AttrType.STRINGS:this._type="string[]",this._value=e.strings;break;case paddle.proto.AttrType.BOOLEAN:this._type="boolean",this._value=e.b;break;case paddle.proto.AttrType.BOOLEANS:this._type="boolean[]",this._value=e.bools;break;case paddle.proto.AttrType.FLOAT:this._type="float32",this._value=e.f;break;case paddle.proto.AttrType.FLOATS:this._type="float[]",this._value=e.floats;break;case paddle.proto.AttrType.INT:this._type="int32",this._value=e.i;break;case paddle.proto.AttrType.INTS:this._type="int32[]",this._value=e.ints;break;case paddle.proto.AttrType.LONG:this._type="int64";break;case paddle.proto.AttrType.LONGS:this._type="int64[]"}switch(this._name){case"use_mkldnn":case"use_cudnn":case"op_callstack":case"op_role":case"op_role_var":case"op_namescope":case"is_test":this._visible=!1}if(t&&Object.prototype.hasOwnProperty.call(t,"default")){const r=t.default,s=this._value;(r==s||Array.isArray(s)&&Array.isArray(r)&&s.length==r.length&&s.every((i,p)=>i==r[p]))&&(this._visible=!1)}}get name(){return this._name}get type(){return this._type}get value(){return this._value}get visible(){return this._visible!=0}},paddle.Tensor=class{constructor(t,e){if(this._type=t,e&&e.length>20&&e.slice(0,16).every(r=>r===0)){const r=new DataView(e.buffer,e.byteOffset,e.byteLength).getUint32(16,!0);this._data=e.slice(20+r)}}get type(){return this._type}get state(){return this._context().state||null}get value(){const t=this._context();return t.state?null:(t.limit=Number.MAX_SAFE_INTEGER,this._decode(t,0))}toString(){const t=this._context();if(t.state)return"";t.limit=1e4;const e=this._decode(t,0);return paddle.Tensor._stringify(e,"","    ")}_context(){const t={index:0,count:0,state:null};if(!this._data)return t.state="Tensor data is empty.",t;if(!this._type)return t.state="Tensor has no data type.",t;switch(t.dataType=this._type.dataType,t.shape=this._type.shape.dimensions,t.view=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength),t.dataType){case"float32":case"int32":case"int64":break;default:t.state="Tensor data type '"+t.dataType+"' is not implemented."}return t}_decode(t,e){const r=t.shape.length!==0?t.shape:[1],s=[],i=r[e];if(e==r.length-1)for(let p=0;p<i;p++){if(t.count>t.limit)return s.push("..."),s;switch(t.dataType){case"float32":s.push(t.view.getFloat32(t.index,!0)),t.index+=4,t.count++;break;case"int32":s.push(t.view.getInt32(t.index,!0)),t.index+=4,t.count++;break;case"int64":s.push(new long.Long(t.data.getUint32(t.index,!0),t.data.getUint32(t.index+4,!0),!1)),t.index+=8,t.count++}}else for(let p=0;p<i;p++){if(t.count>t.limit)return s.push("..."),s;s.push(this._decode(t,e+1))}return t.shape.length==0?s[0]:s}static _stringify(t,e,r){if(Array.isArray(t)){const s=[];s.push(e+"[");const i=t.map(p=>paddle.Tensor._stringify(p,e+r,r));return i.length>0&&s.push(i.join(`,
`)),s.push(e+"]"),s.join(`
`)}return typeof t=="string"?e+t:t==1/0?e+"Infinity":t==-1/0?e+"-Infinity":isNaN(t)?e+"NaN":e+t.toString()}},paddle.TensorType=class{constructor(t){switch(t.data_type){case paddle.proto.VarType.Type.INT32:this._dataType="int32";break;case paddle.proto.VarType.Type.INT64:this._dataType="int64";break;case paddle.proto.VarType.Type.FP32:this._dataType="float32";break;case paddle.proto.VarType.Type.FP64:this._dataType="float64";break;default:this._dataType="?"}this._shape=new paddle.TensorShape(t.dims)}get dataType(){return this._dataType}get shape(){return this._shape}get denotation(){return this._denotation}toString(){return this.dataType+this._shape.toString()}},paddle.TensorShape=class{constructor(t){t=t.map(e=>e.toNumber()),this._dimensions=t.map(e=>e!=-1?e:"?")}get dimensions(){return this._dimensions}toString(){return this._dimensions&&this._dimensions.length?"["+this._dimensions.join(",")+"]":""}},paddle.Metadata=class{static open(t){return paddle.Metadata._metadata?Promise.resolve(paddle.Metadata._metadata):t.request(null,"paddle-metadata.json","utf-8").then(e=>(paddle.Metadata._metadata=new paddle.Metadata(e),paddle.Metadata._metadata)).catch(()=>(paddle.Metadata._metadata=new paddle.Metadata(null),paddle.Metadata._metadata))}constructor(t){if(this._map={},this._attributeCache={},t){const e=JSON.parse(t);if(e)for(const r of e)r.schema.name=r.name,this._map[r.name]=r.schema}}type(t){return this._map[t]||null}attribute(t,e){let r=this._attributeCache[t];if(!r){r={};const s=this.type(t);if(s&&s.attributes&&s.attributes.length>0)for(const i of s.attributes)r[i.name]=i;this._attributeCache[t]=r}return r[e]||null}},paddle.Error=class extends Error{constructor(t){super(t),this.name="Error loading PaddlePaddle model."}},typeof module!="undefined"&&typeof module.exports=="object"&&(module.exports.ModelFactory=paddle.ModelFactory);
