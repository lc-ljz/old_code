var numpy=numpy||{};numpy.Array=class{constructor(e){if(e){const t=new numpy.Reader(e),s=[147,78,85,77,80,89];if(!t.bytes(6).every((n,o)=>n==s[o]))throw new numpy.Error("Invalid signature.");const a=t.byte(),i=t.byte();if(a!==1&&i!==0)throw new numpy.Error("Invalid version '"+[a,i].join(".")+"'.");const r=JSON.parse(t.string().trim().replace(/'/g,'"').replace("False","false").replace("(","[").replace(/,*\),*/g,"]"));if(r.fortran_order)throw new numpy.Error("Fortran order is not supported.'");if(!r.descr||r.descr.length<2)throw new numpy.Error("Missing property 'descr'.");if(!r.shape)throw new numpy.Error("Missing property 'shape'.");switch(this._shape=r.shape,this._byteOrder=r.descr[0],this._byteOrder){case"|":this._dataType=r.descr.substring(1),this._data=t.bytes(t.size-t.position);break;case">":case"<":{if(r.descr.length!==3)throw new numpy.Error("Unsupported data type '"+r.descr+"'.");this._dataType=r.descr.substring(1);const n=parseInt(r.descr[2],10)*this._shape.reduce((o,h)=>o*h,1);this._data=t.bytes(n);break}default:throw new numpy.Error("Unsupported data type '"+r.descr+"'.")}}}get data(){return this._data}set data(e){this._data=e}get dataType(){return this._dataType}set dataType(e){this._dataType=e}get shape(){return this._shape}set shape(e){this._shape=e}get byteOrder(){return this._byteOrder}set byteOrder(e){this._byteOrder=e}toBuffer(){const e=new numpy.Writer;e.bytes([147,78,85,77,80,89]),e.byte(1),e.byte(0);const t={itemSize:1,position:0,dataType:this._dataType,byteOrder:this._byteOrder||"<",shape:this._shape,descr:""};if(t.byteOrder!=="<"&&t.byteOrder!==">")throw new numpy.Error("Unknown byte order '"+this._byteOrder+"'.");if(t.dataType.length!==2||t.dataType[0]!=="f"&&t.dataType[0]!=="i"&&t.dataType[0]!=="u")throw new numpy.Error("Unsupported data type '"+this._dataType+"'.");t.itemSize=parseInt(t.dataType[1],10);let s="";switch(this._shape.length){case 0:throw new numpy.Error("Invalid shape.");case 1:s="("+this._shape[0].toString()+",)";break;default:s="("+this._shape.map(r=>r.toString()).join(", ")+")"}let a="{ "+["'descr': '"+t.byteOrder+t.dataType+"'","'fortran_order': False","'shape': "+s].join(", ")+" }";a+=" ".repeat(16-(a.length+2+8+1&15))+`
`,e.string(a);const i=t.itemSize*this._shape.reduce((r,n)=>r*n);return t.data=new Uint8Array(i),t.dataView=new DataView(t.data.buffer,t.data.byteOffset,i),numpy.Array._encodeDimension(t,this._data,0),e.bytes(t.data),e.toBuffer()}static _encodeDimension(e,t,s){const a=e.shape[s],i=e.byteOrder==="<";if(s==e.shape.length-1)for(let r=0;r<a;r++){switch(e.dataType){case"f2":e.dataView.setFloat16(e.position,t[r],i);break;case"f4":e.dataView.setFloat32(e.position,t[r],i);break;case"f8":e.dataView.setFloat64(e.position,t[r],i);break;case"i1":e.dataView.setInt8(e.position,t[r],i);break;case"i2":e.dataView.setInt16(e.position,t[r],i);break;case"i4":e.dataView.setInt32(e.position,t[r],i);break;case"i8":e.data.set(t[r].toBytes(i),e.position);break;case"u1":e.dataView.setUint8(e.position,t[r],i);break;case"u2":e.dataView.setUint16(e.position,t[r],i);break;case"u4":e.dataView.setUint32(e.position,t[r],i);break;case"u8":e.data.set(t[r].toBytes(i),e.position)}e.position+=e.itemSize}else for(let r=0;r<a;r++)numpy.Array._encodeDimension(e,t[r],s+1)}},numpy.Reader=class{constructor(e){this._buffer=e,this._position=0}get position(){return this._position}get size(){return this._buffer.length}byte(){return this._buffer[this._position++]}bytes(e){const t=this._buffer.slice(this._position,this._position+e);return this._position+=e,t}uint16(){return this.byte()|this.byte()<<8}string(){const e=this.uint16();let t="";for(let s=0;s<e;s++)t+=String.fromCharCode(this.byte());return t}},numpy.Writer=class{constructor(){this._length=0,this._head=null,this._tail=null}byte(e){this.bytes([e])}uint16(e){this.bytes([255&e,e>>8&255])}bytes(e){const t=new Uint8Array(e.length);for(let s=0;s<e.length;s++)t[s]=e[s];this._write(t)}string(e){this.uint16(e.length);const t=new Uint8Array(e.length);for(let s=0;s<e.length;s++)t[s]=e.charCodeAt(s);this._write(t)}_write(e){const t={buffer:e,next:null};this._tail?this._tail.next=t:this._head=t,this._tail=t,this._length+=t.buffer.length}toBuffer(){const e=new Uint8Array(this._length);let t=0,s=this._head;for(;s!=null;)e.set(s.buffer,t),t+=s.buffer.length,s=s.next;return e}},numpy.Error=class extends Error{constructor(e){super(e),this.name="NumPy Error"}},typeof module!="undefined"&&typeof module.exports=="object"&&(module.exports.Array=numpy.Array);
