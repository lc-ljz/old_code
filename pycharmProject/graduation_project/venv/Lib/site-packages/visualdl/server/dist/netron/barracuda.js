var barracuda=barracuda||{},base=base||require("./base"),long=long||{Long:require("long")};barracuda.ModelFactory=class{match(t){if(t.identifier.split(".").pop().toLowerCase()==="nn"){const e=t.buffer;if(e.length>12&&e[0]<=16&&e.subarray(1,8).every(s=>s==0))return!0}return!1}open(t){return barracuda.Metadata.open().then(e=>{try{const s=new barracuda.NNModel(t.buffer);return new barracuda.Model(e,s)}catch(s){const r=t.identifier.toLowerCase(),a=s&&s.message?s.message:s.toString();throw new barracuda.Error(a.replace(/\.$/,"")+" in '"+r+"'.")}})}},barracuda.Model=class{constructor(t,e){this._version=e.version.toString(),this._graphs=[new barracuda.Graph(t,e)]}get format(){return"Barracuda v"+this._version}get graphs(){return this._graphs}},barracuda.Graph=class{constructor(t,e){this._inputs=[],this._outputs=[],this._nodes=[];for(const a of e.inputs)this._inputs.push(new barracuda.Parameter(a.name,[new barracuda.Argument(a.name,new barracuda.TensorType(4,new barracuda.TensorShape(a.shape)))]));for(const a of e.outputs)this._outputs.push(new barracuda.Parameter(a,[new barracuda.Argument(a)]));const s=[],r=new Map;for(const a of e.layers)if(a.type!==255||a.inputs.length>0)s.push(a);else for(const i of a.tensors)r.set(i.name,new barracuda.Tensor(i));for(const a of s)this._nodes.push(new barracuda.Node(t,a,r))}get name(){return""}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}},barracuda.Parameter=class{constructor(t,e){this._name=t,this._arguments=e}get name(){return this._name}get visible(){return!0}get arguments(){return this._arguments}},barracuda.Argument=class{constructor(t,e,s){this._name=t,this._type=e||null,this._initializer=s||null}get name(){return this._name}get type(){return this._type}get initializer(){return this._initializer}},barracuda.Node=class{constructor(t,e,s){this._name=e.name||"",this._metadata=t.type(e.type)||{name:e.type.toString()},this._type=this._metadata.name,this._inputs=[],this._outputs=[],this._attributes=[];const r=Array.prototype.slice.call(this._metadata.inputs||["input"]);if(this._metadata.inputs&&this._metadata.inputs.length===1&&this._metadata.inputs[0]==="inputs")this._inputs.push(new barracuda.Parameter("inputs",e.inputs.map(i=>{const n=s.has(i)?s.get(i):null;return new barracuda.Argument(i,n?n.type:null,n)})));else if(e.inputs)for(let i=0;i<e.inputs.length;i++){const n=e.inputs[i],o=s.has(n)?s.get(n):null;this._inputs.push(new barracuda.Parameter(r.length>0?r.shift():i.toString(),[new barracuda.Argument(n,o?o.type:null,o)]))}if(e.tensors)for(let i=0;i<e.tensors.length;i++){const n=e.tensors[i],o=new barracuda.Tensor(n);this._inputs.push(new barracuda.Parameter(r.length>0?r.shift():i.toString(),[new barracuda.Argument(n.name,o.type,o)]))}if(e.inputs!==void 0&&this._outputs.push(new barracuda.Parameter("output",[new barracuda.Argument(this._name)])),!barracuda.Activation[e.activation])throw new barracuda.Error("Unknown activation '"+e.activation+"'.");this._type==="Activation"?this._type=barracuda.Activation[e.activation]:e.activation!==0&&(this._chain=[new barracuda.Node(t,{type:50,activation:e.activation},s)]);const a=(i,n,o,h)=>{o!==void 0&&(Array.isArray(h)&&Array.isArray(o)&&o.length==h.length&&o.every((u,p)=>u===h[p])||typeof h=="function"&&h(o)||h!==o&&this._attributes.push(new barracuda.Attribute(i,n,o)))};a("strides","int32[]",e.strides,[]),a("pads","int32[]",e.pads,i=>Array.isArray(i)&&(i.every(n=>n===0)||i.every(n=>n===-1))),a("size","int32[]",e.pool_size,[]),a("alpha","float32",e.alpha,1),a("beta","float32",e.beta,0),a("axis","int32",e.axis,-1)}get type(){return this._type}get name(){return this._name}get metadata(){return this._metadata}get attributes(){return this._attributes}get inputs(){return this._inputs}get outputs(){return this._outputs}get chain(){return this._chain}},barracuda.Attribute=class{constructor(t,e,s){this._name=t,this._type=e,this._value=s}get type(){return this._type}get name(){return this._name}get value(){return this._value}get visible(){return!0}},barracuda.Tensor=class{constructor(t){this._type=new barracuda.TensorType(t.itemsize,new barracuda.TensorShape(t.shape)),this._data=t.data}get kind(){return""}get type(){return this._type}get state(){return this._context().state||null}get value(){const t=this._context();return t.state?null:(t.limit=Number.MAX_SAFE_INTEGER,this._decode(t,0))}toString(){const t=this._context();if(t.state)return"";t.limit=1e4;const e=this._decode(t,0);return JSON.stringify(e,null,4)}_context(){const t={index:0,count:0,state:null};if(this._type.dataType=="?")return t.state="Tensor has unknown data type.",t;if(!this._type.shape||this._type.shape.dimensions&&this._type.shape.dimensions.length==0)return t.state="Tensor has no dimensions.",t;if(!this._data)return t.state="Tensor data is empty.",t;switch(this._type.dataType){case"float32":t.data=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength);break;default:t.state="Tensor data type is not implemented."}return t.dataType=this._type.dataType,t.shape=this._type.shape.dimensions,t}_decode(t,e){const s=t.shape.length==0?[1]:t.shape,r=[],a=s[e];if(e==s.length-1)for(let i=0;i<a;i++){if(t.count>t.limit)return r.push("..."),r;switch(this._type.dataType){case"float32":r.push(t.data.getFloat32(t.index,!0)),t.index+=4,t.count++}}else for(let i=0;i<a;i++){if(t.count>t.limit)return r.push("..."),r;r.push(this._decode(t,e+1))}return t.shape.length==0?r[0]:r}},barracuda.TensorType=class{constructor(t,e){switch(t){case 4:this._dataType="float32";break;default:throw new barracuda.Error("Unsupported data type size '"+t.toString()+"'.")}this._shape=e}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return this._dataType+this._shape.toString()}},barracuda.TensorShape=class{constructor(t){this._dimensions=t}get dimensions(){return this._dimensions}toString(){return this._dimensions?"["+this._dimensions.map(t=>t?t.toString():"?").join(",")+"]":""}},barracuda.NNModel=class{constructor(t){const e=new barracuda.BinaryReader(t);this._version=e.int32(),e.int32(),this._inputs=[];const s=e.int32();for(let i=0;i<s;i++)this._inputs.push({name:e.string(),shape:e.shape()});this._outputs=e.strings(),this._memories=[];const r=e.int32();for(let i=0;i<r;i++)this._memories.push({shape:e.shape(),in:e.string(),out:e.string()});this._layers=[];const a=e.int32();for(let i=0;i<a;i++){const n={};n.name=e.string(),n.type=e.int32(),n.activation=e.int32(),e.int32(),e.int32(),n.pads=e.int32s(),n.strides=e.int32s(),n.pool_size=e.int32s(),n.axis=e.int32(),n.alpha=e.float32(),n.beta=e.float32(),e.int32(),n.inputs=e.strings(),n.tensors=[];const o=e.int32();for(let h=0;h<o;h++)n.tensors.push({name:e.string(),shape:e.shape(),offset:e.int64(),itemsize:e.int32(),length:e.int32()});this._layers.push(n)}for(const i of this._layers)for(const n of i.tensors)n.data=e.bytes(n.offset*n.itemsize,n.length*n.itemsize)}get version(){return this._version}get inputs(){return this._inputs}get outputs(){return this._outputs}get memories(){return this._memories}get layers(){return this._layers}},barracuda.Activation={0:"Linear",1:"Relu",2:"Softmax",3:"Tanh",4:"Sigmoid",5:"Elu",6:"Relu6",7:"LeakyRelu",8:"Selu",9:"Swish",10:"LogSoftmax",11:"Softplus",12:"Softsign",100:"Abs",101:"Neg",102:"Ceil",104:"Floor",111:"Sqrt",113:"Exp",114:"Log",200:"Acos",201:"Acosh",202:"Asin",203:"Asinh",204:"Atan",205:"Atanh",206:"Cos",207:"Cosh",208:"Sin",209:"Sinh",210:"Tan"},barracuda.BinaryReader=class{constructor(t){this._buffer=t,this._dataView=new DataView(t.buffer,t.byteOffset,t.byteLength),this._position=0}skip(t){if(this._position+=t,this._position>this._buffer.length)throw new barracuda.Error("Expected "+(this._position-this._buffer.length)+" more bytes. The file might be corrupted. Unexpected end of file.")}bytes(t,e){const s=this._position+t,r=s+e;if(r>this._buffer.length)throw new barracuda.Error("Expected "+(r-this._buffer.length)+" more bytes. The file might be corrupted. Unexpected end of file.");return this._buffer.slice(s,r)}int32(){const t=this._position;return this.skip(4),this._dataView.getInt32(t,!0)}int32s(){const t=[],e=this.int32();for(let s=0;s<e;s++)t.push(this.int32());return t}int64(){const t=this.int32();if(this.int32()!==0)throw new barracuda.Error("Invalid int64 value.");return t}float32(){const t=this._position;return this.skip(4),this._dataView.getFloat32(t,!0)}string(){let t="";const e=this.int32();let s=this._position;this.skip(e);for(let r=0;r<e;r++)t+=String.fromCharCode(this._buffer[s++]);return t}strings(){const t=[],e=this.int32();for(let s=0;s<e;s++)t.push(this.string());return t}shape(){return this.int32s()}},barracuda.Metadata=class{static open(){return barracuda.Metadata._metadata=barracuda.Metadata._metadata||new barracuda.Metadata,Promise.resolve(barracuda.Metadata._metadata)}constructor(){this._map=new Map,this._register(0,"Nop",""),this._register(1,"Dense","Layer",["input","kernel","bias"]),this._register(2,"MatMul","",["input","kernel","bias"]),this._register(20,"Conv2D","Layer",["input","kernel","bias"]),this._register(21,"DepthwiseConv2dNative","Layer",["input","kernel","bias"]),this._register(22,"Conv2DBackpropInput",""),this._register(23,"Upsample2D",""),this._register(25,"MaxPool","Pool"),this._register(26,"AvgPool","Pool"),this._register(28,"GlobalAvgPool","Pool"),this._register(29,"Pad",""),this._register(50,"Activation","Activation"),this._register(51,"ScaleBias","Normalization",["input","scale","bias"]),this._register(52,"InstanceNormalization","Normalization"),this._register(53,"LRN","Normalization"),this._register(64,"RandomStandardNormal",""),this._register(65,"RandomUniform",""),this._register(67,"OneHot",""),this._register(100,"Add","",["inputs"]),this._register(101,"Sub","",["inputs"]),this._register(102,"Mul","",["inputs"]),this._register(103,"RealDiv","",["inputs"]),this._register(104,"Pow","",["inputs"]),this._register(110,"Minimum","",["inputs"]),this._register(111,"Maximum","",["inputs"]),this._register(124,"Max","",["inputs"]),this._register(125,"Mean","",["inputs"]),this._register(126,"Min","",["inputs"]),this._register(127,"Prod","",["inputs"]),this._register(128,"Sum","",["inputs"]),this._register(200,"Flatten","Shape"),this._register(201,"Reshape","Shape"),this._register(210,"Concat","Tensor",["inputs"]),this._register(211,"StridedSlice","Shape")}_register(t,e,s,r){this._map.set(t,{name:e,category:s,inputs:r})}type(t){return this._map.has(t)?this._map.get(t):null}},barracuda.Error=class extends Error{constructor(t){super(t),this.name="Error loading Barracuda model."}},typeof module!="undefined"&&typeof module.exports=="object"&&(module.exports.ModelFactory=barracuda.ModelFactory);
