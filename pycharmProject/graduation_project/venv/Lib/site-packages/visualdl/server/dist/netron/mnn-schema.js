var $root=flatbuffers.get("mnn");$root.MNN=$root.MNN||{},$root.MNN.OpType={AbsVal:0,QuantizedAdd:1,ArgMax:2,AsString:3,InstanceNorm:4,BatchToSpaceND:5,Bias:6,BinaryOp:7,Bnll:8,Cast:9,Concat:10,Const:11,Convolution:12,ConvolutionDepthwise:13,Crop:14,CropAndResize:15,Cubic:16,Deconvolution:17,DeconvolutionDepthwise:18,Dequantize:19,DetectionOutput:20,Dropout:21,Eltwise:22,ELU:23,Embed:24,Exp:25,ExpandDims:26,Fill:27,Flatten:28,FloorMod:29,Gather:30,GatherV2:31,Im2Seq:32,InnerProduct:33,Input:34,Interp:35,Log:36,LRN:37,LSTM:38,MatMul:39,MVN:40,NonMaxSuppression:41,NonMaxSuppressionV2:42,Normalize:43,Pack:44,Padding:45,Permute:46,Pooling:47,Power:48,PReLU:49,PriorBox:50,Proposal:51,QuantizedAvgPool:52,QuantizedBiasAdd:53,QuantizedConcat:54,QuantizedDepthwiseConv2D:55,QuantizedLogistic:56,QuantizedMatMul:57,QuantizedMaxPool:58,QuantizedRelu:59,QuantizedRelu6:60,QuantizedReshape:61,QuantizedSoftmax:62,QuantizeMaxMin:63,QuantizeV2:64,Range:65,Rank:66,ReduceJoin:67,Reduction:68,ReLU:69,ReLU6:70,RequantizationRange:71,Requantize:72,Reshape:73,Resize:74,RNN:75,ROIPooling:76,Scale:77,Selu:78,Seq2Out:79,Shape:80,Sigmoid:81,Size:82,Slice:83,SliceTf:84,Softmax:85,SpaceToBatchND:86,SpatialProduct:87,Split:88,SPP:89,Squeeze:90,StridedSlice:91,StringJoin:92,StringSplit:93,StringToNumber:94,TanH:95,TfQuantizedConv2D:96,Threshold:97,Tile:98,TopKV2:99,Transpose:100,UnaryOp:101,Unpack:102,Where:103,Moments:104,RNNSequenceGRU:105,BatchMatMul:106,Unsqueeze:107,CosineSimilarity:108,DepthToSpace:109,SpaceToDepth:110,ReverseSequence:111,Pooling3D:112,Convolution3D:113,MatrixBandPart:114,GatherND:115,DetectionPostProcess:116,UnravelIndex:117,ScatterNd:118,OneHot:119,BroadcastTo:120,Dilation2D:121,MaxLayerCount:128,ConvertTensor:129,ArgMin:130,LinSpace:131,Plugin:256,Select:257,ZerosLike:258,Broastcast:259,SetDiff1D:260,ReluGrad:261,Relu6Grad:262,PoolGrad:263,SoftmaxGrad:264,Conv2DBackPropFilter:265,TrainableParam:266,BatchNorm:267,ZeroGrad:268,Extra:512,ConvInt8:513,Int8ToFloat:514,DepthwiseConvInt8:515,PoolInt8:516,FloatToInt8:517,EltwiseInt8:518},$root.MNN.Plugin=class{static decode(e,a){const t=new $root.MNN.Plugin;return t.type=e.string_(a,4,null),t.attr=e.tableArray(a,6,$root.MNN.Attribute.decode),t}},$root.MNN.Extra=class{static decode(e,a){const t=new $root.MNN.Extra;return t.type=e.string_(a,4,null),t.engine=e.string_(a,6,null),t.info=e.typedArray(a,8,Int8Array),t.attr=e.tableArray(a,10,$root.MNN.Attribute.decode),t}},$root.MNN.OpParameter=class{static decode(e,a,t){switch(t){case 1:return $root.MNN.QuantizedAdd.decode(e,a);case 2:return $root.MNN.ArgMax.decode(e,a);case 3:return $root.MNN.AsString.decode(e,a);case 4:return $root.MNN.Axis.decode(e,a);case 5:return $root.MNN.BatchNorm.decode(e,a);case 6:return $root.MNN.BinaryOp.decode(e,a);case 7:return $root.MNN.Blob.decode(e,a);case 8:return $root.MNN.CastParam.decode(e,a);case 9:return $root.MNN.Convolution2D.decode(e,a);case 10:return $root.MNN.Crop.decode(e,a);case 11:return $root.MNN.CropAndResize.decode(e,a);case 12:return $root.MNN.Dequantize.decode(e,a);case 13:return $root.MNN.DetectionOutput.decode(e,a);case 14:return $root.MNN.Eltwise.decode(e,a);case 15:return $root.MNN.ExpandDims.decode(e,a);case 16:return $root.MNN.Fill.decode(e,a);case 17:return $root.MNN.Flatten.decode(e,a);case 18:return $root.MNN.Gather.decode(e,a);case 19:return $root.MNN.GatherV2.decode(e,a);case 20:return $root.MNN.InnerProduct.decode(e,a);case 21:return $root.MNN.Input.decode(e,a);case 22:return $root.MNN.Interp.decode(e,a);case 23:return $root.MNN.LRN.decode(e,a);case 24:return $root.MNN.LSTM.decode(e,a);case 25:return $root.MNN.MatMul.decode(e,a);case 26:return $root.MNN.NonMaxSuppressionV2.decode(e,a);case 27:return $root.MNN.Normalize.decode(e,a);case 28:return $root.MNN.PackParam.decode(e,a);case 29:return $root.MNN.Permute.decode(e,a);case 30:return $root.MNN.Plugin.decode(e,a);case 31:return $root.MNN.Pool.decode(e,a);case 32:return $root.MNN.PRelu.decode(e,a);case 33:return $root.MNN.PriorBox.decode(e,a);case 34:return $root.MNN.Proposal.decode(e,a);case 35:return $root.MNN.QuantizedAvgPool.decode(e,a);case 36:return $root.MNN.QuantizedBiasAdd.decode(e,a);case 37:return $root.MNN.QuantizedConcat.decode(e,a);case 38:return $root.MNN.QuantizedLogistic.decode(e,a);case 39:return $root.MNN.QuantizedMatMul.decode(e,a);case 40:return $root.MNN.QuantizedMaxPool.decode(e,a);case 41:return $root.MNN.QuantizedRelu.decode(e,a);case 42:return $root.MNN.QuantizedRelu6.decode(e,a);case 43:return $root.MNN.QuantizedReshape.decode(e,a);case 44:return $root.MNN.QuantizedSoftmax.decode(e,a);case 45:return $root.MNN.QuantizeMaxMin.decode(e,a);case 46:return $root.MNN.QuantizeV2.decode(e,a);case 47:return $root.MNN.Range.decode(e,a);case 48:return $root.MNN.Rank.decode(e,a);case 49:return $root.MNN.ReduceJoin.decode(e,a);case 50:return $root.MNN.ReductionParam.decode(e,a);case 51:return $root.MNN.Relu.decode(e,a);case 52:return $root.MNN.Relu6.decode(e,a);case 53:return $root.MNN.RequantizationRange.decode(e,a);case 54:return $root.MNN.Requantize.decode(e,a);case 55:return $root.MNN.Reshape.decode(e,a);case 56:return $root.MNN.Resize.decode(e,a);case 57:return $root.MNN.RoiPooling.decode(e,a);case 58:return $root.MNN.Scale.decode(e,a);case 59:return $root.MNN.Selu.decode(e,a);case 60:return $root.MNN.Size.decode(e,a);case 61:return $root.MNN.Slice.decode(e,a);case 62:return $root.MNN.SliceTf.decode(e,a);case 63:return $root.MNN.SpaceBatch.decode(e,a);case 64:return $root.MNN.SqueezeParam.decode(e,a);case 65:return $root.MNN.StridedSliceParam.decode(e,a);case 66:return $root.MNN.TensorConvertInfo.decode(e,a);case 67:return $root.MNN.TfQuantizedConv2D.decode(e,a);case 68:return $root.MNN.TopKV2.decode(e,a);case 69:return $root.MNN.Transpose.decode(e,a);case 70:return $root.MNN.UnaryOp.decode(e,a);case 71:return $root.MNN.MomentsParam.decode(e,a);case 72:return $root.MNN.RNNParam.decode(e,a);case 73:return $root.MNN.BatchMatMulParam.decode(e,a);case 74:return $root.MNN.QuantizedFloatParam.decode(e,a);case 75:return $root.MNN.DepthSpaceParam.decode(e,a);case 76:return $root.MNN.EltwiseInt8.decode(e,a);case 77:return $root.MNN.ReverseSequenceParam.decode(e,a);case 78:return $root.MNN.Extra.decode(e,a);case 79:return $root.MNN.Pool3D.decode(e,a);case 80:return $root.MNN.Convolution3D.decode(e,a);case 81:return $root.MNN.ELU.decode(e,a);case 82:return $root.MNN.DetectionPostProcessParam.decode(e,a);case 83:return $root.MNN.OneHotParam.decode(e,a);case 84:return $root.MNN.PadParam.decode(e,a)}}static decodeText(e,a,t){switch(t){case"QuantizedAdd":return $root.MNN.QuantizedAdd.decodeText(e,a);case"ArgMax":return $root.MNN.ArgMax.decodeText(e,a);case"AsString":return $root.MNN.AsString.decodeText(e,a);case"Axis":return $root.MNN.Axis.decodeText(e,a);case"BatchNorm":return $root.MNN.BatchNorm.decodeText(e,a);case"BinaryOp":return $root.MNN.BinaryOp.decodeText(e,a);case"Blob":return $root.MNN.Blob.decodeText(e,a);case"CastParam":return $root.MNN.CastParam.decodeText(e,a);case"Convolution2D":return $root.MNN.Convolution2D.decodeText(e,a);case"Crop":return $root.MNN.Crop.decodeText(e,a);case"CropAndResize":return $root.MNN.CropAndResize.decodeText(e,a);case"Dequantize":return $root.MNN.Dequantize.decodeText(e,a);case"DetectionOutput":return $root.MNN.DetectionOutput.decodeText(e,a);case"Eltwise":return $root.MNN.Eltwise.decodeText(e,a);case"ExpandDims":return $root.MNN.ExpandDims.decodeText(e,a);case"Fill":return $root.MNN.Fill.decodeText(e,a);case"Flatten":return $root.MNN.Flatten.decodeText(e,a);case"Gather":return $root.MNN.Gather.decodeText(e,a);case"GatherV2":return $root.MNN.GatherV2.decodeText(e,a);case"InnerProduct":return $root.MNN.InnerProduct.decodeText(e,a);case"Input":return $root.MNN.Input.decodeText(e,a);case"Interp":return $root.MNN.Interp.decodeText(e,a);case"LRN":return $root.MNN.LRN.decodeText(e,a);case"LSTM":return $root.MNN.LSTM.decodeText(e,a);case"MatMul":return $root.MNN.MatMul.decodeText(e,a);case"NonMaxSuppressionV2":return $root.MNN.NonMaxSuppressionV2.decodeText(e,a);case"Normalize":return $root.MNN.Normalize.decodeText(e,a);case"PackParam":return $root.MNN.PackParam.decodeText(e,a);case"Permute":return $root.MNN.Permute.decodeText(e,a);case"Plugin":return $root.MNN.Plugin.decodeText(e,a);case"Pool":return $root.MNN.Pool.decodeText(e,a);case"PRelu":return $root.MNN.PRelu.decodeText(e,a);case"PriorBox":return $root.MNN.PriorBox.decodeText(e,a);case"Proposal":return $root.MNN.Proposal.decodeText(e,a);case"QuantizedAvgPool":return $root.MNN.QuantizedAvgPool.decodeText(e,a);case"QuantizedBiasAdd":return $root.MNN.QuantizedBiasAdd.decodeText(e,a);case"QuantizedConcat":return $root.MNN.QuantizedConcat.decodeText(e,a);case"QuantizedLogistic":return $root.MNN.QuantizedLogistic.decodeText(e,a);case"QuantizedMatMul":return $root.MNN.QuantizedMatMul.decodeText(e,a);case"QuantizedMaxPool":return $root.MNN.QuantizedMaxPool.decodeText(e,a);case"QuantizedRelu":return $root.MNN.QuantizedRelu.decodeText(e,a);case"QuantizedRelu6":return $root.MNN.QuantizedRelu6.decodeText(e,a);case"QuantizedReshape":return $root.MNN.QuantizedReshape.decodeText(e,a);case"QuantizedSoftmax":return $root.MNN.QuantizedSoftmax.decodeText(e,a);case"QuantizeMaxMin":return $root.MNN.QuantizeMaxMin.decodeText(e,a);case"QuantizeV2":return $root.MNN.QuantizeV2.decodeText(e,a);case"Range":return $root.MNN.Range.decodeText(e,a);case"Rank":return $root.MNN.Rank.decodeText(e,a);case"ReduceJoin":return $root.MNN.ReduceJoin.decodeText(e,a);case"ReductionParam":return $root.MNN.ReductionParam.decodeText(e,a);case"Relu":return $root.MNN.Relu.decodeText(e,a);case"Relu6":return $root.MNN.Relu6.decodeText(e,a);case"RequantizationRange":return $root.MNN.RequantizationRange.decodeText(e,a);case"Requantize":return $root.MNN.Requantize.decodeText(e,a);case"Reshape":return $root.MNN.Reshape.decodeText(e,a);case"Resize":return $root.MNN.Resize.decodeText(e,a);case"RoiPooling":return $root.MNN.RoiPooling.decodeText(e,a);case"Scale":return $root.MNN.Scale.decodeText(e,a);case"Selu":return $root.MNN.Selu.decodeText(e,a);case"Size":return $root.MNN.Size.decodeText(e,a);case"Slice":return $root.MNN.Slice.decodeText(e,a);case"SliceTf":return $root.MNN.SliceTf.decodeText(e,a);case"SpaceBatch":return $root.MNN.SpaceBatch.decodeText(e,a);case"SqueezeParam":return $root.MNN.SqueezeParam.decodeText(e,a);case"StridedSliceParam":return $root.MNN.StridedSliceParam.decodeText(e,a);case"TensorConvertInfo":return $root.MNN.TensorConvertInfo.decodeText(e,a);case"TfQuantizedConv2D":return $root.MNN.TfQuantizedConv2D.decodeText(e,a);case"TopKV2":return $root.MNN.TopKV2.decodeText(e,a);case"Transpose":return $root.MNN.Transpose.decodeText(e,a);case"UnaryOp":return $root.MNN.UnaryOp.decodeText(e,a);case"MomentsParam":return $root.MNN.MomentsParam.decodeText(e,a);case"RNNParam":return $root.MNN.RNNParam.decodeText(e,a);case"BatchMatMulParam":return $root.MNN.BatchMatMulParam.decodeText(e,a);case"QuantizedFloatParam":return $root.MNN.QuantizedFloatParam.decodeText(e,a);case"DepthSpaceParam":return $root.MNN.DepthSpaceParam.decodeText(e,a);case"EltwiseInt8":return $root.MNN.EltwiseInt8.decodeText(e,a);case"ReverseSequenceParam":return $root.MNN.ReverseSequenceParam.decodeText(e,a);case"Extra":return $root.MNN.Extra.decodeText(e,a);case"Pool3D":return $root.MNN.Pool3D.decodeText(e,a);case"Convolution3D":return $root.MNN.Convolution3D.decodeText(e,a);case"ELU":return $root.MNN.ELU.decodeText(e,a);case"DetectionPostProcessParam":return $root.MNN.DetectionPostProcessParam.decodeText(e,a);case"OneHotParam":return $root.MNN.OneHotParam.decodeText(e,a);case"PadParam":return $root.MNN.PadParam.decodeText(e,a)}}},$root.MNN.Op=class{static decode(e,a){const t=new $root.MNN.Op;return t.inputIndexes=e.typedArray(a,4,Int32Array),t.main=e.union(a,6,$root.MNN.OpParameter.decode),t.name=e.string_(a,10,null),t.outputIndexes=e.typedArray(a,12,Int32Array),t.type=e.int32_(a,14,0),t.defaultDimentionFormat=e.int8_(a,16,void 0),t}},$root.MNN.TensorDescribe=class{static decode(e,a){const t=new $root.MNN.TensorDescribe;return t.blob=e.table(a,4,$root.MNN.Blob.decode),t.index=e.int32_(a,6,0),t.name=e.string_(a,8,null),t}},$root.MNN.ForwardType={CPU:0,METAL:1,OPENCL:2,OPENGLES:3,VULKAN:4},$root.MNN.Usage={INFERENCE:0,TRAIN:1},$root.MNN.Net=class{static create(e){return $root.MNN.Net.decode(e,e.root)}static decode(e,a){const t=new $root.MNN.Net;return t.bizCode=e.string_(a,4,null),t.extraTensorDescribe=e.tableArray(a,6,$root.MNN.TensorDescribe.decode),t.gpulibrary=e.table(a,8,$root.MNN.GpuLibrary.decode),t.oplists=e.tableArray(a,10,$root.MNN.Op.decode),t.outputName=e.strings_(a,12),t.preferForwardType=e.int8_(a,14,0),t.sourceType=e.int8_(a,16,0),t.tensorName=e.strings_(a,18),t.tensorNumber=e.int32_(a,20,0),t.usage=e.int8_(a,22,0),t}},$root.MNN.PadMode={CAFFE:0,VALID:1,SAME:2},$root.MNN.Convolution2DCommon=class{static decode(e,a){const t=new $root.MNN.Convolution2DCommon;return t.padX=e.int32_(a,4,0),t.padY=e.int32_(a,6,0),t.kernelX=e.int32_(a,8,1),t.kernelY=e.int32_(a,10,1),t.strideX=e.int32_(a,12,1),t.strideY=e.int32_(a,14,1),t.dilateX=e.int32_(a,16,1),t.dilateY=e.int32_(a,18,1),t.padMode=e.int8_(a,20,0),t.group=e.int32_(a,22,1),t.outputCount=e.int32_(a,24,0),t.inputCount=e.int32_(a,26,0),t.relu=e.bool_(a,28,!1),t.relu6=e.bool_(a,30,!1),t.pads=e.typedArray(a,32,Int32Array),t}},$root.MNN.Convolution3DCommon=class{static decode(e,a){const t=new $root.MNN.Convolution3DCommon;return t.dilates=e.typedArray(a,4,Int32Array),t.strides=e.typedArray(a,6,Int32Array),t.kernels=e.typedArray(a,8,Int32Array),t.pads=e.typedArray(a,10,Int32Array),t.padMode=e.int8_(a,12,0),t.inputCount=e.int32_(a,14,0),t.outputCount=e.int32_(a,16,0),t.relu=e.bool_(a,18,!1),t.relu6=e.bool_(a,20,!1),t}},$root.MNN.IDSTQuan=class{static decode(e,a){const t=new $root.MNN.IDSTQuan;return t.buffer=e.typedArray(a,4,Int8Array),t.alpha=e.typedArray(a,6,Float32Array),t.type=e.int32_(a,8,0),t.useInt32=e.bool_(a,10,!1),t.quantScale=e.float32_(a,12,0),t.scaleIn=e.float32_(a,14,0),t.scaleOut=e.float32_(a,16,0),t.aMax=e.int32_(a,18,0),t.aMin=e.int32_(a,20,0),t.readType=e.int32_(a,22,0),t.has_scaleInt=e.bool_(a,24,!1),t}},$root.MNN.QuantizeAlgo={DEFAULT:0,OVERFLOW_AWARE:1},$root.MNN.QuantizedFloatParam=class{static decode(e,a){const t=new $root.MNN.QuantizedFloatParam;return t.weight=e.typedArray(a,4,Int8Array),t.bias=e.typedArray(a,6,Int32Array),t.scale=e.typedArray(a,8,Float32Array),t.tensorScale=e.typedArray(a,10,Float32Array),t.method=e.int8_(a,12,0),t}},$root.MNN.Convolution2D=class{static decode(e,a){const t=new $root.MNN.Convolution2D;return t.common=e.table(a,4,$root.MNN.Convolution2DCommon.decode),t.weight=e.typedArray(a,6,Float32Array),t.bias=e.typedArray(a,8,Float32Array),t.quanParameter=e.table(a,10,$root.MNN.IDSTQuan.decode),t.symmetricQuan=e.table(a,12,$root.MNN.QuantizedFloatParam.decode),t}},$root.MNN.Convolution3D=class{static decode(e,a){const t=new $root.MNN.Convolution3D;return t.common=e.table(a,4,$root.MNN.Convolution3DCommon.decode),t.weight=e.typedArray(a,6,Float32Array),t.bias=e.typedArray(a,8,Float32Array),t}},$root.MNN.InnerProduct=class{static decode(e,a){const t=new $root.MNN.InnerProduct;return t.outputCount=e.int32_(a,4,0),t.biasTerm=e.int32_(a,6,0),t.weightSize=e.int32_(a,8,0),t.weight=e.typedArray(a,10,Float32Array),t.bias=e.typedArray(a,12,Float32Array),t.axis=e.int32_(a,14,0),t.transpose=e.bool_(a,16,!1),t.quanParameter=e.table(a,18,$root.MNN.IDSTQuan.decode),t}},$root.MNN.PoolType={MAXPOOL:0,AVEPOOL:1},$root.MNN.PoolPadType={CAFFE:0,VALID:1,SAME:2},$root.MNN.Pool=class{static decode(e,a){const t=new $root.MNN.Pool;return t.padX=e.int32_(a,4,0),t.padY=e.int32_(a,6,0),t.isGlobal=e.bool_(a,8,!1),t.kernelX=e.int32_(a,10,0),t.kernelY=e.int32_(a,12,0),t.strideX=e.int32_(a,14,0),t.strideY=e.int32_(a,16,0),t.type=e.int8_(a,18,0),t.padType=e.int8_(a,20,0),t.dataType=e.int32_(a,22,1),t.ceilModel=e.bool_(a,24,!0),t.pads=e.typedArray(a,26,Int32Array),t}},$root.MNN.Pool3D=class{static decode(e,a){const t=new $root.MNN.Pool3D;return t.strides=e.typedArray(a,4,Int32Array),t.kernels=e.typedArray(a,6,Int32Array),t.pads=e.typedArray(a,8,Int32Array),t.type=e.int8_(a,10,0),t.padType=e.int8_(a,12,0),t}},$root.MNN.Relu=class{static decode(e,a){const t=new $root.MNN.Relu;return t.slope=e.float32_(a,4,0),t}},$root.MNN.Relu6=class{static decode(e,a){const t=new $root.MNN.Relu6;return t.minValue=e.float32_(a,4,0),t.maxValue=e.float32_(a,6,6),t}},$root.MNN.PRelu=class{static decode(e,a){const t=new $root.MNN.PRelu;return t.slopeCount=e.int32_(a,4,0),t.slope=e.typedArray(a,6,Float32Array),t}},$root.MNN.ELU=class{static decode(e,a){const t=new $root.MNN.ELU;return t.alpha=e.float32_(a,4,0),t}},$root.MNN.LRN=class{static decode(e,a){const t=new $root.MNN.LRN;return t.regionType=e.int32_(a,4,0),t.localSize=e.int32_(a,6,0),t.alpha=e.float32_(a,8,0),t.beta=e.float32_(a,10,0),t}},$root.MNN.ArgMax=class{static decode(e,a){const t=new $root.MNN.ArgMax;return t.outMaxVal=e.int32_(a,4,0),t.topK=e.int32_(a,6,0),t.axis=e.int32_(a,8,0),t.softmaxThreshold=e.int32_(a,10,0),t}},$root.MNN.Axis=class{static decode(e,a){const t=new $root.MNN.Axis;return t.axis=e.int32_(a,4,0),t}},$root.MNN.Input=class{static decode(e,a){const t=new $root.MNN.Input;return t.dims=e.typedArray(a,4,Int32Array),t.dtype=e.int32_(a,6,1),t.dformat=e.int8_(a,8,void 0),t}},$root.MNN.LSTM=class{static decode(e,a){const t=new $root.MNN.LSTM;return t.outputCount=e.int32_(a,4,0),t.weightSize=e.int32_(a,6,0),t.clippingThreshold=e.float32_(a,8,0),t.weightI=e.table(a,10,$root.MNN.Blob.decode),t.weightH=e.table(a,12,$root.MNN.Blob.decode),t.bias=e.table(a,14,$root.MNN.Blob.decode),t.weightIQ=e.table(a,16,$root.MNN.Blob.decode),t.weightIA=e.table(a,18,$root.MNN.Blob.decode),t.quantScale=e.float32_(a,20,0),t}},$root.MNN.Slice=class{static decode(e,a){const t=new $root.MNN.Slice;return t.axis=e.int32_(a,4,0),t.slicePoints=e.typedArray(a,6,Int32Array),t.sourceType=e.int8_(a,8,0),t}},$root.MNN.BatchNorm=class{static decode(e,a){const t=new $root.MNN.BatchNorm;return t.channels=e.int32_(a,4,0),t.slopeData=e.typedArray(a,6,Float32Array),t.meanData=e.typedArray(a,8,Float32Array),t.varData=e.typedArray(a,10,Float32Array),t.biasData=e.typedArray(a,12,Float32Array),t.Adata=e.typedArray(a,14,Float32Array),t.Bdata=e.typedArray(a,16,Float32Array),t.epsilon=e.float32_(a,18,.001),t}},$root.MNN.Scale=class{static decode(e,a){const t=new $root.MNN.Scale;return t.channels=e.int32_(a,4,0),t.scaleData=e.typedArray(a,6,Float32Array),t.biasData=e.typedArray(a,8,Float32Array),t}},$root.MNN.EltwiseType={PROD:0,SUM:1,MAXIMUM:2,SUB:3},$root.MNN.Eltwise=class{static decode(e,a){const t=new $root.MNN.Eltwise;return t.type=e.int8_(a,4,0),t.coeff=e.typedArray(a,6,Float32Array),t}},$root.MNN.Flatten=class{static decode(e,a){const t=new $root.MNN.Flatten;return t.axis=e.int32_(a,4,0),t.endAxis=e.int32_(a,6,0),t}},$root.MNN.Permute=class{static decode(e,a){const t=new $root.MNN.Permute;return t.dims=e.typedArray(a,4,Int32Array),t}},$root.MNN.Reshape=class{static decode(e,a){const t=new $root.MNN.Reshape;return t.dims=e.typedArray(a,4,Int32Array),t.dimType=e.int8_(a,6,void 0),t}},$root.MNN.DetectionOutput=class{static decode(e,a){const t=new $root.MNN.DetectionOutput;return t.classCount=e.int32_(a,4,0),t.nmsThresholdold=e.float32_(a,6,0),t.nmsTopK=e.int32_(a,8,0),t.keepTopK=e.int32_(a,10,0),t.confidenceThreshold=e.float32_(a,12,0),t.shareLocation=e.int32_(a,14,0),t.backgroundLable=e.int32_(a,16,0),t.varianceEncodedTarget=e.int32_(a,18,0),t.codeType=e.int32_(a,20,0),t.objectnessScore=e.float32_(a,22,.01),t}},$root.MNN.RoiPooling=class{static decode(e,a){const t=new $root.MNN.RoiPooling;return t.pooledWidth=e.int32_(a,4,0),t.pooledHeight=e.int32_(a,6,0),t.spatialScale=e.float32_(a,8,0),t}},$root.MNN.Proposal=class{static decode(e,a){const t=new $root.MNN.Proposal;return t.featStride=e.int32_(a,4,0),t.baseSize=e.int32_(a,6,0),t.preNmsTopN=e.int32_(a,8,0),t.afterNmsTopN=e.int32_(a,10,0),t.nmsThreshold=e.float32_(a,12,0),t.minSize=e.int32_(a,14,0),t.ratios=e.table(a,16,$root.MNN.Blob.decode),t.scales=e.table(a,18,$root.MNN.Blob.decode),t.anchors=e.table(a,20,$root.MNN.Blob.decode),t}},$root.MNN.Interp=class{static decode(e,a){const t=new $root.MNN.Interp;return t.widthScale=e.float32_(a,4,0),t.heightScale=e.float32_(a,6,0),t.outputWidth=e.int32_(a,8,0),t.outputHeight=e.int32_(a,10,0),t.resizeType=e.int32_(a,12,0),t.alignCorners=e.bool_(a,14,!1),t.halfPixelCenters=e.bool_(a,16,!1),t}},$root.MNN.Resize=class{static decode(e,a){const t=new $root.MNN.Resize;return t.xScale=e.float32_(a,4,0),t.yScale=e.float32_(a,6,0),t}},$root.MNN.PriorBox=class{static decode(e,a){const t=new $root.MNN.PriorBox;return t.minSizes=e.typedArray(a,4,Float32Array),t.maxSizes=e.typedArray(a,6,Float32Array),t.aspectRatios=e.typedArray(a,8,Float32Array),t.variances=e.typedArray(a,10,Float32Array),t.flip=e.bool_(a,12,!1),t.clip=e.bool_(a,14,!1),t.imageWidth=e.int32_(a,16,0),t.imageHeight=e.int32_(a,18,0),t.stepWidth=e.int32_(a,20,0),t.stepHeight=e.int32_(a,22,0),t.offset=e.float32_(a,24,0),t}},$root.MNN.Normalize=class{static decode(e,a){const t=new $root.MNN.Normalize;return t.acrossSpatial=e.int32_(a,4,0),t.channelShared=e.int32_(a,6,0),t.eps=e.float32_(a,8,0),t.scale=e.typedArray(a,10,Float32Array),t}},$root.MNN.EltwiseInt8=class{static decode(e,a){const t=new $root.MNN.EltwiseInt8;return t.type=e.int8_(a,4,0),t.inputQuan0=e.table(a,6,$root.MNN.QuantizedFloatParam.decode),t.inputQuan1=e.table(a,8,$root.MNN.QuantizedFloatParam.decode),t.outputQuan=e.table(a,10,$root.MNN.QuantizedFloatParam.decode),t}},$root.MNN.MNN_DATA_FORMAT={NCHW:0,NHWC:1,NC4HW4:2,NHWC4:3,UNKNOWN:4},$root.MNN.Blob=class{static decode(e,a){const t=new $root.MNN.Blob;return t.dims=e.typedArray(a,4,Int32Array),t.dataFormat=e.int8_(a,6,0),t.dataType=e.int32_(a,8,1),t.uint8s=e.typedArray(a,10,Uint8Array),t.int8s=e.typedArray(a,12,Int8Array),t.int32s=e.typedArray(a,14,Int32Array),t.int64s=e.int64s_(a,16),t.float32s=e.typedArray(a,18,Float32Array),t.strings=e.strings_(a,20),t}},$root.MNN.ListValue=class{static decode(e,a){const t=new $root.MNN.ListValue;return t.s=e.strings_(a,4),t.i=e.typedArray(a,6,Int32Array),t.f=e.typedArray(a,8,Float32Array),t.b=e.bools_(a,10),t.type=e.typedArray(a,12,Int32Array),t}},$root.MNN.Attribute=class{static decode(e,a){const t=new $root.MNN.Attribute;return t.s=e.string_(a,4,null),t.i=e.int32_(a,6,0),t.b=e.bool_(a,8,!1),t.key=e.string_(a,10,null),t.type=e.int32_(a,12,void 0),t.f=e.float32_(a,14,0),t.tensor=e.table(a,16,$root.MNN.Blob.decode),t.list=e.table(a,18,$root.MNN.ListValue.decode),t}},$root.MNN.NetSource={CAFFE:0,TENSORFLOW:1,TFLITE:2,ONNX:3},$root.MNN.DataType={DT_INVALID:0,DT_FLOAT:1,DT_DOUBLE:2,DT_INT32:3,DT_UINT8:4,DT_INT16:5,DT_INT8:6,DT_STRING:7,DT_COMPLEX64:8,DT_INT64:9,DT_BOOL:10,DT_QINT8:11,DT_QUINT8:12,DT_QINT32:13,DT_BFLOAT16:14,DT_QINT16:15,DT_QUINT16:16,DT_UINT16:17,DT_COMPLEX128:18,DT_HALF:19,DT_RESOURCE:20,DT_VARIANT:21},$root.MNN.BinaryOpOperation={ADD:0,SUB:1,MUL:2,DIV:3,MAX_TEMP:4,MIN_TEMP:5,POW:6,REALDIV:7,MINIMUM:8,MAXIMUM:9,GREATER:10,GREATER_EQUAL:11,LESS:12,FLOORDIV:13,SquaredDifference:14,EQUAL:15,LESS_EQUAL:16,FLOORMOD:17,MOD:19,ATAN2:20,LOGICALOR:21,NOTEQUAL:22},$root.MNN.BinaryOp=class{static decode(e,a){const t=new $root.MNN.BinaryOp;return t.opType=e.int32_(a,4,0),t.T=e.int32_(a,6,1),t}},$root.MNN.PackParam=class{static decode(e,a){const t=new $root.MNN.PackParam;return t.dataType=e.int32_(a,4,0),t.axis=e.int32_(a,6,0),t}},$root.MNN.StridedSliceParam=class{static decode(e,a){const t=new $root.MNN.StridedSliceParam;return t.Index=e.int32_(a,4,0),t.T=e.int32_(a,6,0),t.beginMask=e.int32_(a,8,0),t.endMask=e.int32_(a,10,0),t.ellipsisMask=e.int32_(a,12,0),t.newAxisMask=e.int32_(a,14,0),t.shrinkAxisMask=e.int32_(a,16,0),t}},$root.MNN.SqueezeParam=class{static decode(e,a){const t=new $root.MNN.SqueezeParam;return t.squeezeDims=e.typedArray(a,4,Int32Array),t}},$root.MNN.CastParam=class{static decode(e,a){const t=new $root.MNN.CastParam;return t.srcT=e.int32_(a,4,0),t.dstT=e.int32_(a,6,0),t}},$root.MNN.ReductionType={SUM:0,ASUM:1,SUMSQ:2,MEAN:3,MAXIMUM:4,MINIMUM:5,PROD:6,ANY:7,ALL:8},$root.MNN.ReductionParam=class{static decode(e,a){const t=new $root.MNN.ReductionParam;return t.operation=e.int8_(a,4,0),t.dim=e.typedArray(a,6,Int32Array),t.coeff=e.float32_(a,8,0),t.keepDims=e.bool_(a,10,!1),t.dType=e.int32_(a,12,1),t}},$root.MNN.Gather=class{static decode(e,a){const t=new $root.MNN.Gather;return t.Tindices=e.int32_(a,4,0),t.Tparams=e.int32_(a,6,0),t.validateIndices=e.bool_(a,8,!1),t.axis=e.int32_(a,10,0),t}},$root.MNN.ExpandDims=class{static decode(e,a){const t=new $root.MNN.ExpandDims;return t.T=e.int32_(a,4,0),t.Tdim=e.int32_(a,6,0),t.axis=e.int32_(a,8,0),t}},$root.MNN.Selu=class{static decode(e,a){const t=new $root.MNN.Selu;return t.scale=e.float32_(a,4,0),t.alpha=e.float32_(a,6,0),t}},$root.MNN.AsString=class{static decode(e,a){const t=new $root.MNN.AsString;return t.T=e.int32_(a,4,0),t.precision=e.int32_(a,6,0),t.scientific=e.bool_(a,8,!1),t.shortest=e.bool_(a,10,!1),t.width=e.int32_(a,12,0),t.fillString=e.string_(a,14,null),t}},$root.MNN.ReduceJoin=class{static decode(e,a){const t=new $root.MNN.ReduceJoin;return t.keepDims=e.bool_(a,4,!1),t.separator=e.string_(a,6,null),t}},$root.MNN.UnaryOpOperation={ABS:0,NEG:1,FLOOR:2,CEIL:3,SQUARE:4,SQRT:5,RSQRT:6,EXP:7,LOG:8,SIN:9,COS:10,TAN:11,ASIN:12,ACOS:13,ATAN:14,RECIPROCAL:15,LOG1P:16,BNLL:17,ACOSH:18,SINH:19,ASINH:20,ATANH:21,SIGN:22,ROUND:23,COSH:24,ERF:25,ERFC:26,ERFINV:27,EXPM1:28},$root.MNN.UnaryOp=class{static decode(e,a){const t=new $root.MNN.UnaryOp;return t.opType=e.int32_(a,4,0),t.T=e.int32_(a,6,0),t}},$root.MNN.TopKV2=class{static decode(e,a){const t=new $root.MNN.TopKV2;return t.T=e.int32_(a,4,1),t.sorted=e.bool_(a,6,!1),t}},$root.MNN.CropAndResizeMethod={BILINEAR:0,NEAREST:1},$root.MNN.CropAndResize=class{static decode(e,a){const t=new $root.MNN.CropAndResize;return t.extrapolationValue=e.float32_(a,4,0),t.method=e.int8_(a,6,0),t}},$root.MNN.Fill=class{static decode(e,a){return new $root.MNN.Fill}},$root.MNN.GatherV2=class{static decode(e,a){const t=new $root.MNN.GatherV2;return t.Taxis=e.int32_(a,4,0),t.Tindices=e.int32_(a,6,0),t.Tparams=e.int32_(a,8,0),t}},$root.MNN.NonMaxSuppressionV2=class{static decode(e,a){return new $root.MNN.NonMaxSuppressionV2}},$root.MNN.Range=class{static decode(e,a){const t=new $root.MNN.Range;return t.Tidx=e.int32_(a,4,0),t}},$root.MNN.Rank=class{static decode(e,a){return new $root.MNN.Rank}},$root.MNN.Size=class{static decode(e,a){const t=new $root.MNN.Size;return t.outputDataType=e.int32_(a,4,0),t}},$root.MNN.Transpose=class{static decode(e,a){const t=new $root.MNN.Transpose;return t.Tperm=e.int32_(a,4,0),t}},$root.MNN.SliceTf=class{static decode(e,a){const t=new $root.MNN.SliceTf;return t.T=e.int32_(a,4,0),t}},$root.MNN.QuantizeMaxMin=class{static decode(e,a){const t=new $root.MNN.QuantizeMaxMin;return t.T=e.int32_(a,4,0),t}},$root.MNN.Crop=class{static decode(e,a){const t=new $root.MNN.Crop;return t.axis=e.int32_(a,4,2),t.offset=e.typedArray(a,6,Int32Array),t}},$root.MNN.SpaceBatch=class{static decode(e,a){const t=new $root.MNN.SpaceBatch;return t.blockShape=e.table(a,4,$root.MNN.Blob.decode),t.padding=e.table(a,6,$root.MNN.Blob.decode),t}},$root.MNN.MatMul=class{static decode(e,a){const t=new $root.MNN.MatMul;return t.T=e.int32_(a,4,0),t.transposeA=e.bool_(a,6,!1),t.transposeB=e.bool_(a,8,!1),t.weight=e.typedArray(a,10,Float32Array),t.bias=e.typedArray(a,12,Float32Array),t}},$root.MNN.MomentsParam=class{static decode(e,a){const t=new $root.MNN.MomentsParam;return t.dim=e.typedArray(a,4,Int32Array),t.keepDims=e.bool_(a,6,!0),t.dType=e.int32_(a,8,1),t}},$root.MNN.RNNParam=class{static decode(e,a){const t=new $root.MNN.RNNParam;return t.numUnits=e.int32_(a,4,0),t.isBidirectionalRNN=e.bool_(a,6,!1),t.keepAllOutputs=e.bool_(a,8,!1),t.fwGateWeight=e.table(a,10,$root.MNN.Blob.decode),t.fwGateBias=e.table(a,12,$root.MNN.Blob.decode),t.fwCandidateWeight=e.table(a,14,$root.MNN.Blob.decode),t.fwCandidateBias=e.table(a,16,$root.MNN.Blob.decode),t.bwGateWeight=e.table(a,18,$root.MNN.Blob.decode),t.bwGateBias=e.table(a,20,$root.MNN.Blob.decode),t.bwCandidateWeight=e.table(a,22,$root.MNN.Blob.decode),t.bwCandidateBias=e.table(a,24,$root.MNN.Blob.decode),t}},$root.MNN.BatchMatMulParam=class{static decode(e,a){const t=new $root.MNN.BatchMatMulParam;return t.adjX=e.bool_(a,4,!1),t.adjY=e.bool_(a,6,!1),t}},$root.MNN.DepthSpaceParam=class{static decode(e,a){const t=new $root.MNN.DepthSpaceParam;return t.blockSize=e.int32_(a,4,0),t}},$root.MNN.ReverseSequenceParam=class{static decode(e,a){const t=new $root.MNN.ReverseSequenceParam;return t.batchDim=e.int32_(a,4,0),t.seqDim=e.int32_(a,6,0),t}},$root.MNN.DetectionPostProcessParam=class{static decode(e,a){const t=new $root.MNN.DetectionPostProcessParam;return t.maxDetections=e.int32_(a,4,0),t.maxClassesPerDetection=e.int32_(a,6,0),t.detectionsPerClass=e.int32_(a,8,0),t.nmsScoreThreshold=e.float32_(a,10,0),t.iouThreshold=e.float32_(a,12,0),t.numClasses=e.int32_(a,14,0),t.useRegularNMS=e.bool_(a,16,!1),t.centerSizeEncoding=e.typedArray(a,18,Float32Array),t}},$root.MNN.OneHotParam=class{static decode(e,a){const t=new $root.MNN.OneHotParam;return t.dType=e.int32_(a,4,1),t.axis=e.int32_(a,6,-1),t}},$root.MNN.PadValueMode={CONSTANT:0,REFLECT:1,SYMMETRIC:2},$root.MNN.PadParam=class{static decode(e,a){const t=new $root.MNN.PadParam;return t.mode=e.int8_(a,4,0),t}},$root.MNN.FusedActivation={kTfLiteActNone:0,kTfLiteActRelu:1,kTfLiteActRelu1:2,kTfLiteActRelu6:3,kTfLiteActTanh:4,kTfLiteActSignBit:5,kTfLiteActSigmoid:6},$root.MNN.QuantizedParam=class{static decode(e,a){const t=new $root.MNN.QuantizedParam;return t.zeroPoint=e.int32_(a,4,0),t.scale=e.float32_(a,6,0),t}},$root.MNN.QuantizedAdd=class{static decode(e,a){const t=new $root.MNN.QuantizedAdd;return t.activationType=e.int8_(a,4,0),t.input1QuantizedParam=e.table(a,6,$root.MNN.QuantizedParam.decode),t.input2QuantizedParam=e.table(a,8,$root.MNN.QuantizedParam.decode),t.outputQuantizedParam=e.table(a,10,$root.MNN.QuantizedParam.decode),t}},$root.MNN.ModeFormat={TENSORFLOW:0,TFLITE:1},$root.MNN.QuantizeMode={MIN_COMBINED:0,MIN_FIRST:1,SCALED:2},$root.MNN.Dequantize=class{static decode(e,a){const t=new $root.MNN.Dequantize;return t.inputQuantizedParam=e.table(a,4,$root.MNN.QuantizedParam.decode),t.mode=e.int8_(a,6,0),t.modelFormat=e.int8_(a,8,0),t.type=e.int32_(a,10,0),t}},$root.MNN.QuantizedAvgPool=class{static decode(e,a){const t=new $root.MNN.QuantizedAvgPool;return t.kernelX=e.int32_(a,4,0),t.kernelY=e.int32_(a,6,0),t.modelFormat=e.int8_(a,8,0),t.outputActivationMax=e.int32_(a,10,0),t.outputActivationMin=e.int32_(a,12,0),t.padType=e.int8_(a,14,0),t.padX=e.int32_(a,16,0),t.padY=e.int32_(a,18,0),t.strideX=e.int32_(a,20,0),t.strideY=e.int32_(a,22,0),t.type=e.int32_(a,24,0),t}},$root.MNN.QuantizedBiasAdd=class{static decode(e,a){const t=new $root.MNN.QuantizedBiasAdd;return t.bias=e.typedArray(a,4,Int32Array),t.inputType=e.int32_(a,6,0),t.max=e.int32_(a,8,0),t.min=e.int32_(a,10,0),t.outputType=e.int32_(a,12,0),t}},$root.MNN.QuantizedConcat=class{static decode(e,a){const t=new $root.MNN.QuantizedConcat;return t.activationType=e.int8_(a,4,0),t.axis=e.int32_(a,6,0),t.inputScale=e.typedArray(a,8,Float32Array),t.inputZeroPoint=e.typedArray(a,10,Int32Array),t.outputQuantizedParam=e.table(a,12,$root.MNN.QuantizedParam.decode),t}},$root.MNN.QuantizedLogistic=class{static decode(e,a){const t=new $root.MNN.QuantizedLogistic;return t.inputQuantizedParam=e.table(a,4,$root.MNN.QuantizedParam.decode),t.outputQuantizedParam=e.table(a,6,$root.MNN.QuantizedParam.decode),t}},$root.MNN.QuantizedMatMul=class{static decode(e,a){const t=new $root.MNN.QuantizedMatMul;return t.transposeA=e.bool_(a,4,!1),t.transposeB=e.bool_(a,6,!1),t}},$root.MNN.QuantizedMaxPool=class{static decode(e,a){const t=new $root.MNN.QuantizedMaxPool;return t.kernelX=e.int32_(a,4,0),t.kernelY=e.int32_(a,6,0),t.modelFormat=e.int8_(a,8,0),t.outputActivationMax=e.int32_(a,10,0),t.outputActivationMin=e.int32_(a,12,0),t.padType=e.int8_(a,14,0),t.padX=e.int32_(a,16,0),t.padY=e.int32_(a,18,0),t.strideX=e.int32_(a,20,0),t.strideY=e.int32_(a,22,0),t.type=e.int32_(a,24,0),t}},$root.MNN.QuantizedRelu=class{static decode(e,a){const t=new $root.MNN.QuantizedRelu;return t.type=e.int32_(a,4,0),t}},$root.MNN.QuantizedRelu6=class{static decode(e,a){const t=new $root.MNN.QuantizedRelu6;return t.type=e.int32_(a,4,0),t}},$root.MNN.QuantizedReshape=class{static decode(e,a){const t=new $root.MNN.QuantizedReshape;return t.dims=e.typedArray(a,4,Int32Array),t.modelFormat=e.int8_(a,6,0),t}},$root.MNN.QuantizedSoftmax=class{static decode(e,a){const t=new $root.MNN.QuantizedSoftmax;return t.beta=e.float32_(a,4,0),t.inputScale=e.float32_(a,6,0),t}},$root.MNN.QuantizeRoundMode={HALF_AWAY_FROM_ZERO:0,HALF_TO_EVEN:1},$root.MNN.QuantizeV2=class{static decode(e,a){const t=new $root.MNN.QuantizeV2;return t.type=e.int32_(a,4,0),t.mode=e.int8_(a,6,0),t.roundMode=e.int8_(a,8,0),t}},$root.MNN.RequantizationRange=class{static decode(e,a){return new $root.MNN.RequantizationRange}},$root.MNN.Requantize=class{static decode(e,a){return new $root.MNN.Requantize}},$root.MNN.TfQuantizedConv2D=class{static decode(e,a){const t=new $root.MNN.TfQuantizedConv2D;return t.bias=e.typedArray(a,4,Int32Array),t.biasflag=e.bool_(a,6,!1),t.common=e.table(a,8,$root.MNN.Convolution2DCommon.decode),t.weight=e.typedArray(a,10,Uint8Array),t.activationType=e.int8_(a,12,0),t.multiplier=e.int32_(a,14,0),t.outMax=e.int32_(a,16,0),t.outMin=e.int32_(a,18,0),t.shift=e.int32_(a,20,0),t.biasQuantizedParam=e.table(a,22,$root.MNN.QuantizedParam.decode),t.depthMultiplier=e.int32_(a,24,0),t.filterQuantizedParam=e.table(a,26,$root.MNN.QuantizedParam.decode),t.inputQuantizedParam=e.table(a,28,$root.MNN.QuantizedParam.decode),t.modelFormat=e.int8_(a,30,0),t.outputQuantizedParam=e.table(a,32,$root.MNN.QuantizedParam.decode),t}},$root.MNN.STORAGE_TYPE={BUFFER:0,UNIFORM:1,IMAGE:2},$root.MNN.ACCESS_TYPE={READ_ONLY:0,WRITE_ONLY:1,READ_WRITE:2},$root.MNN.GpuBuffer=class{static decode(e,a){const t=new $root.MNN.GpuBuffer;return t.access=e.int8_(a,4,0),t.storage=e.int8_(a,6,0),t.content=e.table(a,8,$root.MNN.Blob.decode),t}},$root.MNN.GpuPipeline=class{static decode(e,a){const t=new $root.MNN.GpuPipeline;return t.localSize=e.typedArray(a,4,Int32Array),t.key=e.string_(a,6,null),t.metal=e.typedArray(a,8,Int8Array),t.vulkan=e.typedArray(a,10,Int8Array),t.openglComputeShader=e.string_(a,12,null),t.openclKernel=e.string_(a,14,null),t}},$root.MNN.GpuStage=class{static decode(e,a){const t=new $root.MNN.GpuStage;return t.pipeline=e.string_(a,4,null),t.groupSize=e.typedArray(a,6,Int32Array),t.inputIndexes=e.typedArray(a,8,Int32Array),t.outputIndexes=e.typedArray(a,10,Int32Array),t.middleBuffer=e.tableArray(a,12,$root.MNN.GpuBuffer.decode),t.constBuffer=e.tableArray(a,14,$root.MNN.GpuBuffer.decode),t.globalSizeIndex=e.int32_(a,16,0),t.globalSizeDivide=e.typedArray(a,18,Int32Array),t.requireSize=e.bool_(a,20,!1),t}},$root.MNN.GpuFunction=class{static decode(e,a){const t=new $root.MNN.GpuFunction;return t.stags=e.tableArray(a,4,$root.MNN.GpuStage.decode),t.name=e.string_(a,6,null),t}},$root.MNN.GpuLibrary=class{static decode(e,a){const t=new $root.MNN.GpuLibrary;return t.functions=e.tableArray(a,4,$root.MNN.GpuFunction.decode),t.pipeline=e.tableArray(a,6,$root.MNN.GpuPipeline.decode),t.name=e.string_(a,8,null),t}},$root.MNN.TensorConvertInfo=class{static decode(e,a){const t=new $root.MNN.TensorConvertInfo;return t.source=e.int8_(a,4,0),t.dest=e.int8_(a,6,0),t}};
