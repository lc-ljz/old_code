var gzip=gzip||{};gzip.Archive=class{constructor(i){if(this._entries=[],i.length<18||i[0]!=31||i[1]!=139)throw new gzip.Error("Invalid gzip archive.");const t=new gzip.Reader(i,0,i.length);this._entries.push(new gzip.Entry(t))}get entries(){return this._entries}},gzip.Entry=class{constructor(i){if(!i.match([31,139]))throw new gzip.Error("Invalid gzip signature.");const t=i.byte();if(t!=8)throw new gzip.Error("Invalid compression method '"+t.toString()+"'.");const s=i.byte();if(i.uint32(),i.byte(),i.byte(),(4&s)!=0){const o=i.uint16();i.skip(o)}(8&s)!=0&&(this._name=i.string()),(16&s)!=0&&i.string(),(1&s)!=0&&i.uint16();const n=i.bytes();if(typeof process=="object"&&typeof process.versions=="object"&&process.versions.node!==void 0?this._data=require("zlib").inflateRawSync(n):typeof pako!="undefined"?this._data=pako.inflateRaw(n):this._data=new require("./zip").Inflater().inflateRaw(n),i.position=-8,i.uint32(),i.uint32()!=this._data.length)throw new gzip.Error("Invalid size.")}get name(){return this._name}get data(){return this._data}},gzip.Reader=class{constructor(i,t,s){this._buffer=i,this._position=t,this._end=s}match(i){if(this._position+i.length<=this._end){for(let t=0;t<i.length;t++)if(this._buffer[this._position+t]!=i[t])return!1}return this._position+=i.length,!0}get position(){return this._position}set position(i){this._position=i>=0?i:this._end+i}skip(i){if(this._position+i>this._end)throw new gzip.Error("Data not available.");this._position+=i}bytes(i){if(this._position+i>this._end)throw new gzip.Error("Data not available.");i=i===void 0?this._end:i;const t=this._buffer.subarray(this._position,this._position+i);return this._position+=i,t}byte(){if(this._position+1>this._end)throw new gzip.Error("Data not available.");const i=this._buffer[this._position];return this._position++,i}uint16(){if(this._position+2>this._end)throw new gzip.Error("Data not available.");const i=this._buffer[this._position]|this._buffer[this._position+1]<<8;return this._position+=2,i}uint32(){return this.uint16()|this.uint16()<<16}string(){let i="";const t=this._buffer.indexOf(0,this._position);if(t<0)throw new gzip.Error("End of string not found.");for(;this._position<t;)i+=String.fromCharCode(this._buffer[this._position++]);return this._position++,i}},gzip.Error=class extends Error{constructor(i){super(i),this.name="Gzip Error"}},typeof module!="undefined"&&typeof module.exports=="object"&&(module.exports.Archive=gzip.Archive);
