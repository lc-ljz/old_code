var darknet=darknet||{},base=base||require("./base"),long=long||{Long:require("long")};darknet.ModelFactory=class{match(s){const c=s.identifier.split(".").pop().toLowerCase();if(c=="cfg"||c=="model"){const r=s.text;if(r.substring(0,Math.min(r.length,1024)).indexOf("[net]")!==-1)return!0}return!1}open(s,c){return darknet.Metadata.open(c).then(r=>{const p=s.identifier,_=p.split(".");_.pop();const d=_.join(".");return s.request(d+".weights",null).then(M=>this._openModel(r,p,s.text,M)).catch(()=>this._openModel(r,p,s.text,null))})}_openModel(s,c,r,p){try{return new darknet.Model(s,r,p?new darknet.Weights(p):null)}catch(_){const d=_&&_.message?_.message:_.toString();throw new darknet.Error(d.replace(/\.$/,"")+" in '"+c+"'.")}}},darknet.Model=class{constructor(s,c,r){this._graphs=[],this._graphs.push(new darknet.Graph(s,c,r))}get format(){return"Darknet"}get graphs(){return this._graphs}},darknet.Graph=class{constructor(s,c,r){this._inputs=[],this._outputs=[],this._nodes=[];const p=[];let _=null;const d=c.split(`
`);let M=0;for(;d.length>0;){M++;const a=d.shift(),l=a.replace(/\s/g,"");if(l.length>0)switch(l[0]){case"#":case";":break;case"[":_={},_.line=M,_.type=l[l.length-1]==="]"?l.substring(1,l.length-1):l.substring(1),_.options={},p.push(_);break;default:if(!_||l[0]<32||l[0]>126)throw new darknet.Error("Invalid cfg '"+a.replace(/[^\x20-\x7E]+/g,"").trim()+"' at line "+M.toString()+".");if(_){const u=l.indexOf("=");if(u<0)throw new darknet.Error("Invalid cfg '"+a.replace(/[^\x20-\x7E]+/g,"").trim()+"' at line "+M.toString()+".");const t=l.substring(0,u),o=l.substring(u+1);_.options[t]=o}}}const h=(a,l,u)=>{let t=a[l];if(typeof t=="string"&&t.startsWith("$")){const o=t.substring(1);t=I.has(o)?I.get(o):t}if(t!==void 0){const o=parseInt(t,10);if(!Number.isInteger(o))throw new darknet.Error("Invalid int option '"+JSON.stringify(a[l])+"'.");return o}return u},z=(a,l,u)=>{const t=a[l];return t!==void 0?t:u},g=(a,l)=>{if(a.some(u=>u===0||u===void 0||isNaN(u)))throw new darknet.Error("Invalid tensor shape '"+JSON.stringify(a)+"' in '"+l+"'.");return new darknet.TensorShape(a)},T=(a,l,u)=>{const t=r?r.bytes(4*l.reduce((w,y)=>w*y)):null,o=new darknet.TensorType("float32",g(l,"load_weights")),n=new darknet.Tensor(o,t),i=new darknet.Argument("",null,n);return new darknet.Parameter(a,u!==!1,[i])},S=(a,l,u)=>{a.weights.push(T(l+"scale",[u],l==="")),a.weights.push(T(l+"mean",[u],l==="")),a.weights.push(T(l+"variance",[u],l===""))},E=(a,l,u,t,o,n,i,w,y,m,b,k)=>{a.out_w=Math.floor((u+2*b-w)/y)+1,a.out_h=Math.floor((t+2*b-w)/m)+1,a.out_c=n,a.out=a.out_w*a.out_h*a.out_c,a.weights.push(T(l+"biases",[n],l==="")),k&&S(a,l,n),a.weights.push(T(l+"weights",[Math.floor(o/i),n,w,w],l==="")),a.outputs[0].type=new darknet.TensorType("float32",g([a.out_w,a.out_h,a.out_c],"make_convolutional_layer"))},f=(a,l,u,t,o)=>{a.out_h=1,a.out_w=1,a.out_c=t,a.out=t,a.weights.push(T(l+"biases",[t],l==="")),o&&S(a,l,t),a.weights.push(T(l+"weights",[u,t],l==="")),a.outputs[0].type=new darknet.TensorType("float32",g([t],"make_connected_layer"))},e={},I=new Map,v=p.shift();switch(v.type){case"net":case"network":e.h=h(v.options,"height",0),e.w=h(v.options,"width",0),e.c=h(v.options,"channels",0),e.inputs=h(v.options,"inputs",e.h*e.w*e.c);for(const a of Object.keys(v.options))I.set(a,v.options[a])}const j=e.w&&e.h&&e.c?new darknet.TensorType("float32",g([e.w,e.h,e.c],"params-if")):new darknet.TensorType("float32",g([e.inputs],"params-else")),O="input";if(e.arguments=[new darknet.Argument(O,j,null)],this._inputs.push(new darknet.Parameter(O,!0,e.arguments)),p.length===0)throw new darknet.Error("Config file has no sections.");let x=!0;for(let a=0;a<p.length;a++){const l=p[a];l.name=a.toString(),l.chain=[],l.layer={};const u=l.options,t=l.layer;switch(t.inputs=[].concat(e.arguments),t.outputs=[new darknet.Argument(a.toString(),null,null)],t.weights=[],l.type){case"shortcut":{const o=u.from?u.from.split(",").map(n=>Number.parseInt(n.trim(),10)):[];for(let n of o){n=n<0?a+n:n;const i=p[n].layer;i&&t.inputs.push(i.outputs[0])}delete u.from;break}case"sam":case"scale_channels":{let o=h(u,"from",0);o=o<0?a+o:o;const n=p[o].layer;n&&t.inputs.push(n.outputs[0]),delete u.from;break}case"route":{t.inputs=[],t.layers=[];const o=u.layers?u.layers.split(",").map(n=>Number.parseInt(n.trim(),10)):[];for(let n=0;n<o.length;n++){const i=p[o[n]<0?a+o[n]:o[n]].layer;i&&(t.inputs.push(i.outputs[0]),t.layers.push(i))}delete u.layers;break}}if(x){switch(l.type){case"conv":case"convolutional":case"deconvolutional":{const o=t.inputs[0].type.shape.dimensions;if(o[0]!==e.w||o[1]!==e.h||o[2]!==e.c)throw new darknet.Error("Layer before convolutional layer must output image.");const n=h(u,"size",1),i=h(u,"filters",1),w=h(u,"pad",0)?n>>1:h(u,"padding",0);let y=h(u,"stride_x",-1),m=h(u,"stride_y",-1);if(y<1||m<1){const N=h(u,"stride",1);y=y<1?N:y,m=m<1?N:m}const b=h(u,"groups",1),k=h(u,"batch_normalize",0),A=z(u,"activation","logistic");E(t,"",e.w,e.h,e.c,i,b,n,y,m,w,k),A!=="logistic"&&l.chain.push({type:A});break}case"connected":{const o=h(u,"output",1),n=h(u,"batch_normalize",0),i=z(u,"activation","logistic");f(t,"",e.inputs,o,n),i!=="logistic"&&l.chain.push({type:i});break}case"local":{const o=t.inputs[0].type.shape.dimensions;if(o[0]!==e.w||o[1]!==e.h||o[2]!==e.c)throw new darknet.Error("Layer before avgpool layer must output image.");const n=h(u,"filters",1),i=h(u,"size",1),w=h(u,"stride",1),y=h(u,"pad",0),m=z(u,"activation","logistic");t.out_h=Math.floor((e.h-(y?1:i))/w)+1,t.out_w=Math.floor((e.w-(y?1:i))/w)+1,t.out_c=n,t.out=t.out_w*t.out_h*t.out_c,t.weights.push(T("weights",[e.c,n,i,i,t.out_h*t.out_w])),t.weights.push(T("biases",[t.out_w*t.out_h*t.out_c])),t.outputs[0].type=new darknet.TensorType("float32",g([t.out_w,t.out_h,t.out_c],"local")),m!=="logistic"&&l.chain.push({type:m});break}case"batchnorm":t.out_h=e.h,t.out_w=e.w,t.out_c=e.c,t.out=t.in,S(r,l,"",t.out),t.outputs[0].type=new darknet.TensorType("float32",g([t.ouputs],"batchnorm"));break;case"activation":t.out_h=e.h,t.out_w=e.w,t.out_c=e.c,t.out=t.in,t.outputs[0].type=new darknet.TensorType("float32",g([t.ouputs],"activation"));break;case"max":case"maxpool":{const o=t.inputs[0].type.shape.dimensions;if(o[0]!==e.w||o[1]!==e.h||o[2]!==e.c)throw new darknet.Error("Layer before maxpool layer must output image.");const n=h(u,"antialiasing",0),i=h(u,"stride",1),w=h(u,"stride_x",i),y=h(u,"stride_y",i),m=n?1:w,b=n?1:y,k=h(u,"size",i),A=h(u,"padding",k-1),N=h(u,"out_channels",1);if(h(u,"maxpool_depth",0)?(t.out_c=N,t.out_w=e.w,t.out_h=e.h):(t.out_w=Math.floor((e.w+A-k)/m)+1,t.out_h=Math.floor((e.h+A-k)/b)+1,t.out_c=e.c),n){const L=n===2?2:3,P=n===2?0:Math.floor(L/3);t.input_layer={weights:[],outputs:t.outputs},E(t.input_layer,"",t.out_h,t.out_w,t.out_c,t.out_c,t.out_c,L,w,y,P,0),t.out_w=t.input_layer.out_w,t.out_h=t.input_layer.out_h,t.out_c=t.input_layer.out_c}else t.outputs[0].type=new darknet.TensorType("float32",g([t.out_w,t.out_h,t.out_c],"maxpool"));t.out=t.out_w*t.out_h*t.out_c;break}case"avgpool":{const o=t.inputs[0].type.shape.dimensions;if(o[0]!==e.w||o[1]!==e.h||o[2]!==e.c)throw new darknet.Error("Layer before avgpool layer must output image.");t.out_w=1,t.out_h=1,t.out_c=e.c,t.out=t.out_c,t.outputs[0].type=new darknet.TensorType("float32",g([t.out_w,t.out_h,t.out_c],"avgpool"));break}case"crnn":{const o=h(u,"size",3),n=h(u,"stride",1),i=h(u,"output",1),w=h(u,"hidden",1),y=h(u,"groups",1),m=h(u,"pad",0)?o>>1:h(u,"padding",0),b=h(u,"batch_normalize",0);t.input_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},E(t.input_layer,"input_",e.h,e.w,e.c,w,y,o,n,n,m,b),t.self_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},E(t.self_layer,"self_",e.h,e.w,w,w,y,o,n,n,m,b),t.output_layer={weights:[],outputs:t.outputs},E(t.output_layer,"output_",e.h,e.w,w,i,y,o,n,n,m,b),t.weights=t.weights.concat(t.input_layer.weights),t.weights=t.weights.concat(t.self_layer.weights),t.weights=t.weights.concat(t.output_layer.weights),t.out_h=t.output_layer.out_h,t.out_w=t.output_layer.out_w,t.out_c=i,t.out=t.output_layer.out;break}case"rnn":{const o=h(u,"output",1),n=h(u,"hidden",1),i=h(u,"batch_normalize",0),w=e.inputs;t.input_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},f(t.input_layer,"input_",w,n,i),t.self_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},f(t.self_layer,"self_",n,n,i),t.output_layer={weights:[],outputs:t.outputs},f(t.output_layer,"output_",n,o,i),t.weights=t.weights.concat(t.input_layer.weights),t.weights=t.weights.concat(t.self_layer.weights),t.weights=t.weights.concat(t.output_layer.weights),t.out_w=1,t.out_h=1,t.out_c=o,t.out=o;break}case"gru":{const o=e.inputs,n=h(u,"output",1),i=h(u,"batch_normalize",0);t.input_z_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},f(t.input_z_layer,"input_z",o,n,i),t.state_z_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},f(t.state_z_layer,"state_z",n,n,i),t.input_r_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},f(t.input_r_layer,"input_r",o,n,i),t.state_r_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},f(t.state_r_layer,"state_r",n,n,i),t.input_h_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},f(t.input_h_layer,"input_h",o,n,i),t.state_h_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},f(t.state_h_layer,"state_h",n,n,i),t.weights=t.weights.concat(t.input_z_layer.weights),t.weights=t.weights.concat(t.state_z_layer.weights),t.weights=t.weights.concat(t.input_r_layer.weights),t.weights=t.weights.concat(t.state_r_layer.weights),t.weights=t.weights.concat(t.input_h_layer.weights),t.weights=t.weights.concat(t.state_h_layer.weights),t.out=n,t.outputs[0].type=new darknet.TensorType("float32",g([n],"gru"));break}case"lstm":{const o=e.inputs,n=h(u,"output",1),i=h(u,"batch_normalize",0);t.uf={weights:[],outputs:[new darknet.Argument("",null,null)]},f(t.uf,"uf_",o,n,i),t.ui={weights:[],outputs:[new darknet.Argument("",null,null)]},f(t.ui,"ui_",o,n,i),t.ug={weights:[],outputs:[new darknet.Argument("",null,null)]},f(t.ug,"ug_",o,n,i),t.uo={weights:[],outputs:[new darknet.Argument("",null,null)]},f(t.uo,"uo_",o,n,i),t.wf={weights:[],outputs:[new darknet.Argument("",null,null)]},f(t.wf,"wf_",n,n,i),t.wi={weights:[],outputs:[new darknet.Argument("",null,null)]},f(t.wi,"wi_",n,n,i),t.wg={weights:[],outputs:[new darknet.Argument("",null,null)]},f(t.wg,"wg_",n,n,i),t.wo={weights:[],outputs:[new darknet.Argument("",null,null)]},f(t.wo,"wo_",n,n,i),t.weights=t.weights.concat(t.uf.weights),t.weights=t.weights.concat(t.ui.weights),t.weights=t.weights.concat(t.ug.weights),t.weights=t.weights.concat(t.uo.weights),t.weights=t.weights.concat(t.wf.weights),t.weights=t.weights.concat(t.wi.weights),t.weights=t.weights.concat(t.wg.weights),t.weights=t.weights.concat(t.wo.weights),t.out_w=1,t.out_h=1,t.out_c=n,t.out=n,t.outputs[0].type=new darknet.TensorType("float32",g([n],"lstm")),r=null;break}case"softmax":t.out_w=e.w,t.out_h=e.h,t.out_c=e.c,t.out=e.inputs,t.outputs[0].type=new darknet.TensorType("float32",g([t.out],"softmax"));break;case"dropout":t.out_w=e.w,t.out_h=e.h,t.out_c=e.c,t.out=e.inputs,t.outputs[0].type=new darknet.TensorType("float32",g([t.out_w,t.out_h,t.out_c],"dropout"));break;case"upsample":{const o=h(u,"stride",2);t.out_w=e.w*o,t.out_h=e.h*o,t.out_c=e.c,t.out=t.out_w*t.out_h*t.out_c,t.outputs[0].type=new darknet.TensorType("float32",g([t.out_w,t.out_h,t.out_c],"upsample"));break}case"crop":{const o=t.inputs[0].type.shape.dimensions;if(o[0]!==e.w||o[1]!==e.h||o[2]!==e.c)throw new darknet.Error("Layer before crop layer must output image.");const n=h(u,"crop_height",1),i=h(u,"crop_width",1);t.out_w=i,t.out_h=n,t.out_c=e.c,t.out=t.out_w*t.out_h*t.out_c,t.outputs[0].type=new darknet.TensorType("float32",g([t.out_w,t.out_h,t.out_c],"crop"));break}case"yolo":{const o=h(u,"classes",20),n=h(u,"num",1);t.out_h=e.h,t.out_w=e.w,t.out_c=n*(o+4+1),t.out=t.out_h*t.out_w*t.out_c,t.outputs[0].type=new darknet.TensorType("float32",g([t.out_w,t.out_h,t.out_c],"yolo"));break}case"Gaussian_yolo":{const o=h(u,"classes",20),n=h(u,"num",1);t.out_h=e.h,t.out_w=e.w,t.out_c=n*(o+8+1),t.out=t.out_h*t.out_w*t.out_c,t.outputs[0].type=new darknet.TensorType("float32",g([t.out_w,t.out_h,t.out_c],"Gaussian_yolo"));break}case"region":{const o=h(u,"coords",4),n=h(u,"classes",20),i=h(u,"num",1);t.out=e.h*e.w*i*(n+o+1),t.outputs[0].type=new darknet.TensorType("float32",g([e.h,e.w,i,n+o+1],"region"));break}case"cost":t.out=e.inputs,t.outputs[0].type=new darknet.TensorType("float32",g([t.out],"cost"));break;case"reorg":{const o=h(u,"stride",1),n=h(u,"reverse",0),i=h(u,"extra",0);n?(t.out_w=e.w*o,t.out_h=e.h*o,t.out_c=Math.floor(e.c/(o*o))):(t.out_w=Math.floor(e.w/o),t.out_h=Math.floor(e.h/o),t.out_c=e.c*(o*o)),t.out=t.out_h*t.out_w*t.out_c,i&&(t.out_w=0,t.out_h=0,t.out_c=0,t.out=e.h*e.w*e.c+i),t.outputs[0].type=new darknet.TensorType("float32",g([t.out],"reorg"));break}case"route":{const o=[].concat(t.layers),n=h(u,"groups",1);t.out=0;for(const i of o)t.out+=i.outputs/n;if(o.length>0){const i=o.shift();for(t.out_w=i.out_w,t.out_h=i.out_h,t.out_c=i.out_c/n;o.length>0;){const w=o.shift();if(w.out_w!==i.out_w||w.out_h!==i.out_h){x=!1;break}t.out_c+=w.out_c}x&&(t.outputs[0].type=new darknet.TensorType("float32",g([t.out_w,t.out_h,t.out_c],"route")))}else x=!1;x||(t.out_h=0,t.out_w=0,t.out_c=0);break}case"shortcut":case"scale_channels":case"sam":{const o=z(u,"activation","linear");t.out_w=e.w,t.out_h=e.h,t.out_c=e.c,t.out=e.w*e.h*e.c,t.outputs[0].type=new darknet.TensorType("float32",g([e.w,e.h,e.c],"shortcut|scale_channels|sam")),o!=="linear"&&l.chain.push({type:o});break}case"detection":t.out_w=e.w,t.out_h=e.h,t.out_c=e.c,t.out=e.inputs,t.outputs[0].type=new darknet.TensorType("float32",g([t.out],"detection"));break;default:x=!1}e.h=t.out_h,e.w=t.out_w,e.c=t.out_c,e.inputs=t.out,e.last=l}e.arguments=t.outputs}for(let a=0;a<p.length;a++)this._nodes.push(new darknet.Node(s,v,p[a]));r&&r.validate()}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}},darknet.Parameter=class{constructor(s,c,r){this._name=s,this._visible=c,this._arguments=r}get name(){return this._name}get visible(){return this._visible}get arguments(){return this._arguments}},darknet.Argument=class{constructor(s,c,r){if(typeof s!="string")throw new darknet.Error("Invalid argument identifier '"+JSON.stringify(s)+"'.");this._name=s,this._type=c,this._initializer=r}get name(){return this._name}get type(){return this._initializer?this._initializer.type:this._type}set type(s){if(this._type)throw new darknet.Error("Invalid argument type set operation.");this._type=s}get initializer(){return this._initializer}},darknet.Node=class{constructor(s,c,r){this._name=r.name||"",this._location=r.line!==void 0?r.line.toString():void 0,this._metadata=s,this._type=r.type,this._attributes=[],this._inputs=[],this._outputs=[],this._chain=[];const p=r.layer;if(p&&p.inputs&&p.inputs.length>0&&this._inputs.push(new darknet.Parameter(p.inputs.length<=1?"input":"inputs",!0,p.inputs)),p&&p.weights&&p.weights.length>0&&(this._inputs=this._inputs.concat(p.weights)),p&&p.outputs&&p.outputs.length>0&&this._outputs.push(new darknet.Parameter(p.outputs.length<=1?"output":"outputs",!0,p.outputs)),r.chain)for(const d of r.chain)this._chain.push(new darknet.Node(s,c,d,""));const _=r.options;if(_)for(const d of Object.keys(_))this._attributes.push(new darknet.Attribute(s.attribute(this._type,d),d,_[d]))}get name(){return this._name}get location(){return this._location}get type(){return this._type}get metadata(){return this._metadata.type(this._type)}get attributes(){return this._attributes}get inputs(){return this._inputs}get outputs(){return this._outputs}get chain(){return this._chain}},darknet.Attribute=class{constructor(s,c,r){if(this._name=c,this._value=r,s){switch(this._type=s.type||"",this._type){case"int32":{const p=parseInt(this._value,10);Number.isInteger(p)&&(this._value=p);break}case"float32":{const p=parseFloat(this._value);isNaN(p)||(this._value=p);break}case"int32[]":{const p=this._value.split(",").map(_=>parseInt(_.trim(),10));p.every(_=>Number.isInteger(_))&&(this._value=p);break}}(Object.prototype.hasOwnProperty.call(s,"visible")&&!s.visible||Object.prototype.hasOwnProperty.call(s,"default")&&this._value==s.default)&&(this._visible=!1)}}get name(){return this._name}get type(){return this._type}get value(){return this._value}get visible(){return this._visible!=0}},darknet.Tensor=class{constructor(s,c){this._type=s,this._data=c}get kind(){return"Tensor"}get name(){return""}get type(){return this._type}get state(){return this._context().state}get value(){const s=this._context();return s.state?null:(s.limit=Number.MAX_SAFE_INTEGER,this._decode(s,0))}toString(){const s=this._context();if(s.state)return"";s.limit=1e4;const c=this._decode(s,0);return JSON.stringify(c,null,4)}_context(){const s={};return this._data?(s.state=null,s.position=0,s.count=0,s.dataView=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength),s.dimensions=this.type.shape.dimensions,s):(s.state="Tensor data is empty.",s)}_decode(s,c){const r=[],p=s.dimensions[c];if(c==s.dimensions.length-1)for(let _=0;_<p;_++){if(s.count>s.limit)return r.push("..."),r;r.push(s.dataView.getFloat32(s.position,!0)),s.position+=4,s.count++}else for(let _=0;_<p;_++){if(s.count>s.limit)return r.push("..."),r;r.push(this._decode(s,c+1))}return r}},darknet.TensorType=class{constructor(s,c){this._dataType=s,this._shape=c}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return(this._dataType||"?")+this._shape.toString()}},darknet.TensorShape=class{constructor(s){if(s.some(c=>c===0||c===void 0||isNaN(c)))throw new darknet.Error("Invalid tensor shape '"+JSON.stringify(s)+"'.");this._dimensions=s}get dimensions(){return this._dimensions}toString(){return this._dimensions?this._dimensions.length==0?"":"["+this._dimensions.map(s=>s.toString()).join(",")+"]":""}},darknet.Weights=class{constructor(s){this._buffer=s,this._dataView=new DataView(s.buffer,s.byteOffset,s.byteLength),this._position=0;const c=this.int32(),r=this.int32(),p=this.int32();if(this._seen=10*c+r>=2?this.int64():this.int32(),c>1e3||r>1e3)throw new darknet.Error("Unsupported transpose weights file version '"+[c,r,p].join(".")+"'.")}int32(){const s=this._position;return this.skip(4),this._dataView.getInt32(s,!0)}int64(){const s=this.int32(),c=this.int32();return new long.Long(s,c,!0).toNumber()}bytes(s){const c=this._position;return this.skip(s),this._buffer.subarray(c,this._position)}skip(s){if(this._position+=s,this._position>this._buffer.length)throw new darknet.Error("Expected "+(this._position-this._buffer.length)+" more bytes. The file might be corrupted. Unexpected end of file.")}validate(){if(this._position!==this._buffer.length)throw new darknet.Error("Invalid weights size.")}},darknet.Metadata=class{static open(s){return darknet.Metadata._metadata?Promise.resolve(darknet.Metadata._metadata):s.request(null,"darknet-metadata.json","utf-8").then(c=>(darknet.Metadata._metadata=new darknet.Metadata(c),darknet.Metadata._metadata)).catch(()=>(darknet.Metadata._metadata=new darknet.Metadata(null),darknet.Metadata._metadata))}constructor(s){if(this._map=new Map,this._attributeMap=new Map,s){const c=JSON.parse(s);if(c){for(const r of c)if(r&&r.name&&r.schema){if(this._map.has(r.name))throw new darknet.Error("Duplicate metadata key '"+r.name+"'.");r.schema.name=r.name,this._map.set(r.name,r.schema)}}}}type(s){return this._map.get(s)||null}attribute(s,c){const r=s+":"+c;if(!this._attributeMap.has(r)){this._attributeMap.set(r,null);const p=this.type(s);if(p&&p.attributes)for(const _ of p.attributes)this._attributeMap.set(s+":"+_.name,_)}return this._attributeMap.get(r)}},darknet.Error=class extends Error{constructor(s){super(s),this.name="Error loading Darknet model."}},typeof module!="undefined"&&typeof module.exports=="object"&&(module.exports.ModelFactory=darknet.ModelFactory);
