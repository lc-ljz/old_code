var openvino=openvino||{},base=base||require("./base"),long=long||{Long:require("long")};openvino.ModelFactory=class{match(t){const i=t.identifier,n=i.split(".").pop().toLowerCase();if(n==="xml"&&t.text.includes("<net"))return!0;if(n==="bin"){switch(i){case"natives_blob.bin":case"snapshot_blob.bin":case"v8_context_snapshot.bin":return!1}const s=t.buffer,r=[33,168,239,190,173,222];if(s&&s.length>6&&r.every((e,a)=>e==s[a]))return!1;if(s.length>4){const e=s[0]|s[1]<<8|s[2]<<16|s[3]<<24;if(e===0||e===1||e===19950407||e===871224||e===180310)return!1}return!0}return!1}open(t,i){const n=t.identifier;switch(n.split(".").pop().toLowerCase()){case"xml":return t.request(n.substring(0,n.length-4)+".bin",null).then(s=>this._openModel(n,i,t.text,s)).catch(()=>this._openModel(n,i,t.text,null));case"bin":return t.request(n.substring(0,n.length-4)+".xml","utf-8").then(s=>this._openModel(n,i,s,t.buffer)).catch(s=>{i.exception(s,!1);const r=s&&s.message?s.message:s.toString();throw new openvino.Error(r.replace(/\.$/,"")+" in '"+n+"'.")})}}_openModel(t,i,n,s){return openvino.Metadata.open(i).then(r=>{try{let e=!1;const a=new DOMParser({errorHandler:()=>{e=!0}}).parseFromString(n,"text/xml");if(e||a.documentElement==null||a.getElementsByTagName("parsererror").length>0)throw new openvino.Error("File format is not OpenVINO.");if(!a.documentElement||a.documentElement.nodeName!="net")throw new openvino.Error("File format is not OpenVINO IR.");const u=openvino.XmlReader.read(a.documentElement),o=new openvino.Model(r,u,s);return u.disconnectedLayers&&i.exception(new openvino.Error("Graph contains not connected layers "+JSON.stringify(u.disconnectedLayers)+" in '"+t+"'.")),o}catch(e){i.exception(e,!1);const a=e&&e.message?e.message:e.toString();throw new openvino.Error(a.replace(/\.$/,"")+" in '"+t+"'.")}})}},openvino.Model=class{constructor(t,i,n){this._name=i.name||"",this._graphs=[new openvino.Graph(t,i,n)]}get name(){return this._name}get format(){return"OpenVINO IR"}get graphs(){return this._graphs}},openvino.Graph=class{constructor(t,i,n){this._name=i.name||"",this._nodes=[],this._inputs=[],this._outputs=[],this._arguments={};for(const e of this._const(i.layers,i.edges)){const a=e.inputs.map(o=>this._argument(e.id,e.precision,o,i.edges)),u=e.outputs.map(o=>this._argument(e.id,o.precision||e.precision,o,null));switch(e.type){case"Input":{const o=e.name||"";this._inputs.push(new openvino.Parameter(o,u));break}default:this._nodes.push(new openvino.Node(this,t,n,e,a,u))}}this._replaceTensorIteratorWithSubgraph(t,n,i.layers,i.edges),delete this._arguments;const s=new Set;for(const e of this._nodes)for(const a of e.outputs)for(const u of a.arguments)s.add(u.name);for(const e of this.inputs)for(const a of e.arguments)s.add(a.name);const r=new Set;for(const e of this._nodes)for(const a of e.inputs)for(const u of a.arguments)u.initializer||s.has(u.name)||r.add(e);r.size!==0&&(i.disconnectedLayers=Array.from(r).map(e=>e.name))}get name(){return this._name}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}_argument(t,i,n,s){let r=t+":"+n.id;s&&(r=s[r]);let e=this._arguments[r];if(!e){const a=n.dims.length==0?null:new openvino.TensorShape(n.dims);e=new openvino.Argument(r,new openvino.TensorType(i,a),null)}return e}_replaceTensorIteratorWithSubgraph(t,i,n,s){const r=n.filter(e=>e.type==="TensorIterator");for(const e of r){const a=e.id,u=this._nodes.find(c=>c._id===a),o=e.body.layers,p=e.body.edges,l=e.back_edges,h=Object.assign({},p,l),d=e.port_map;for(const c of this._const(o,h,l)){const _=c.inputs.map(g=>this._argument(c.id,c.precision,g,h)),f=c.outputs.map(g=>this._argument(c.id,c.precision||g.precision,g,null)),w=new openvino.Node(this,t,i,c,_,f);w._id=a+"_"+c.id;for(const g of w._inputs)for(const y of g.arguments)y.name&&(y._name=a+"_"+y.name);for(const g of w._outputs)for(const y of g.arguments)y.name&&(y._name=a+"_"+y.name);this._nodes.push(w)}for(const c of d.input){const _=this._nodes.find(w=>w._id===a+"_"+c.internal_layer_id),f=s[a+":"+c.external_port_id];if(f){const w=f.split(":"),g=w[0],y=w[1];if(this._nodes.find(b=>b._id===g)){if(!_._inputs)throw new openvino.Error("Tensor Iterator node with name '"+_._id+"' does not have inputs.");const b=g+":"+y,k=_._inputs.find(m=>Boolean(m.arguments.find(x=>!x.name)));if(k){const m=k._arguments.find(x=>!x._name);m&&(m._name=b)}else _._inputs.push(new openvino.Parameter((_._inputs.length+1).toString(),[new openvino.Argument(b,null,null)]))}else{const b=u._inputs.find(m=>m._name==="input");if(!b)return;const k=_._inputs.find(m=>Boolean(m.arguments.find(x=>!x.name)));if(k){const m=k.arguments.find(x=>!x.name);m&&(m._name=b.arguments[0].name)}}}}for(const c of d.output){const _=this._nodes.find(g=>g._id===`${a}_${c.internal_layer_id}`),f=a+":"+c.external_port_id,w=Object.keys(s).filter(g=>s[g]===f);for(const g of w){const y=g.split(":")[0],b=this._nodes.find(k=>k._id===y);if(b._inputs&&(!b._inputs||b._inputs.length!==0)&&_._outputs&&_._outputs[0])for(const k of b._inputs)for(const m of k._arguments){if(!m.name||m.name&&m.name.split(":")[0]!==a)continue;const x=_.outputs[0].arguments[0].name.split(":")[1];m._name=_.id+":"+x}}}this._nodes=this._nodes.filter(c=>c.id!==e.id)}}_const(t,i,n){const s=[];n=n||{},t=t.slice();for(const e of t){if(e.type==="Const"&&e.inputs.length===0&&e.outputs.length===1&&e.blobs.length===0&&e.data&&e.data.length>3){const a={};for(const u of e.data)a[u.name]=u.value;if(a.element_type&&a.offset&&a.size){const u=a.element_type;let o=null;switch(u){case"f16":o="FP16";break;case"f32":o="FP32";break;default:o=u.toUpperCase()}const p=a.shape?a.shape.split(",").map(l=>parseInt(l.trim(),10)):null;e.data=[],e.blobs.push({name:"custom",precision:o,offset:parseInt(a.offset,10),size:parseInt(a.size,10),shape:p})}}e.type==="Const"&&e.blobs.length===1&&!e.blobs[0].shape&&e.inputs.length===0&&e.outputs.length===1&&e.outputs[0].dims&&(e.blobs[0].shape=e.outputs[0].dims)}const r=new Map;for(const e of t)if(e.type==="Const"&&e.inputs.length===0&&e.outputs.length===1){const a=e.id+":"+e.outputs[0].id;r.set(a,{layer:e,counter:0})}for(const e of Object.keys(i)){const a=i[e];r.has(a)&&r.get(a).counter++}if(n)for(const e of Object.keys(n)){const a=n[e];r.has(a)&&r.get(a).counter++}for(const e of r)e[1].counter!==1&&r.delete(e[0]);for(const e of t)if(e.blobs.length===0)for(let a=e.inputs.length-1;a>0;a--){const u=e.inputs[a],o=e.id+":"+u.id,p=i[o]||n[o];if(!r.has(p))break;const l=r.get(p).layer,h=l.blobs[0];h&&(h.id=l.name||l.id,h.kind="Const",e.blobs.push(h),e.inputs.splice(a,1),r.get(p).layer=null,r.get(p).delete=!0)}for(;t.length>0;){const e=t.shift();if(e.type==="Const"&&e.inputs.length===0&&e.outputs.length===1){const a=e.id+":"+e.outputs[0].id;if(r.has(a)&&r.get(a).delete)continue}s.push(e)}return s}},openvino.Node=class{constructor(t,i,n,s,r,e){this._metadata=i,this._type=s.type,this._name=s.name||"",this._id=s.id,this._inputs=[],this._outputs=[],this._initializers=[],this._attributes=[];const a=s.precision;let u=0;for(const l of r){const h=u==0?"input":u.toString();this._inputs.push(new openvino.Parameter(h,[l])),u++}let o=0;for(const l of e){const h=o==0?"output":o.toString();this._outputs.push(new openvino.Parameter(h,[l])),o++}const p={};for(const l of s.data){p[l.name]=l.value;const h=i.attribute(this.type,l.name);this._attributes.push(new openvino.Attribute(h,l.name,l.value))}for(const l of s.blobs){const h=l.name,d=l.offset,c=l.size,_=n&&d+c<=n.length?n.slice(d,d+c):null;let f=l.shape||null;const w=l.kind||"Blob",g=l.id||"",y=l.precision||a,b={FP16:2,FP32:4,I8:1,I16:2,I32:4,I64:8,U8:1,U16:2,U32:4,U64:8}[y];if(b)switch(this._type+":"+h){case"FullyConnected:weights":{const m=parseInt(p["out-size"],10);f=[c/(m*b),m];break}case"FullyConnected:biases":f=[parseInt(p["out-size"],10)];break;case"Convolution:weights":case"Deconvolution:weights":{const m=this.inputs[0].arguments[0].type.shape.dimensions[1],x=parseInt(p.group||"1",10),v=p["kernel-x"]&&p["kernel-y"]?[parseInt(p["kernel-x"],10),parseInt(p["kernel-y"],10)]:p.kernel.split(",").map(N=>parseInt(N.trim(),10)),T=parseInt(p.output,10);f=[Math.floor(m/x),T].concat(v);break}case"ScaleShift:weights":case"ScaleShift:biases":case"Convolution:biases":case"Normalize:weights":case"PReLU:weights":f=[Math.floor(c/b)];break;case"Const:custom":this._outputs.length>0&&this._outputs[0].arguments.length>0&&this._outputs[0].arguments[0].type&&this._outputs[0].arguments[0].type.shape&&this._outputs[0].arguments[0].type.shape.dimensions&&(f=this._outputs[0].arguments[0].type.shape.dimensions)}const k=f?new openvino.TensorShape(f):null;this._initializers.push(new openvino.Parameter(h,[new openvino.Argument(g,null,new openvino.Tensor(y,k,_,w))]))}}get id(){return this._id}get name(){return this._name}get device(){return this._device||""}get type(){return this._type}get metadata(){return this._metadata.type(this._type)}get attributes(){return this._attributes}get inputs(){return this._inputs.concat(this._initializers)}get outputs(){return this._outputs}},openvino.Parameter=class{constructor(t,i){this._name=t,this._arguments=i}get name(){return this._name}get visible(){return!0}get arguments(){return this._arguments}},openvino.Argument=class{constructor(t,i,n){this._name=t,this._type=i||null,this._initializer=n||null}get name(){return this._name}get type(){return this._initializer?this._initializer.type:this._type}get initializer(){return this._initializer}},openvino.Attribute=class{constructor(t,i,n){if(this._name=i,this._value=n,t){if(Object.prototype.hasOwnProperty.call(t,"type"))switch(this._type=t.type,t.type){case"boolean":switch(n){case"1":case"true":this._value=!0;break;case"0":case"false":this._value=!1}break;case"int32":{const s=Number.parseInt(this._value,10);this._value=Number.isNaN(this._value-s)?n:s;break}case"float32":case"float64":{const s=Number.parseFloat(this._value);this._value=Number.isNaN(this._value-s)?n:s;break}case"int32[]":if(this._value.length>2){let s=[];this._value.split(",").map(r=>{r=r.trim();const e=Number.parseInt(r,10);Number.isNaN(r-e)?s=null:s!=null&&s.push(e)}),s!=null&&(this._value=s)}break;case"float32[]":if(this._value.length>2){let s=[];this._value.split(",").map(r=>{r=r.trim();const e=Number.parseFloat(r);Number.isNaN(r-e)?s=null:s!=null&&s.push(e)}),s!=null&&(this._value=s)}}if(Object.prototype.hasOwnProperty.call(t,"visible")&&t.visible==0)this._visible=!1;else if(Object.prototype.hasOwnProperty.call(t,"default")){let s=t.default;if(this._value==s)this._visible=!1;else if(Array.isArray(this._value)&&Array.isArray(s)){if(s=s.slice(0,s.length),s.length>1&&s[s.length-1]==null)for(s.pop();s.length<this._value.length;)s.push(s[s.length-1]);this._value.every((r,e)=>r==s[e])&&(this._visible=!1)}}}}get name(){return this._name}get value(){return this._value}get type(){return this._type}get visible(){return this._visible!=0}},openvino.Tensor=class{constructor(t,i,n,s){this._data=n,this._type=new openvino.TensorType(t,i),this._kind=s}get kind(){return this._kind}get type(){return this._type}get state(){return this._context().state}get value(){const t=this._context();return t.state?null:(t.limit=Number.MAX_SAFE_INTEGER,this._decode(t,0))}toString(){const t=this._context();if(t.state)return"";t.limit=1e4;const i=this._decode(t,0);return openvino.Tensor._stringify(i,"","    ")}_context(){const t={state:null};return this._data?this._type.shape?(t.index=0,t.count=0,t.data=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength),t.dataType=this._type.dataType,t.shape=this._type.shape.dimensions,t):(t.state="Tensor shape is not defined.",t):(t.state="Tensor data is empty.",t)}_decode(t,i){const n=t.shape.length==0?[1]:t.shape,s=[],r=n[i];if(i==n.length-1)for(let e=0;e<r;e++){if(t.count>t.limit)return s.push("..."),s;switch(this._type.dataType){case"float32":s.push(t.data.getFloat32(t.index,!0)),t.index+=4,t.count++;break;case"float16":s.push(t.data.getFloat16(t.index,!0)),t.index+=2,t.count++;break;case"int8":s.push(t.data.getInt8(t.index)),t.index+=1,t.count++;break;case"int16":s.push(t.data.getInt16(t.index,!0)),t.index+=2,t.count++;break;case"int32":s.push(t.data.getInt32(t.index,!0)),t.index+=4,t.count++;break;case"int64":s.push(new long.Long(t.data.getUint32(t.index,!0),t.data.getUint32(t.index+4,!0),!1)),t.index+=8,t.count++;break;case"uint8":s.push(t.data.getUint8(t.index)),t.index+=1,t.count++;break;case"uint16":s.push(t.data.getUint16(t.index,!0)),t.index+=2,t.count++;break;case"uint32":s.push(t.data.getUint32(t.index,!0)),t.index+=4,t.count++;break;case"uint64":s.push(new long.Long(t.data.getUint32(t.index,!0),t.data.getUint32(t.index+4,!0),!0)),t.index+=8,t.count++}}else for(let e=0;e<r;e++){if(t.count>t.limit)return s.push("..."),s;s.push(this._decode(t,i+1))}return t.shape.length==0?s[0]:s}static _stringify(t,i,n){if(Array.isArray(t)){const s=[];s.push(i+"[");const r=t.map(e=>openvino.Tensor._stringify(e,i+n,n));return r.length>0&&s.push(r.join(`,
`)),s.push(i+"]"),s.join(`
`)}return typeof t=="string"?i+t:t==1/0?i+"Infinity":t==-1/0?i+"-Infinity":isNaN(t)?i+"NaN":i+t.toString()}},openvino.TensorType=class{constructor(t,i){switch(t=t&&t.toLowerCase()){case"f16":case"fp16":this._dataType="float16";break;case"f32":case"fp32":this._dataType="float32";break;case"i8":this._dataType="int8";break;case"i16":this._dataType="int16";break;case"i32":this._dataType="int32";break;case"i64":this._dataType="int64";break;case"u1":this._dataType="boolean";break;case"u8":this._dataType="uint8";break;case"u16":this._dataType="uint16";break;case"u32":this._dataType="uint32";break;case"u64":this._dataType="uint64";break;case"bool":this._dataType="boolean";break;case"":case null:this._dataType="?";break;default:throw new openvino.Error("Unknown precision '"+JSON.stringify(t)+"'.")}this._shape=i}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return this._shape==null?this.dataType+"[?]":this.dataType+this._shape.toString()}},openvino.TensorShape=class{constructor(t){this._dimensions=t}get dimensions(){return this._dimensions}toString(){return this._dimensions&&this._dimensions.length!=0?"["+this._dimensions.join(",")+"]":""}},openvino.Metadata=class{static open(t){return openvino.Metadata._metadata?Promise.resolve(openvino.Metadata._metadata):t.request(null,"openvino-metadata.json","utf-8").then(i=>(openvino.Metadata._metadata=new openvino.Metadata(i),openvino.Metadata._metadata)).catch(()=>(openvino.Metadata._metadata=new openvino.Metadata(null),openvino.Metadata._metadata))}constructor(t){if(this._map=new Map,this._attributeMap=new Map,t){const i=JSON.parse(t);if(i){for(const n of i)if(n&&n.name&&n.schema){if(this._map.has(n.name))throw new openvino.Error("Duplicate metadata key '"+n.name+"'.");n.schema.name=n.name,this._map.set(n.name,n.schema)}}}}type(t){return this._map.get(t)||null}attribute(t,i){const n=t+":"+i;if(!this._attributeMap.has(n)){this._attributeMap.set(n,null);const s=this.type(t);if(s&&s.attributes)for(const r of s.attributes)this._attributeMap.set(t+":"+r.name,r)}return this._attributeMap.get(n)}},openvino.XmlReader=class{static read(t){const i=(a,u)=>{const o=[];let p=a.firstChild;for(;p!=null;)p.nodeType==1&&p.nodeName==u&&o.push(p),p=p.nextSibling;return o},n=(a,u)=>{const o=i(a,u);if(o.length>1)throw new openvino.Error("Element '"+a.nodeName+"' has multiple '"+u+"' elements.");return o.length>0?o[0]:null},s=(a,u)=>{const o=n(a,u);return o?i(o,"port").map(p=>({id:p.getAttribute("id"),precision:p.getAttribute("precision"),dims:Array.prototype.slice.call(p.getElementsByTagName("dim")).map(l=>parseInt(l.textContent.trim(),10))})):[]},r=a=>{const u=n(a,"layers");return u?i(u,"layer").map(o=>{const p=n(o,"data"),l=n(o,"blobs"),h={id:o.getAttribute("id"),name:o.getAttribute("name"),type:o.getAttribute("type"),precision:o.getAttribute("precision"),data:p?Array.from(p.attributes).map(d=>({name:d.name,value:d.value})):[],blobs:l?Array.from(l.childNodes).filter(d=>d.nodeType===1).map(d=>({name:d.nodeName,precision:d.getAttribute("precision"),offset:parseInt(d.getAttribute("offset"),10),size:parseInt(d.getAttribute("size"),10)})):[],inputs:s(o,"input"),outputs:s(o,"output")};if(h.type==="TensorIterator"){h.back_edges=e(o,"back_edges");const d=n(o,"body");d&&(h.body={layers:r(d),edges:e(d)});const c=n(o,"port_map");if(c){h.port_map={input:[],output:[]};for(const _ of Array.from(c.childNodes).filter(f=>f.nodeType===1)){const f={axis:_.getAttribute("axis"),external_port_id:_.getAttribute("external_port_id"),internal_layer_id:_.getAttribute("internal_layer_id"),internal_port_id:_.getAttribute("internal_port_id")};switch(_.nodeName){case"input":h.port_map.input.push(f);break;case"output":h.port_map.output.push(f)}}}}return h}):[]},e=(a,u)=>{const o={},p=n(a,u||"edges");if(p)for(const l of i(p,"edge")){const h=l.getAttribute("from-layer"),d=l.getAttribute("from-port");o[l.getAttribute("to-layer")+":"+l.getAttribute("to-port")]=h+":"+d}return o};return{name:t.getAttribute("name"),batch:t.getAttribute("batch"),version:t.getAttribute("version"),layers:r(t),edges:e(t)}}},openvino.Error=class extends Error{constructor(t){super(t),this.name="Error loading OpenVINO model."}},typeof module!="undefined"&&typeof module.exports=="object"&&(module.exports.ModelFactory=openvino.ModelFactory);
