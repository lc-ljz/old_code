var coreml=coreml||{},base=base||require("./base"),long=long||{Long:require("long")},protobuf=protobuf||require("./protobuf");coreml.ModelFactory=class{match(t){return t.identifier.split(".").pop().toLowerCase()=="mlmodel"}open(t,e){return e.require("./coreml-proto").then(()=>{const i=t.identifier;let r=null;try{coreml.proto=protobuf.get("coreml").CoreML.Specification;const s=protobuf.Reader.create(t.buffer);r=coreml.proto.Model.decode(s)}catch(s){throw new coreml.Error("File format is not coreml.Model ("+s.message+") in '"+i+"'.")}return coreml.Metadata.open(e).then(s=>{try{return new coreml.Model(s,r)}catch(a){e.exception(a,!1);const n=a&&a.message?a.message:a.toString();throw new coreml.Error(n.replace(/\.$/,"")+" in '"+i+"'.")}})})}},coreml.Model=class{constructor(t,e){if(this._specificationVersion=e.specificationVersion,this._graphs=[new coreml.Graph(t,e)],e.description&&e.description.metadata){const i=e.description.metadata;i.versionString&&(this._version=i.versionString),i.author&&(this._author=i.author),i.shortDescription&&(this._description=i.shortDescription),i.license&&(this._license=i.license),t.userDefined&&Object.keys(i.userDefined).length}}get format(){return"Core ML v"+this._specificationVersion.toString()}get version(){return this._version||null}get description(){return this._description||null}get author(){return this._author||null}get license(){return this._license||null}get graphs(){return this._graphs}},coreml.Graph=class{constructor(t,e){this._metadata=t,this._description=e.description,this._groups=!1,this._inputs=[],this._outputs=[],this._nodes=[],this._description&&(this._inputs=this._description.input.map(i=>{const r=new coreml.Argument(i.name,coreml.Graph._formatFeatureType(i.type),i.shortDescription,null);return new coreml.Parameter(i.name,!0,[r])}),this._outputs=this._description.output.map(i=>{const r=new coreml.Argument(i.name,coreml.Graph._formatFeatureType(i.type),i.shortDescription,null);return new coreml.Parameter(i.name,!0,[r])})),this._type=this._loadModel(e,{},"")}get name(){return""}get type(){return this._type}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}get groups(){return this._groups}_updateOutput(t,e){for(const i of this._nodes)for(const r of i.outputs)for(const s of r.arguments)s.name===t&&(s.name=e);return e}_updateClassifierOutput(t,e){let i=e.labelProbabilityLayerName;if(!i&&this._nodes.length>0){const a=this._nodes.slice(-1).pop();a&&a.outputs.length==1&&a.outputs[0].arguments.length==1&&(i=a.outputs[0].arguments[0].name)}let r=this._description.predictedFeatureName,s=this._description.predictedProbabilitiesName;if((r||s)&&i&&e.ClassLabels){r=r||"?",s=s||"?";const a=this._updateOutput(i,i+":labelProbabilityLayerName"),n=e.ClassLabels;this._nodes.push(new coreml.Node(this._metadata,this._group,n,null,"",e[n],[a],[s,r]))}}_updatePreprocessing(t,e,i){if(i&&i.length>0){const r=this._description.input[0].name,s=[];for(const o of this._nodes)o.inputs.some(p=>p.arguments.some(u=>u.name==r))&&s.push(o);let a=r,n=0;for(const o of i){const p=o.featureName?o.featureName:a;a=r+":"+n.toString(),this._createNode(t,e,o.preprocessor,null,"",o[o.preprocessor],[p],[a]),n++}for(const o of s)for(const p of o.inputs)for(const u of p.arguments)u.name===r&&(u.name=a)}}_loadModel(t,e,i){this._groups=this._groups|i.length>0;const r=t&&t.description&&t.description.metadata&&t.description.metadata.shortDescription?t.description.metadata.shortDescription:"";switch(t.Type){case"neuralNetworkClassifier":{const s=t.neuralNetworkClassifier;for(const a of s.layers)this._createNode(e,i,a.layer,a.name,r,a[a.layer],a.input,a.output);return this._updateClassifierOutput(i,s),this._updatePreprocessing(e,i,s.preprocessing),"Neural Network Classifier"}case"neuralNetwork":{const s=t.neuralNetwork;for(const a of s.layers)this._createNode(e,i,a.layer,a.name,r,a[a.layer],a.input,a.output);return this._updatePreprocessing(e,i,s.preprocessing),"Neural Network"}case"neuralNetworkRegressor":{const s=t.neuralNetworkRegressor;for(const a of s.layers)this._createNode(e,i,a.layer,a.name,r,a[a.layer],a.input,a.output);return this._updatePreprocessing(e,i,s),"Neural Network Regressor"}case"pipeline":for(let s=0;s<t.pipeline.models.length;s++)this._loadModel(t.pipeline.models[s],e,(i?i+"/":"")+"pipeline["+s.toString()+"]");return"Pipeline";case"pipelineClassifier":for(let s=0;s<t.pipelineClassifier.pipeline.models.length;s++)this._loadModel(t.pipelineClassifier.pipeline.models[s],e,(i?i+"/":"")+"pipelineClassifier["+s.toString()+"]");return"Pipeline Classifier";case"pipelineRegressor":for(let s=0;s<t.pipelineRegressor.pipeline.models.length;s++)this._loadModel(t.pipelineRegressor.pipeline.models[s],e,(i?i+"/":"")+"pipelineRegressor["+s.toString()+"]");return"Pipeline Regressor";case"glmClassifier":return this._createNode(e,i,"glmClassifier",null,r,{classEncoding:t.glmClassifier.classEncoding,offset:t.glmClassifier.offset,weights:t.glmClassifier.weights},[t.description.input[0].name],[t.description.predictedProbabilitiesName]),this._updateClassifierOutput(i,t.glmClassifier),"Generalized Linear Classifier";case"glmRegressor":return this._createNode(e,i,"glmRegressor",null,r,t.glmRegressor,[t.description.input[0].name],[t.description.output[0].name]),"Generalized Linear Regressor";case"dictVectorizer":return this._createNode(e,i,"dictVectorizer",null,r,t.dictVectorizer,[t.description.input[0].name],[t.description.output[0].name]),"Dictionary Vectorizer";case"featureVectorizer":return this._createNode(e,i,"featureVectorizer",null,r,t.featureVectorizer,coreml.Graph._formatFeatureDescriptionList(t.description.input),[t.description.output[0].name]),"Feature Vectorizer";case"treeEnsembleClassifier":return this._createNode(e,i,"treeEnsembleClassifier",null,r,t.treeEnsembleClassifier.treeEnsemble,[t.description.input[0].name],[t.description.output[0].name]),this._updateClassifierOutput(i,t.treeEnsembleClassifier),"Tree Ensemble Classifier";case"treeEnsembleRegressor":return this._createNode(e,i,"treeEnsembleRegressor",null,r,t.treeEnsembleRegressor.treeEnsemble,[t.description.input[0].name],[t.description.output[0].name]),"Tree Ensemble Regressor";case"supportVectorClassifier":return this._createNode(e,i,"supportVectorClassifier",null,r,{coefficients:t.supportVectorClassifier.coefficients,denseSupportVectors:t.supportVectorClassifier.denseSupportVectors,kernel:t.supportVectorClassifier.kernel,numberOfSupportVectorsPerClass:t.supportVectorClassifier.numberOfSupportVectorsPerClass,probA:t.supportVectorClassifier.probA,probB:t.supportVectorClassifier.probB,rho:t.supportVectorClassifier.rho,supportVectors:t.supportVectorClassifier.supportVectors},[t.description.input[0].name],[t.description.output[0].name]),this._updateClassifierOutput(i,t.supportVectorClassifier),"Support Vector Classifier";case"supportVectorRegressor":return this._createNode(e,i,"supportVectorRegressor",null,r,{coefficients:t.supportVectorRegressor.coefficients,kernel:t.supportVectorRegressor.kernel,rho:t.supportVectorRegressor.rho,supportVectors:t.supportVectorRegressor.supportVectors},[t.description.input[0].name],[t.description.output[0].name]),"Support Vector Regressor";case"arrayFeatureExtractor":return this._createNode(e,i,"arrayFeatureExtractor",null,r,{extractIndex:t.arrayFeatureExtractor.extractIndex},[t.description.input[0].name],[t.description.output[0].name]),"Array Feature Extractor";case"oneHotEncoder":{const s=t.oneHotEncoder.CategoryType,a={outputSparse:t.oneHotEncoder.outputSparse};return a[s]=t.oneHotEncoder[s],this._createNode(e,i,"oneHotEncoder",null,r,a,[t.description.input[0].name],[t.description.output[0].name]),"One Hot Encoder"}case"imputer":{const s=t.imputer.ImputedValue,a=t.imputer.ReplaceValue,n={};return n[s]=t.imputer[s],n[a]=t.imputer[a],this._createNode(e,i,"oneHotEncoder",null,r,n,[t.description.input[0].name],[t.description.output[0].name]),"Imputer"}case"normalizer":return this._createNode(e,i,"normalizer",null,r,t.normalizer,[t.description.input[0].name],[t.description.output[0].name]),"Normalizer";case"wordTagger":return this._createNode(e,i,"wordTagger",null,r,t.wordTagger,[t.description.input[0].name],[t.wordTagger.tokensOutputFeatureName,t.wordTagger.tokenTagsOutputFeatureName,t.wordTagger.tokenLocationsOutputFeatureName,t.wordTagger.tokenLengthsOutputFeatureName]),"Word Tagger";case"textClassifier":return this._createNode(e,i,"textClassifier",null,r,t.textClassifier,[t.description.input[0].name],[t.description.output[0].name]),"Text Classifier";case"nonMaximumSuppression":{const s={pickTop:t.nonMaximumSuppression.pickTop,stringClassLabels:t.nonMaximumSuppression.stringClassLabels,iouThreshold:t.nonMaximumSuppression.iouThreshold,confidenceThreshold:t.nonMaximumSuppression.confidenceThreshold};return this._createNode(e,i,"nonMaximumSuppression",null,r,s,[t.nonMaximumSuppression.confidenceInputFeatureName,t.nonMaximumSuppression.coordinatesInputFeatureName,t.nonMaximumSuppression.iouThresholdInputFeatureName,t.nonMaximumSuppression.confidenceThresholdInputFeatureName],[t.nonMaximumSuppression.confidenceOutputFeatureName,t.nonMaximumSuppression.coordinatesOutputFeatureName]),"Non Maximum Suppression"}case"visionFeaturePrint":{const s={scene:t.visionFeaturePrint.scene};return this._createNode(e,i,"visionFeaturePrint",null,r,s,[t.description.input[0].name],[t.description.output[0].name]),"Vision Feature Print"}case"soundAnalysisPreprocessing":return this._createNode(e,i,"soundAnalysisPreprocessing",null,r,t.soundAnalysisPreprocessing,[t.description.input[0].name],[t.description.output[0].name]),"Sound Analysis Preprocessing";case"kNearestNeighborsClassifier":return this._createNode(e,i,"kNearestNeighborsClassifier",null,r,t.kNearestNeighborsClassifier,[t.description.input[0].name],[t.description.output[0].name]),this._updateClassifierOutput(i,t.kNearestNeighborsClassifier),"Nearest Neighbors Classifier";case"itemSimilarityRecommender":return this._createNode(e,i,"itemSimilarityRecommender",null,r,{itemStringIds:t.itemSimilarityRecommender.itemStringIds.vector,itemItemSimilarities:t.itemSimilarityRecommender.itemItemSimilarities},t.description.input.map(s=>s.name),t.description.output.map(s=>s.name)),"Item Similarity Recommender";case"linkedModel":return this._createNode(e,i,"linkedModel",null,r,t.linkedModel.linkedModelFile,[t.description.input[0].name],[t.description.output[0].name]),"Linked Model";case"customModel":return this._createNode(e,i,"customModel",null,r,{className:t.customModel.className,parameters:t.customModel.parameters},[t.description.input[0].name],[t.description.output[0].name]),"customModel"}throw new coreml.Error("Unknown model type '"+JSON.stringify(Object.keys(t))+"'.")}_createNode(t,e,i,r,s,a,n,o){n=n.map(u=>t[u]?t[u].argument:u),o=o.map(u=>{if(t[u]){t[u].counter++;const l=u+`
`+t[u].counter.toString();return t[u].argument=l,l}return t[u]={argument:u,counter:0},u});const p=new coreml.Node(this._metadata,e,i,r,s,a,n,o);return this._nodes.push(p),p}static _formatFeatureType(t){let e="?";if(t){switch(t.Type){case"multiArrayType":{let i=new coreml.TensorShape([]);t.multiArrayType.shape&&t.multiArrayType.shape.length>0&&(i=new coreml.TensorShape(t.multiArrayType.shape));let r="?";switch(t.multiArrayType.dataType){case coreml.proto.ArrayFeatureType.ArrayDataType.FLOAT32:r="float32";break;case coreml.proto.ArrayFeatureType.ArrayDataType.INT32:r="int32";break;case coreml.proto.ArrayFeatureType.ArrayDataType.DOUBLE:r="float64"}e=new coreml.TensorType(r,i);break}case"stringType":e=new coreml.TensorType("string");break;case"doubleType":e=new coreml.TensorType("float64");break;case"int64Type":e=new coreml.TensorType("int64");break;case"dictionaryType":e=new coreml.MapType(t.dictionaryType.KeyType.replace("KeyType",""),"float64");break;case"imageType":e=new coreml.ImageType(t.imageType.colorSpace,t.imageType.width,t.imageType.height)}t.isOptional&&(e=new coreml.OptionalType(e))}return e}static _formatFeatureDescriptionList(t){return t.map(e=>e.name)}},coreml.Parameter=class{constructor(t,e,i){this._name=t,this._visible=e,this._arguments=i}get name(){return this._name}get visible(){return this._visible}get arguments(){return this._arguments}},coreml.Argument=class{constructor(t,e,i,r){if(typeof t!="string")throw new coreml.Error("Invalid argument identifier '"+JSON.stringify(t)+"'.");this._name=t,this._type=e,this._description=i||null,this._initializer=r||null}get name(){return this._name}set name(t){this._name=t}get type(){return this._initializer?this._initializer.type:this._type}get description(){return this._description}get quantization(){return this._initializer?this._initializer.quantization:null}get initializer(){return this._initializer}},coreml.Node=class{constructor(t,e,i,r,s,a,n,o){if(this._metadata=t,e&&(this._group=e),!i)throw new Error("Undefined node type.");this._type=i,this._name=r||"",this._description=s||"",this._attributes=[];const p=[];if(a){const u=this._initialize(a,p);for(const l of Object.keys(a))if(!u[l]){const c=t.attribute(this.type,l);this._attributes.push(new coreml.Attribute(c,l,a[l]))}}this._inputs=this._metadata.getInputs(this._type,n).map(u=>new coreml.Parameter(u.name,!0,u.arguments.map(l=>new coreml.Argument(l.name,l.type,null,null)))),this._inputs=this._inputs.concat(p),this._outputs=o.map((u,l)=>{const c=this._metadata.getOutputName(this._type,l);return new coreml.Parameter(c,!0,[new coreml.Argument(u,null,null,null)])})}get type(){return this._type}get name(){return this._name}get description(){return this._description}get metadata(){return this._metadata.type(this.type)}get group(){return this._group?this._group:null}get inputs(){return this._inputs}get outputs(){return this._outputs}get attributes(){return this._attributes}_initialize(t,e){switch(this._type){case"convolution":{const i=[t.outputChannels,t.kernelChannels,t.kernelSize[0],t.kernelSize[1]];return t.isDeconvolution&&(i[0]=t.kernelChannels,i[1]=Math.floor(t.outputChannels/(t.nGroups!=0?t.nGroups:1))),this._initializer(e,"Weights","weights",i,t.weights),t.hasBias&&this._initializer(e,"Weights","bias",[t.outputChannels],t.bias),{weights:!0,bias:t.hasBias}}case"innerProduct":return this._initializer(e,"Weights","weights",[t.outputChannels,t.inputChannels],t.weights),t.hasBias&&this._initializer(e,"Weights","bias",[t.outputChannels],t.bias),{weights:!0,bias:t.hasBias};case"batchnorm":return this._initializer(e,"Weights","gamma",[t.channels],t.gamma),this._initializer(e,"Weights","beta",[t.channels],t.beta),t.mean&&this._initializer(e,"Weights","mean",[t.channels],t.mean),t.variance&&this._initializer(e,"Weights","variance",[t.channels],t.variance),{gamma:!0,beta:!0,mean:!0,variance:!0};case"embedding":return this._initializer(e,"Weights","weights",[t.inputDim,t.outputChannels],t.weights),{weights:!0};case"loadConstant":return this._initializer(e,"Weights","data",t.shape,t.data),{data:!0};case"scale":return this._initializer(e,"Weights","scale",t.shapeScale,t.scale),t.hasBias&&this._initializer(e,"Weights","bias",t.shapeBias,t.bias),{scale:!0,bias:t.hasBias};case"bias":return this._initializer(e,"Weights","bias",t.shape,t.bias),{bias:!0};case"simpleRecurrent":return this._initializer(e,"Weights","weights",[t.outputVectorSize,t.inputVectorSize],t.weightMatrix),this._initializer(e,"Weights","recurrent",[t.outputVectorSize,t.inputVectorSize],t.recursionMatrix),t.hasBiasVectors&&this._initializer(e,"Weights","bias",[t.outputVectorSize],t.biasVector),{weightMatrix:!0,recursionMatrix:!0,biasVector:t.hasBiasVectors};case"gru":{const i=[t.outputVectorSize,t.outputVectorSize],r=[t.outputVectorSize,t.inputVectorSize],s=[t.outputVectorSize];return this._initializer(e,"Weights","updateGateWeightMatrix",r,t.updateGateWeightMatrix),this._initializer(e,"Weights","resetGateWeightMatrix",r,t.resetGateWeightMatrix),this._initializer(e,"Weights","outputGateWeightMatrix",r,t.outputGateWeightMatrix),this._initializer(e,"Weights","updateGateRecursionMatrix",i,t.updateGateRecursionMatrix),this._initializer(e,"Weights","resetGateRecursionMatrix",i,t.resetGateRecursionMatrix),this._initializer(e,"Weights","outputGateRecursionMatrix",i,t.outputGateRecursionMatrix),t.hasBiasVectors&&(this._initializer(e,"Weights","updateGateBiasVector",s,t.updateGateBiasVector),this._initializer(e,"Weights","resetGateBiasVector",s,t.resetGateBiasVector),this._initializer(e,"Weights","outputGateBiasVector",s,t.outputGateBiasVector)),{updateGateWeightMatrix:!0,resetGateWeightMatrix:!0,outputGateWeightMatrix:!0,updateGateRecursionMatrix:!0,resetGateRecursionMatrix:!0,outputGateRecursionMatrix:!0,updateGateBiasVector:t.hasBiasVectors,resetGateBiasVector:t.hasBiasVectors,outputGateBiasVector:t.hasBiasVectors}}case"uniDirectionalLSTM":case"biDirectionalLSTM":{const i=this._type=="uniDirectionalLSTM"?1:2,r=[t.outputVectorSize,t.inputVectorSize],s=[t.outputVectorSize];for(let a=0;a<i;a++){const n=i==1?t.weightParams:t.weightParams[a],o=a==0?"":"_rev";this._initializer(e,"Weights","inputGateWeightMatrix"+o,r,n.inputGateWeightMatrix),this._initializer(e,"Weights","forgetGateWeightMatrix"+o,r,n.forgetGateWeightMatrix),this._initializer(e,"Weights","blockInputWeightMatrix"+o,r,n.blockInputWeightMatrix),this._initializer(e,"Weights","outputGateWeightMatrix"+o,r,n.outputGateWeightMatrix),this._initializer(e,"Weights","inputGateRecursionMatrix"+o,r,n.inputGateRecursionMatrix),this._initializer(e,"Weights","forgetGateRecursionMatrix"+o,r,n.forgetGateRecursionMatrix),this._initializer(e,"Weights","blockInputRecursionMatrix"+o,r,n.blockInputRecursionMatrix),this._initializer(e,"Weights","outputGateRecursionMatrix"+o,r,n.outputGateRecursionMatrix),t.params.hasBiasVectors&&(this._initializer(e,"Weights","inputGateBiasVector"+o,s,n.inputGateBiasVector),this._initializer(e,"Weights","forgetGateBiasVector"+o,s,n.forgetGateBiasVector),this._initializer(e,"Weights","blockInputBiasVector"+o,s,n.blockInputBiasVector),this._initializer(e,"Weights","outputGateBiasVector"+o,s,n.outputGateBiasVector)),t.params.hasPeepholeVectors&&(this._initializer(e,"Weights","inputGatePeepholeVector"+o,s,n.inputGatePeepholeVector),this._initializer(e,"Weights","forgetGatePeepholeVector"+o,s,n.forgetGatePeepholeVector),this._initializer(e,"Weights","outputGatePeepholeVector"+o,s,n.outputGatePeepholeVector))}return{weightParams:!0}}case"dictVectorizer":return t.stringToIndex=this._convertVector(t.stringToIndex),{};case"wordTagger":return t.modelParameterData=Array.from(t.modelParameterData),t.stringTags=this._convertVector(t.stringTags),{tokensOutputFeatureName:!0,tokenTagsOutputFeatureName:!0,tokenLengthsOutputFeatureName:!0,tokenLocationsOutputFeatureName:!0};case"textClassifier":return t.modelParameterData=Array.from(t.modelParameterData),t.stringClassLabels=this._convertVector(t.stringClassLabels),{};case"nonMaximumSuppression":return t.stringClassLabels=this._convertVector(t.stringClassLabels),{}}return{}}_convertVector(t){return t&&Object.keys(t).length==1&&t.vector?t.vector:t}_initializer(t,e,i,r,s){const a=new coreml.Tensor(e,i,r,s),n=new coreml.Argument("",null,null,a);let o=!0;const p=this._metadata.getInputSchema(this._type,i);p&&Object.prototype.hasOwnProperty.call(p,"visible")&&!p.visible&&(o=!1),t.push(new coreml.Parameter(i,o,[n]))}},coreml.Attribute=class{constructor(t,e,i){if(this._name=e,this._value=i,t){if(t.type&&(this._type=t.type),this._type&&coreml.proto){let r=coreml.proto;const s=this._type.split(".");for(;r&&s.length>0;)r=r[s.shift()];r&&r[this._value]&&(this._value=r[this.value])}Object.prototype.hasOwnProperty.call(t,"visible")&&!t.visible?this._visible=!1:Object.prototype.hasOwnProperty.call(t,"default")&&(Array.isArray(i)&&(i=i.map(r=>r&&long.Long.isLong(r)?r.toNumber():r)),JSON.stringify(t.default)==JSON.stringify(i)&&(this._visible=!1))}}get name(){return this._name}get type(){return this._type}get value(){return this._value}get visible(){return this._visible!=0}},coreml.Tensor=class{constructor(t,e,i,r){this._kind=t,this._name=e,this._data=null;let s="?";r&&(r.floatValue&&r.floatValue.length>0?(this._data=r.floatValue,s="float32"):r.float16Value&&r.float16Value.length>0?(this._data=r.float16Value,s="float16"):r.rawValue&&r.rawValue.length>0&&(r.quantization?(this._data=r.rawValue,s="uint"+r.quantization.numberOfBits.toString()):i=[]),this._quantization=r.quantization||null),this._type=new coreml.TensorType(s,new coreml.TensorShape(i))}get name(){return this._name}get kind(){return this._kind}get type(){return this._type}get quantization(){if(this._quantization){if(this._quantization.lookupTableQuantization&&this._quantization.lookupTableQuantization.floatValue&&this._quantization.lookupTableQuantization.floatValue.length>0){const t=[];for(const e of Object.keys(this._quantization.lookupTableQuantization.floatValue))t.push(e.toString()+" = "+this._quantization.lookupTableQuantization.floatValue[e].toString());return t.join("; ")}return"?"}return null}get state(){return this._context().state}get value(){const t=this._context();return t.state?null:(t.limit=Number.MAX_SAFE_INTEGER,this._decode(t,0))}toString(){const t=this._context();if(t.state)return"";t.limit=1e4;const e=this._decode(t,0);return JSON.stringify(e,null,4)}_context(){const t={state:null,index:0,count:0};if(t.dataType=this._type.dataType,t.dimensions=this._type.shape.dimensions,!this._data)return t.state="Tensor data is empty.",t;switch(t.dataType){case"float32":t.data=this._data;break;case"float16":t.data=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength);break;default:this._quantization?(t.dataType="quantization",t.bits=long.Long.isLong(this._quantization.numberOfBits)?this._quantization.numberOfBits.toNumber():this._quantization.numberOfBits,t.data=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength)):t.state="Tensor data type is not implemented."}return t}_decode(t,e){const i=[],r=t.dimensions[e];if(e==t.dimensions.length-1)for(let s=0;s<r;s++){if(t.count>t.limit)return i.push("..."),i;switch(t.dataType){case"float32":i.push(this._data[t.index]),t.index++;break;case"float16":i.push(t.data.getFloat16(t.index,!0)),t.index+=2;break;case"quantization":i.push(t.data.getBits(t.index,t.bits)),t.index++}t.count++}else for(let s=0;s<r;s++){if(t.count>t.limit)return i.push("..."),i;i.push(this._decode(t,e+1))}return i}},coreml.TensorType=class{constructor(t,e){this._dataType=t,this._shape=e||new coreml.TensorShape([])}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return this.dataType+this._shape.toString()}},coreml.TensorShape=class{constructor(t){this._dimensions=t}get dimensions(){return this._dimensions}toString(){return this._dimensions&&this._dimensions.length!=0?"["+this._dimensions.map(t=>t.toString()).join(",")+"]":""}},coreml.MapType=class{constructor(t,e){this._keyType=t,this._valueType=e}get keyType(){return this._keyType}get valueType(){return this._valueType}toString(){return"map<"+this._keyType+","+this._valueType.toString()+">"}},coreml.ImageType=class{constructor(t,e,i){switch(this._colorSpace="?",t){case coreml.proto.ImageFeatureType.ColorSpace.GRAYSCALE:this._colorSpace="Grayscale";break;case coreml.proto.ImageFeatureType.ColorSpace.RGB:this._colorSpace="RGB";break;case coreml.proto.ImageFeatureType.ColorSpace.BGR:this._colorSpace="BGR"}this._width=e,this._height=i}toString(){return"image<"+this._colorSpace+","+this._width.toString()+"x"+this._height.toString()+">"}},coreml.OptionalType=class{constructor(t){this._type=t}toString(){return this._type.toString()+"?"}},coreml.Metadata=class{static open(t){return coreml.Metadata._metadata?Promise.resolve(coreml.Metadata._metadata):t.request(null,"coreml-metadata.json","utf-8").then(e=>(coreml.Metadata._metadata=new coreml.Metadata(e),coreml.Metadata._metadata)).catch(()=>(coreml.Metadata._metadata=new coreml.Metadata(null),coreml.Metadata._metadata))}constructor(t){if(this._map=new Map,this._attributeCache=new Map,this._inputCache={},t){const e=JSON.parse(t);if(e)for(const i of e)i.name&&i.schema&&(i.schema.name=i.name,this._map.set(i.name,i.schema))}}type(t){return this._map.get(t)}attribute(t,e){const i=t+":"+e;if(!this._attributeCache.has(i)){const r=this.type(t);if(r&&r.attributes&&r.attributes.length>0)for(const s of r.attributes)this._attributeCache.set(t+":"+s.name,s);this._attributeCache.has(i)||this._attributeCache.set(i,null)}return this._attributeCache.get(i)}getInputSchema(t,e){let i=this._inputCache[t];if(!i){i={};const r=this.type(t);if(r&&r.inputs&&r.inputs.length>0)for(const s of r.inputs)i[s.name]=s;this._inputCache[t]=i}return i[e]||null}getInputs(t,e){const i=[],r=this._map[t];let s=0;for(;s<e.length;){const a={arguments:[]};let n=1,o=null;r&&r.inputs?s<r.inputs.length&&(o=r.inputs[s].name,r.inputs[s].option=="variadic"&&(n=e.length-s)):s==0&&(o="input"),a.name=o||"("+s.toString()+")";const p=e.slice(s,s+n);for(let u=0;u<p.length;u++)a.arguments.push({name:p[u]});s+=n,i.push(a)}return i}getOutputName(t,e){const i=this._map[t];if(i){const r=i.outputs;if(r&&e<r.length){const s=r[e];if(s){const a=s.name;if(a)return a}}}return e==0?"output":"("+e.toString()+")"}},coreml.Error=class extends Error{constructor(t){super(t),this.name="Error loading Core ML model."}},typeof module!="undefined"&&typeof module.exports=="object"&&(module.exports.ModelFactory=coreml.ModelFactory);
