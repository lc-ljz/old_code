var armnn=armnn||{},base=base||require("./base"),flatbuffers=flatbuffers||require("./flatbuffers"),long=long||{Long:require("long")};armnn.ModelFactory=class{match(t){const n=t.identifier.split(".").pop().toLowerCase();if(n=="armnn")return!0;if(n==="json"){const s=t.text;if(s.indexOf('"layers"',0)!==-1&&s.indexOf('"layer_type"',0)!==-1)return!0}return!1}open(t,n){return n.require("./armnn-schema").then(s=>{armnn.schema=flatbuffers.get("armnn").armnnSerializer;const r=t.identifier;let a=null;try{switch(r.split(".").pop().toLowerCase()){case"armnn":{const e=new flatbuffers.Reader(t.buffer);a=armnn.schema.SerializedGraph.create(e);break}case"json":{const e=new flatbuffers.TextReader(t.text);a=armnn.schema.SerializedGraph.createText(e);break}}}catch(e){n.exception(e,!1);const i=e&&e.message?e.message:e.toString();throw new armnn.Error(i.replace(/\.$/,"")+" in '"+r+"'.")}return armnn.Metadata.open(n).then(e=>{try{return new armnn.Model(e,a)}catch(i){const o=i&&i.message?i.message:i.toString();throw new new armnn.Error(o.replace(/\.$/,"")+" in '"+r+"'.")}})})}},armnn.Model=class{constructor(t,n){this._graphs=[],this._graphs.push(new armnn.Graph(t,n))}get format(){return"Arm NN"}get description(){return""}get graphs(){return this._graphs}},armnn.Graph=class{constructor(t,n){this._name="",this._nodes=[],this._inputs=[],this._outputs=[];const s={};for(let r=0;r<n.layers.length;r++){const a=armnn.Node.getBase(n.layers[r]);for(let e=0;e<a.outputSlots.length;e++){const i=a.index.toString()+":"+e.toString();s[i]=new armnn.Argument(i,a.outputSlots[e].tensorInfo,null)}}for(let r=0;r<n.layers.length;r++){const a=n.layers[r];switch(a.layer.constructor.name){case"InputLayer":{const e=armnn.Node.getBase(a),i=e?e.layerName:"";for(let o=0;o<e.outputSlots.length;o++){const u=s[e.index.toString()+":"+o.toString()];this._inputs.push(new armnn.Parameter(i,[u]))}break}case"OutputLayer":{const e=armnn.Node.getBase(a),i=e?e.layerName:"";for(let o=0;o<e.inputSlots.length;o++){const u=e.inputSlots[o].connection,h=u.sourceLayerIndex,c=u.outputSlotIndex,p=s[h.toString()+":"+c.toString()];this._outputs.push(new armnn.Parameter(i,[p]))}break}default:this._nodes.push(new armnn.Node(t,a,s))}}}get name(){return this._name}get groups(){return!1}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}},armnn.Node=class{constructor(t,n,s){this._metadata=t,this._type=n.layer.constructor.name,this._name="",this._outputs=[],this._inputs=[],this._attributes=[];const r=armnn.Node.getBase(n);if(r){this._name=r.layerName;for(let e=0;e<r.inputSlots.length;e++){const i=r.inputSlots[e].connection,o=i.sourceLayerIndex,u=i.outputSlotIndex,h=s[o.toString()+":"+u.toString()];this._inputs.push(new armnn.Parameter("input",[h]))}for(let e=0;e<r.outputSlots.length;e++){const i=s[r.index.toString()+":"+e.toString()];this._outputs.push(new armnn.Parameter("output",[i]))}}const a=this._metadata.type(this._type);if(a){const e=armnn.Node.castLayer(n);if(a.bindings)for(let i=0;i<a.bindings.length;i++){const o=a.bindings[i],u=e.base()[o.src]();this._attributes.push(new armnn.Attribute(o.name,o.type,u))}if(a.attributes)for(const i of a.attributes){const o=this.packAttr(e,i);this._attributes.push(new armnn.Attribute(i.name,i.type,o))}if(a.inputs)for(let i=0;i<a.inputs.length;i++){const o=a.inputs[i],u=e[o.src];if(u){const h=[new armnn.Argument("",null,u)];this._inputs.push(new armnn.Parameter(o.name,h))}}}}get type(){return this._type.replace(/Layer$/,"")}get name(){return this._name}get domain(){return null}get metadata(){return this._metadata.type(this._type)}get group(){return null}get inputs(){return this._inputs}get outputs(){return this._outputs}get attributes(){return this._attributes}static castLayer(t){return t.layer}static getBase(t){return(t=armnn.Node.castLayer(t)).base.base?t.base.base:t.base}getAttr(t,n){if(t[n]===void 0)return"undefined";const s=t[n];return Array.isArray(s)?s.join(", "):s}packAttr(t,n){const s=t===null?null:t.descriptor,r=n.src,a=n.src_type;if(a!==void 0){const e=this.getAttr(s,r);return armnn.schema[a+"Name"]!==void 0?armnn.schema[a+"Name"][e]:e}if(Array.isArray(r)){const e=[];for(let i=0;i<r.length;i++)e.push(this.getAttr(s,r[i]));return e.join(", ")}return this.getAttr(s,r)}static makeKey(t,n){return t.toString()+"_"+n.toString()}},armnn.Attribute=class{constructor(t,n,s){switch(this._name=t,this._value=s,this._visible=!0,n){case"int":this._type="int32";break;case"uint":this._type="uint32";break;case"float":this._type="float32";break;case"string":this._type="string"}}get name(){return this._name}get type(){return this._type}get value(){return this._value}get visible(){return this._visible!=0}},armnn.Parameter=class{constructor(t,n){this._name=t,this._arguments=n}get name(){return this._name}get visible(){return!0}get arguments(){return this._arguments}},armnn.Argument=class{constructor(t,n,s){if(typeof t!="string")throw new armnn.Error("Invalid argument identifier '"+JSON.stringify(t)+"'.");const r=s?s.info:n;this._name=t,this._type=new armnn.TensorType(r),this._initializer=s?new armnn.Tensor(r,s):null,this._type.dataType.startsWith("q")&&r&&(this._scale=r.quantizationScale,this._zeroPoint=r.quantizationOffset)}get name(){return this._name}get type(){return this._type}get quantization(){if(this._scale!==void 0&&this._zeroPoint!==void 0)return this._scale.toString()+" * "+(this._zeroPoint==0?"q":"(q - "+this._zeroPoint.toString()+")")}get initializer(){return this._initializer}},armnn.Tensor=class{constructor(t,n){this._name="",this._type=new armnn.TensorType(t),this._kind="Initializer",this._data=n.data.data.slice(0)}get name(){return this._name}get kind(){return this._kind}get type(){return this._type}get state(){return this._context().state}get value(){const t=this._context();return t.state?null:(t.limit=Number.MAX_SAFE_INTEGER,this._decode(t,0))}toString(){const t=this._context();if(t.state)return"";t.limit=1e4;const n=this._decode(t,0);return JSON.stringify(n,null,4)}_context(){const t={state:null,index:0,count:0};return this._data==null?(t.state="Tensor data is empty.",t):(t.dataType=this._type.dataType,t.shape=this._type.shape.dimensions,t.data=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength),t)}_decode(t,n){let s=t.shape;s.length==0&&(s=[1]);const r=s[n],a=[];if(n==s.length-1)for(let e=0;e<r;e++){if(t.count>t.limit)return a.push("..."),a;switch(t.dataType){case"float16":a.push(t.data.getFloat16(t.index,!0)),t.index+=2,t.count++;break;case"float32":a.push(t.data.getFloat32(t.index,!0)),t.index+=4,t.count++;break;case"quint8":a.push(t.data.getUint8(t.index)),t.index+=1,t.count++;break;case"qint16":a.push(t.data.getInt16(t.index,!0)),t.index+=2,t.count++;break;case"int32":a.push(t.data.getInt32(t.index,!0)),t.index+=4,t.count++;break;case"boolean":a.push(t.data.getInt8(t.index)),t.index+=1,t.count++}}else for(let e=0;e<r;e++){if(t.count>t.limit)return a.push("..."),a;a.push(this._decode(t,n+1))}return t.shape.length==0?a[0]:a}},armnn.TensorType=class{constructor(t){const n=t.dataType;switch(n){case 0:this._dataType="float16";break;case 1:this._dataType="float32";break;case 2:this._dataType="quint8";break;case 3:this._dataType="int32";break;case 4:this._dataType="boolean";break;case 5:this._dataType="qint16";break;case 6:this._dataType="quint8";break;case 7:this._dataType="qint16";break;default:throw new armnn.Error("Unknown data type '"+JSON.stringify(n)+"'.")}this._shape=new armnn.TensorShape(t.dimensions)}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return this.dataType+this._shape.toString()}},armnn.TensorShape=class{constructor(t){this._dimensions=Array.from(t)}get dimensions(){return this._dimensions}toString(){return this._dimensions&&this._dimensions.length!=0?"["+this._dimensions.map(t=>t.toString()).join(",")+"]":""}},armnn.Metadata=class{static open(t){return armnn.Metadata._metadata?Promise.resolve(armnn.Metadata._metadata):t.request(null,"armnn-metadata.json","utf-8").then(n=>(armnn.Metadata._metadata=new armnn.Metadata(n),armnn.Metadata._metadata)).catch(()=>(armnn.Metadata._metadata=new armnn.Metadata(null),armnn.Metadata._metadata))}constructor(t){if(this._map={},t){const n=JSON.parse(t);if(n)for(const s of n)s.name&&s.schema&&(s.schema.name=s.name,this._map[s.name]=s.schema)}}type(t){return this._map[t]}attribute(t,n){const s=this.type(t);if(s){let r=s.attributeMap;if(!r){if(r={},s.attributes)for(const e of s.attributes)r[e.name]=e;s.attributeMap=r}const a=r[n];if(a)return a}return null}},armnn.Error=class extends Error{constructor(t){super(t),this.name="Error loading Arm NN model."}},typeof module!="undefined"&&typeof module.exports=="object"&&(module.exports.ModelFactory=armnn.ModelFactory);
